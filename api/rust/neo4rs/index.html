<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Neo4j driver compatible with neo4j 4.x versions"><title>neo4rs - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="neo4rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../neo4rs/index.html">neo4rs</a><span class="version">0.7.1</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../neo4rs/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">neo4rs</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/neo4rs/lib.rs.html#1-454">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Neo4j driver compatible with neo4j 4.x versions</p>
<ul>
<li>An implementation of the <a href="https://7687.org/">bolt protocol</a> to interact with Neo4j server</li>
<li>async/await apis using <a href="https://github.com/tokio-rs/tokio">tokio</a></li>
<li>Supports bolt 4.2 specification</li>
<li>tested with Neo4j versions: 4.0, 4.1, 4.2</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>id = uuid::Uuid::new_v4().to_string();

   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span>id = uuid::Uuid::new_v4().to_string();
    graph
        .run(query(<span class="string">"CREATE (p:Person {id: $id})"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>handles = Vec::new();
    <span class="kw">let </span>count = std::sync::Arc::new(std::sync::atomic::AtomicU32::new(<span class="number">0</span>));
    <span class="kw">for _ in </span><span class="number">1</span>..=<span class="number">42 </span>{
        <span class="kw">let </span>graph = graph.clone();
        <span class="kw">let </span>id = id.clone();
        <span class="kw">let </span>count = count.clone();
        <span class="kw">let </span>handle = tokio::spawn(<span class="kw">async move </span>{
            <span class="kw">let </span><span class="kw-2">mut </span>result = graph
                .execute(query(<span class="string">"MATCH (p:Person {id: $id}) RETURN p"</span>).param(<span class="string">"id"</span>, id))
                .<span class="kw">await
                </span>.unwrap();
            <span class="kw">while let </span><span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(_row)) = result.next().<span class="kw">await </span>{
                count.fetch_add(<span class="number">1</span>, std::sync::atomic::Ordering::Relaxed);
            }
        });
        handles.push(handle);
    }

    futures::future::join_all(handles).<span class="kw">await</span>;
    <span class="macro">assert_eq!</span>(count.load(std::sync::atomic::Ordering::Relaxed), <span class="number">42</span>);
}
}</code></pre></div>
<h3 id="configurations"><a href="#configurations">Configurations</a></h3>
<p>Use the config builder to override the default configurations like</p>
<ul>
<li><code>fetch_size</code> - number of rows to fetch in batches (default is 200)</li>
<li><code>max_connections</code> - maximum size of the connection pool (default is 16)</li>
<li><code>db</code> - the database to connect to (default is <code>neo4j</code>)</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>config = ConfigBuilder::default()
       .uri(<span class="string">"127.0.0.1:7687"</span>)
       .user(<span class="string">"neo4j"</span>)
       .password(<span class="string">"neo"</span>)
       .db(<span class="string">"neo4j"</span>)
       .fetch_size(<span class="number">500</span>)
       .max_connections(<span class="number">10</span>)
       .build()
       .unwrap();
   <span class="kw">let </span>graph = Graph::connect(config).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph.execute(query(<span class="string">"RETURN 1"</span>)).<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>value: i64 = row.get(<span class="string">"1"</span>).unwrap();
    <span class="macro">assert_eq!</span>(<span class="number">1</span>, value);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}</code></pre></div>
<h3 id="nodes"><a href="#nodes">Nodes</a></h3>
<p>A simple example to create a node and consume the created node from the row stream.</p>
<ul>
<li><a href="struct.Graph.html#method.run" title="method neo4rs::Graph::run"><code>Graph::run</code></a> just returns <a href="type.Result.html" title="type neo4rs::Result"><code>errors::Result</code></a><code>&lt;()&gt;</code>, usually used for write only queries.</li>
<li><a href="struct.Graph.html#method.execute" title="method neo4rs::Graph::execute"><code>Graph::execute</code></a> returns <a href="type.Result.html" title="type neo4rs::Result"><code>errors::Result</code></a><code>&lt;</code><a href="struct.RowStream.html" title="struct neo4rs::RowStream"><code>RowStream</code></a><code>&gt;</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="macro">assert!</span>(graph.run(query(<span class="string">"RETURN 1"</span>)).<span class="kw">await</span>.is_ok());

    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(
            query(<span class="string">"CREATE (friend:Person {name: $name}) RETURN friend"</span>).param(<span class="string">"name"</span>, <span class="string">"Mr Mark"</span>),
        )
        .<span class="kw">await
        </span>.unwrap();

    <span class="attr">#[derive(serde::Deserialize)]
    </span><span class="kw">struct </span>Person {
        labels: Labels,
        keys: Keys&lt;Vec&lt;String&gt;&gt;,
        name: String,
    }

    <span class="kw">while let </span><span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(row)) = result.next().<span class="kw">await </span>{
        <span class="comment">// use serde to extract the relationship data
        </span><span class="kw">let </span>friend: Person = row.get(<span class="string">"friend"</span>).unwrap();
        <span class="macro">assert_eq!</span>(friend.name, <span class="string">"Mr Mark"</span>);
        <span class="macro">assert_eq!</span>(friend.labels.<span class="number">0</span>, <span class="macro">vec!</span>[<span class="string">"Person"</span>]);
        <span class="macro">assert_eq!</span>(friend.keys.<span class="number">0</span>, <span class="macro">vec!</span>[<span class="string">"name"</span>]);

        <span class="comment">// or use the neo4rs::Relation type
        </span><span class="kw">let </span>node: Node = row.get(<span class="string">"friend"</span>).unwrap();
        <span class="macro">assert_eq!</span>(node.get::&lt;String&gt;(<span class="string">"name"</span>).unwrap(), <span class="string">"Mr Mark"</span>);
        <span class="macro">assert_eq!</span>(node.labels(), <span class="macro">vec!</span>[<span class="string">"Person"</span>]);
        <span class="macro">assert_eq!</span>(node.keys(), <span class="macro">vec!</span>[<span class="string">"name"</span>]);
        <span class="macro">assert!</span>(node.id() &gt;= <span class="number">0</span>);
    }
}
}</code></pre></div>
<h3 id="transactions"><a href="#transactions">Transactions</a></h3>
<p>Start a new transaction using <a href="struct.Graph.html#method.start_txn" title="method neo4rs::Graph::start_txn"><code>Graph::start_txn</code></a>, which will return a handle <a href="struct.Txn.html" title="struct neo4rs::Txn"><code>Txn</code></a> that can
be used to <a href="struct.Txn.html#method.commit" title="method neo4rs::Txn::commit"><code>Txn::commit</code></a> or <a href="struct.Txn.html#method.rollback" title="method neo4rs::Txn::rollback"><code>Txn::rollback</code></a> the transaction.</p>
<p>Note that the handle takes a connection from the connection pool, which will be released once
the Txn is dropped</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{
    <span class="kw">let </span><span class="kw-2">mut </span>txn = graph.start_txn().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>id = uuid::Uuid::new_v4().to_string();
    <span class="kw">let </span>result = txn
        .run_queries([
            query(<span class="string">"CREATE (p:Person {id: $id})"</span>).param(<span class="string">"id"</span>, id.clone()),
            query(<span class="string">"CREATE (p:Person {id: $id})"</span>).param(<span class="string">"id"</span>, id.clone()),
        ])
        .<span class="kw">await</span>;

    <span class="macro">assert!</span>(result.is_ok());
    txn.commit().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"MATCH (p:Person) WHERE p.id = $id RETURN p.id"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_some());
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_some());
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h4 id="streams-within-a-transaction"><a href="#streams-within-a-transaction">Streams within a transaction</a></h4>
<p>Each <a href="struct.RowStream.html" title="struct neo4rs::RowStream"><code>RowStream</code></a> returned by various execute functions within the same
transaction are well isolated, so you can consume the stream anytime
within the transaction using <a href="struct.RowStream.html#method.next" title="method neo4rs::RowStream::next"><code>RowStream::next</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>config = ConfigBuilder::default()
       .uri(<span class="string">"127.0.0.1:7687"</span>)
       .user(<span class="string">"neo4j"</span>)
       .password(<span class="string">"neo"</span>)
       .fetch_size(<span class="number">1</span>)
       .build()
       .unwrap();
   <span class="kw">let </span>graph = Graph::connect(config).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span>name = uuid::Uuid::new_v4().to_string();
    <span class="kw">let </span><span class="kw-2">mut </span>txn = graph.start_txn().<span class="kw">await</span>.unwrap();

    <span class="attr">#[derive(serde::Deserialize)]
    </span><span class="kw">struct </span>Person {
        name: String,
    }

    txn.run_queries([
        query(<span class="string">"CREATE (p { name: $name })"</span>).param(<span class="string">"name"</span>, name.clone()),
        query(<span class="string">"CREATE (p { name: $name })"</span>).param(<span class="string">"name"</span>, name.clone()),
    ])
        .<span class="kw">await
        </span>.unwrap();

    <span class="comment">//start stream_one
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream_one = txn
        .execute(query(<span class="string">"MATCH (p {name: $name}) RETURN p"</span>).param(<span class="string">"name"</span>, name.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = stream_one.next(txn.handle()).<span class="kw">await</span>.unwrap().unwrap();
    <span class="macro">assert_eq!</span>(row.to::&lt;Person&gt;().unwrap().name, name);

    <span class="comment">//start stream_two
    </span><span class="kw">let </span><span class="kw-2">mut </span>stream_two = txn.execute(query(<span class="string">"RETURN 1"</span>)).<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>row = stream_two.next(txn.handle()).<span class="kw">await</span>.unwrap().unwrap();
    <span class="macro">assert_eq!</span>(row.to::&lt;i64&gt;().unwrap(), <span class="number">1</span>);

    <span class="comment">//stream_one is still active here
    </span><span class="kw">let </span>row = stream_one.next(txn.handle()).<span class="kw">await</span>.unwrap().unwrap();
    <span class="macro">assert_eq!</span>(row.to::&lt;Person&gt;().unwrap().name, name);

    <span class="comment">//stream_one completes
    </span><span class="macro">assert!</span>(stream_one.next(txn.handle()).<span class="kw">await</span>.unwrap().is_none());
    <span class="comment">//stream_two completes
    </span><span class="macro">assert!</span>(stream_two.next(txn.handle()).<span class="kw">await</span>.unwrap().is_none());
    txn.commit().<span class="kw">await</span>.unwrap();
}
}
</code></pre></div>
<h4 id="streams-are-evaluated-lazily"><a href="#streams-are-evaluated-lazily">Streams are evaluated lazily</a></h4>
<p>The <a href="struct.RowStream.html" title="struct neo4rs::RowStream"><code>RowStream</code></a> returned by various <code>execute</code> functions need to be
consumed with <a href="struct.RowStream.html#method.next" title="method neo4rs::RowStream::next"><code>RowStream::next</code></a> in order to actually execute the
query.
The various <code>run</code> functions on the other hand are always executed
eagerly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{
    <span class="kw">let </span>before = graph
        .execute(query(<span class="string">"MATCH (n:MyNode) RETURN COUNT(n) AS n"</span>))
        .<span class="kw">await
        </span>.unwrap()
        .next()
        .<span class="kw">await
        </span>.unwrap()
        .unwrap()
        .get::&lt;i64&gt;(<span class="string">"n"</span>)
        .unwrap();

    <span class="comment">// use `run` for fire-and-forget queries, that are being executed on the server
    </span>graph
        .run(query(<span class="string">"CREATE (n:MyNode {p: 'prop'})"</span>))
        .<span class="kw">await
        </span>.unwrap();

    <span class="comment">// using `execute` without consuming the result will do nothing
    // This will trigger a `unused_must_use` warning
    </span>graph
        .execute(query(<span class="string">"CREATE (n:MyNode {p: 'prop'})"</span>))
        .<span class="kw">await
        </span>.unwrap();

    <span class="comment">// consuming the result stream of`execute` will run the query on the server
    </span>graph
        .execute(query(<span class="string">"CREATE (n:MyNode {p: 'prop'})"</span>))
        .<span class="kw">await
        </span>.unwrap()
        .next()
        .<span class="kw">await
        </span>.unwrap();

    <span class="kw">let </span>after = graph
        .execute(query(<span class="string">"MATCH (n:MyNode) RETURN COUNT(n) AS n"</span>))
        .<span class="kw">await
        </span>.unwrap()
        .next()
        .<span class="kw">await
        </span>.unwrap()
        .unwrap()
        .get::&lt;i64&gt;(<span class="string">"n"</span>)
        .unwrap();

    <span class="macro">assert_eq!</span>(after, before + <span class="number">2</span>);
}
}
</code></pre></div>
<h4 id="rollback-a-transaction"><a href="#rollback-a-transaction">Rollback a transaction</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span><span class="kw-2">mut </span>txn = graph.start_txn().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>id = uuid::Uuid::new_v4().to_string();
    <span class="comment">// create a node
    </span>txn.run(query(<span class="string">"CREATE (p:Person {id: $id})"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="comment">// rollback the changes
    </span>txn.rollback().<span class="kw">await</span>.unwrap();

    <span class="comment">// changes not updated in the database
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"MATCH (p:Person) WHERE p.id = $id RETURN p.id"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h4 id="txn-vs-graph"><a href="#txn-vs-graph">Txn vs Graph</a></h4>
<p>Everytime you execute a query using <a href="struct.Graph.html#method.run" title="method neo4rs::Graph::run"><code>Graph::run</code></a> or <a href="struct.Graph.html#method.execute" title="method neo4rs::Graph::execute"><code>Graph::execute</code></a>, a new connection is
taken from the pool and released immediately.</p>
<p>However, when you execute a query on a transaction using <a href="struct.Txn.html#method.run" title="method neo4rs::Txn::run"><code>Txn::run</code></a> or <a href="struct.Txn.html#method.execute" title="method neo4rs::Txn::execute"><code>Txn::execute</code></a> the
same connection will be reused, the underlying connection will be released to the pool in a
clean state only after you commit/rollback the transaction and the <a href="struct.Txn.html" title="struct neo4rs::Txn"><code>Txn</code></a> handle is dropped.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span><span class="kw-2">mut </span>txn = graph.start_txn().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>id = uuid::Uuid::new_v4().to_string();
    txn.run(query(<span class="string">"CREATE (p:Person {id: $id})"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    txn.run(query(<span class="string">"CREATE (p:Person {id: $id})"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="comment">// graph.execute(..) will not see the changes done above as the txn is not committed yet
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"MATCH (p:Person) WHERE p.id = $id RETURN p.id"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
    txn.commit().<span class="kw">await</span>.unwrap();

    <span class="comment">//changes are now seen as the transaction is committed.
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"MATCH (p:Person) WHERE p.id = $id RETURN p.id"</span>).param(<span class="string">"id"</span>, id.clone()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_some());
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_some());
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h3 id="relationships"><a href="#relationships">Relationships</a></h3>
<p>Bounded Relationship between nodes are created using cypher queries and the same can be parsed
from the <a href="struct.RowStream.html" title="struct neo4rs::RowStream"><code>RowStream</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph.execute(
        query(<span class="string">"CREATE (p:Person { name: 'Oliver Stone' })-[r:WORKS_AT {as: 'Engineer'}]-&gt;(neo) RETURN r"</span>)
    ).<span class="kw">await</span>.unwrap();

    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>relation: Relation = row.get(<span class="string">"r"</span>).unwrap();
    <span class="macro">assert!</span>(relation.id() &gt; -<span class="number">1</span>);
    <span class="macro">assert!</span>(relation.start_node_id() &gt; -<span class="number">1</span>);
    <span class="macro">assert!</span>(relation.end_node_id() &gt; -<span class="number">1</span>);
    <span class="macro">assert_eq!</span>(relation.typ(), <span class="string">"WORKS_AT"</span>);
    <span class="macro">assert_eq!</span>(relation.keys(), <span class="macro">vec!</span>[<span class="string">"as"</span>]);
    <span class="macro">assert_eq!</span>(relation.get::&lt;String&gt;(<span class="string">"as"</span>).unwrap(), <span class="string">"Engineer"</span>);
}
}</code></pre></div>
<p>Similar to bounded relation, an unbounded relation can also be created/parsed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph.execute(
        query(<span class="string">"MERGE (p1:Person { name: 'Oliver Stone' })-[r:RELATED {as: 'friend'}]-(p2: Person {name: 'Mark'}) RETURN r"</span>)
    ).<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();

    <span class="attr">#[derive(serde::Deserialize)]
    </span><span class="kw">struct </span>Related {
        id: Id,
        start_node_id: StartNodeId,
        end_node_id: EndNodeId,
        typ: Type,
        keys: Keys&lt;Vec&lt;String&gt;&gt;,
        <span class="attr">#[serde(rename = <span class="string">"as"</span>)]
        </span>related_as: String,
    }

    <span class="comment">// use serde to extract the relationship data
    </span><span class="kw">let </span>relation: Related = row.get(<span class="string">"r"</span>).unwrap();

    <span class="comment">// The following checks are always true, but are included here
    // to demonstrate the types of the fields.
    </span><span class="attr">#[allow(clippy::absurd_extreme_comparisons, unused_comparisons)]
    </span>{
        <span class="macro">assert!</span>(relation.id.<span class="number">0 </span>&gt;= <span class="number">0</span>);
        <span class="macro">assert!</span>(relation.start_node_id.<span class="number">0 </span>&gt;= <span class="number">0</span>);
        <span class="macro">assert!</span>(relation.end_node_id.<span class="number">0 </span>&gt;= <span class="number">0</span>);
    }

    <span class="macro">assert_eq!</span>(relation.typ.<span class="number">0</span>, <span class="string">"RELATED"</span>);
    <span class="macro">assert_eq!</span>(relation.keys.<span class="number">0</span>, <span class="macro">vec!</span>[<span class="string">"as"</span>]);
    <span class="macro">assert_eq!</span>(relation.related_as, <span class="string">"friend"</span>);

    <span class="comment">// or use the neo4rs::Relation type
    </span><span class="kw">let </span>relation: Relation = row.get(<span class="string">"r"</span>).unwrap();
    <span class="macro">assert!</span>(relation.id() &gt; -<span class="number">1</span>);
    <span class="macro">assert!</span>(relation.start_node_id() &gt; -<span class="number">1</span>);
    <span class="macro">assert!</span>(relation.end_node_id() &gt; -<span class="number">1</span>);
    <span class="macro">assert_eq!</span>(relation.typ(), <span class="string">"RELATED"</span>);
    <span class="macro">assert_eq!</span>(relation.keys(), <span class="macro">vec!</span>[<span class="string">"as"</span>]);
    <span class="macro">assert_eq!</span>(relation.get::&lt;String&gt;(<span class="string">"as"</span>).unwrap(), <span class="string">"friend"</span>);
}
}
</code></pre></div>
<h3 id="points"><a href="#points">Points</a></h3>
<p>A 2d or 3d point can be represented with the types  <a href="struct.Point2D.html" title="struct neo4rs::Point2D"><code>Point2D</code></a> and <a href="struct.Point3D.html" title="struct neo4rs::Point3D"><code>Point3D</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

   <span class="kw">let </span>qry = <span class="string">"
       WITH point({ x: 2.3, y: 4.5, crs: 'cartesian' }) AS p1,
            point({ x: 1.1, y: 5.4, crs: 'cartesian' }) AS p2
       RETURN point.distance(p1,p2) AS dist, p1, p2
    "</span>;
{ 
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph.execute(query(qry)).<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>dist: f64 = row.get(<span class="string">"dist"</span>).unwrap();
    <span class="kw">let </span>p1: Point2D = row.get(<span class="string">"p1"</span>).unwrap();
    <span class="kw">let </span>p2: Point2D = row.get(<span class="string">"p2"</span>).unwrap();
    <span class="macro">assert_eq!</span>(<span class="number">1.5</span>, dist);
    <span class="macro">assert_eq!</span>(p1.sr_id(), <span class="number">7203</span>);
    <span class="macro">assert_eq!</span>(p1.x(), <span class="number">2.3</span>);
    <span class="macro">assert_eq!</span>(p1.y(), <span class="number">4.5</span>);
    <span class="macro">assert_eq!</span>(p2.sr_id(), <span class="number">7203</span>);
    <span class="macro">assert_eq!</span>(p2.x(), <span class="number">1.1</span>);
    <span class="macro">assert_eq!</span>(p2.y(), <span class="number">5.4</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(
            <span class="string">"RETURN point({ longitude: 56.7, latitude: 12.78, height: 8 }) AS point"</span>,
        ))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>point: Point3D = row.get(<span class="string">"point"</span>).unwrap();
    <span class="macro">assert_eq!</span>(point.sr_id(), <span class="number">4979</span>);
    <span class="macro">assert_eq!</span>(point.x(), <span class="number">56.7</span>);
    <span class="macro">assert_eq!</span>(point.y(), <span class="number">12.78</span>);
    <span class="macro">assert_eq!</span>(point.z(), <span class="number">8.0</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h3 id="raw-bytes"><a href="#raw-bytes">Raw bytes</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span>bytes = <span class="string">b"Hello, Neo4j!"</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $b as output"</span>).param(<span class="string">"b"</span>, bytes.as_ref()))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>b: Vec&lt;u8&gt; = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(b, bytes);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h3 id="durations"><a href="#durations">Durations</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span>duration = std::time::Duration::new(<span class="number">5259600</span>, <span class="number">7</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, duration))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>d: std::time::Duration = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(d.as_secs(), <span class="number">5259600</span>);
    <span class="macro">assert_eq!</span>(d.subsec_nanos(), <span class="number">7</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h3 id="date"><a href="#date">Date</a></h3>
<p>See <a href="https://docs.rs/chrono/0.4.19/chrono/naive/struct.NaiveDate.html">NaiveDate</a> for date abstraction, it captures the date without time component.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span>date = chrono::NaiveDate::from_ymd_opt(<span class="number">1985</span>, <span class="number">2</span>, <span class="number">5</span>).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, date))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>d: chrono::NaiveDate = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(d.to_string(), <span class="string">"1985-02-05"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}</code></pre></div>
<h3 id="time"><a href="#time">Time</a></h3>
<ul>
<li><a href="https://docs.rs/chrono/0.4.19/chrono/naive/struct.NaiveTime.html">NaiveTime</a> captures only the time of the day</li>
<li><code>tuple</code>(<a href="https://docs.rs/chrono/0.4.19/chrono/naive/struct.NaiveTime.html">NaiveTime</a>, <code>Option</code>&lt;<a href="https://docs.rs/chrono/0.4.19/chrono/offset/struct.FixedOffset.html">FixedOffset</a>&gt;) captures the time of the day along with the
offset</li>
</ul>
<h4 id="time-as-param"><a href="#time-as-param">Time as param</a></h4>
<p>Pass a time as a parameter to the query:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="comment">//send time without offset as param
    </span><span class="kw">let </span>time = chrono::NaiveTime::from_hms_nano_opt(<span class="number">11</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">200</span>).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, time))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: (chrono::NaiveTime, <span class="prelude-ty">Option</span>&lt;Offset&gt;) = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.<span class="number">0</span>.to_string(), <span class="string">"11:15:30.000000200"</span>);
    <span class="macro">assert_eq!</span>(t.<span class="number">1</span>, <span class="prelude-val">None</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="comment">//send time with offset as param
    </span><span class="kw">let </span>time = chrono::NaiveTime::from_hms_nano_opt(<span class="number">11</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">200</span>).unwrap();
    <span class="kw">let </span>offset = chrono::FixedOffset::east_opt(<span class="number">3 </span>* <span class="number">3600</span>).unwrap();
    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, (time, offset)))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: (chrono::NaiveTime, <span class="prelude-ty">Option</span>&lt;Offset&gt;) = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.<span class="number">0</span>.to_string(), <span class="string">"11:15:30.000000200"</span>);
    <span class="macro">assert_eq!</span>(t.<span class="number">1</span>, <span class="prelude-val">Some</span>(Offset(offset)));
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}</code></pre></div>
<h4 id="parsing-time-from-result"><a href="#parsing-time-from-result">Parsing time from result</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="comment">//Parse time without offset
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(
            <span class="string">" WITH time({hour:10, minute:15, second:30, nanosecond: 200}) AS t RETURN t"</span>,
        ))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: (chrono::NaiveTime, <span class="prelude-ty">Option</span>&lt;Offset&gt;) = row.get(<span class="string">"t"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.<span class="number">0</span>.to_string(), <span class="string">"10:15:30.000000200"</span>);
    <span class="macro">assert_eq!</span>(t.<span class="number">1</span>, <span class="prelude-val">None</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="comment">//Parse time with timezone information
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(
            <span class="string">" WITH time({hour:10, minute:15, second:33, nanosecond: 200, timezone: '+01:00'}) AS t RETURN t"</span>,
        ))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: (chrono::NaiveTime, <span class="prelude-ty">Option</span>&lt;Offset&gt;) = row.get(<span class="string">"t"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.<span class="number">0</span>.to_string(), <span class="string">"10:15:33.000000200"</span>);
    <span class="macro">assert_eq!</span>(t.<span class="number">1</span>, <span class="prelude-val">Some</span>(Offset(chrono::FixedOffset::east_opt(<span class="number">3600</span>).unwrap())));
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h3 id="datetime"><a href="#datetime">DateTime</a></h3>
<ul>
<li><a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html">DateTime</a> captures the date and time with offset</li>
<li><a href="https://docs.rs/chrono/0.4.19/chrono/struct.NaiveDateTime.html">NaiveDateTime</a> captures the date time without offset</li>
<li><code>tuple</code>(<a href="https://docs.rs/chrono/0.4.19/chrono/struct.NaiveDateTime.html">NaiveDateTime</a>, String)  captures the date/time and the time zone id</li>
</ul>
<h4 id="datetime-as-param"><a href="#datetime-as-param">DateTime as param</a></h4>
<p>Pass a DateTime as parameter to the query:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="comment">//send datetime as parameter in the query
    </span><span class="kw">let </span>datetime = chrono::DateTime::parse_from_rfc2822(<span class="string">"Tue, 01 Jul 2003 10:52:37 +0200"</span>).unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, datetime))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: chrono::DateTime&lt;chrono::FixedOffset&gt; = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"2003-07-01 10:52:37 +02:00"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="comment">//send NaiveDateTime as parameter in the query
    </span><span class="kw">let </span>localdatetime =
    chrono::NaiveDateTime::parse_from_str(<span class="string">"2015-07-01 08:55:59.123"</span>, <span class="string">"%Y-%m-%d %H:%M:%S%.f"</span>)
        .unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, localdatetime))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: chrono::NaiveDateTime = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"2015-07-01 08:55:59.123"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="comment">//send NaiveDateTime with timezone id as parameter in the query
    </span><span class="kw">let </span>datetime =
    chrono::NaiveDateTime::parse_from_str(<span class="string">"2015-07-03 08:55:59.555"</span>, <span class="string">"%Y-%m-%d %H:%M:%S%.f"</span>)
        .unwrap();
    <span class="kw">let </span>timezone = <span class="string">"Europe/Paris"</span>;

    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(<span class="string">"RETURN $d as output"</span>).param(<span class="string">"d"</span>, (datetime, timezone)))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>(time, zone): (chrono::NaiveDateTime, String) = row.get(<span class="string">"output"</span>).unwrap();
    <span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"2015-07-03 08:55:59.555"</span>);
    <span class="macro">assert_eq!</span>(zone, <span class="string">"Europe/Paris"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}</code></pre></div>
<h4 id="parsing-datetime-from-result"><a href="#parsing-datetime-from-result">Parsing DateTime from result</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="comment">//Parse NaiveDateTime from result
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(
            <span class="string">"WITH localdatetime('2015-06-24T12:50:35.556') AS t RETURN t"</span>,
        ))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: chrono::NaiveDateTime = row.get(<span class="string">"t"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"2015-06-24 12:50:35.556"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="comment">//Parse DateTime from result
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(
            <span class="string">"WITH datetime('2015-06-24T12:50:35.777+0100') AS t RETURN t"</span>,
        ))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>t: chrono::DateTime&lt;chrono::FixedOffset&gt; = row.get(<span class="string">"t"</span>).unwrap();
    <span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"2015-06-24 12:50:35.777 +01:00"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());

    <span class="comment">//Parse NaiveDateTime with zone id from result
    </span><span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(query(
            <span class="string">"WITH datetime({ year:1984, month:11, day:11, hour:12, minute:31, second:14, nanosecond: 645876123, timezone:'Europe/Stockholm' }) AS d return d"</span>,
        ))
        .<span class="kw">await
        </span>.unwrap();
    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>(datetime, zone_id): (chrono::NaiveDateTime, String) = row.get(<span class="string">"d"</span>).unwrap();
    <span class="macro">assert_eq!</span>(datetime.to_string(), <span class="string">"1984-11-11 12:31:14.645876123"</span>);
    <span class="macro">assert_eq!</span>(zone_id, <span class="string">"Europe/Stockholm"</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}
</code></pre></div>
<h3 id="path"><a href="#path">Path</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>neo4rs::<span class="kw-2">*</span>;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
   <span class="kw">let </span>uri = <span class="string">"127.0.0.1:7687"</span>;
   <span class="kw">let </span>user = <span class="string">"neo4j"</span>;
   <span class="kw">let </span>pass = <span class="string">"neo"</span>;
   <span class="kw">let </span>graph = Graph::new(uri, user, pass).<span class="kw">await</span>.unwrap();

{ 
    <span class="kw">let </span>name = uuid::Uuid::new_v4().to_string();
    graph
        .run(
            query(<span class="string">"CREATE (p:Person { name: $name })-[r:WORKS_AT]-&gt;(n:Company { name: 'Neo'})"</span>)
                .param(<span class="string">"name"</span>, name.clone()),
        )
        .<span class="kw">await
        </span>.unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>result = graph
        .execute(
            query(<span class="string">"MATCH p = (person:Person { name: $name })-[r:WORKS_AT]-&gt;(c:Company) RETURN p"</span>)
                .param(<span class="string">"name"</span>, name),
        )
        .<span class="kw">await
        </span>.unwrap();

    <span class="kw">let </span>row = result.next().<span class="kw">await</span>.unwrap().unwrap();
    <span class="kw">let </span>path: Path = row.get(<span class="string">"p"</span>).unwrap();
    <span class="macro">assert_eq!</span>(path.indices().len(), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(path.nodes().len(), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(path.rels().len(), <span class="number">1</span>);
    <span class="macro">assert!</span>(result.next().<span class="kw">await</span>.unwrap().is_none());
}
}</code></pre></div>
</div></details><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.cenum.html" title="macro neo4rs::cenum">cenum</a></div></li></ul><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BoltBoolean.html" title="struct neo4rs::BoltBoolean">BoltBoolean</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltBytes.html" title="struct neo4rs::BoltBytes">BoltBytes</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltDate.html" title="struct neo4rs::BoltDate">BoltDate</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltDateTime.html" title="struct neo4rs::BoltDateTime">BoltDateTime</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltDateTimeZoneId.html" title="struct neo4rs::BoltDateTimeZoneId">BoltDateTimeZoneId</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltDuration.html" title="struct neo4rs::BoltDuration">BoltDuration</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltFloat.html" title="struct neo4rs::BoltFloat">BoltFloat</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltInteger.html" title="struct neo4rs::BoltInteger">BoltInteger</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltList.html" title="struct neo4rs::BoltList">BoltList</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltLocalDateTime.html" title="struct neo4rs::BoltLocalDateTime">BoltLocalDateTime</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltLocalTime.html" title="struct neo4rs::BoltLocalTime">BoltLocalTime</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltMap.html" title="struct neo4rs::BoltMap">BoltMap</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltNode.html" title="struct neo4rs::BoltNode">BoltNode</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltNull.html" title="struct neo4rs::BoltNull">BoltNull</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltPath.html" title="struct neo4rs::BoltPath">BoltPath</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltPoint2D.html" title="struct neo4rs::BoltPoint2D">BoltPoint2D</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltPoint3D.html" title="struct neo4rs::BoltPoint3D">BoltPoint3D</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltRelation.html" title="struct neo4rs::BoltRelation">BoltRelation</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltString.html" title="struct neo4rs::BoltString">BoltString</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltTime.html" title="struct neo4rs::BoltTime">BoltTime</a></div></li><li><div class="item-name"><a class="struct" href="struct.BoltUnboundedRelation.html" title="struct neo4rs::BoltUnboundedRelation">BoltUnboundedRelation</a></div></li><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct neo4rs::Config">Config</a></div><div class="desc docblock-short">The configuration used to connect to the database, see <a href="struct.Graph.html#method.connect" title="associated function neo4rs::Graph::connect"><code>crate::Graph::connect</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ConfigBuilder.html" title="struct neo4rs::ConfigBuilder">ConfigBuilder</a></div><div class="desc docblock-short">A builder to override default configurations and build the <a href="struct.Config.html" title="struct neo4rs::Config"><code>Config</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Database.html" title="struct neo4rs::Database">Database</a></div><div class="desc docblock-short">Newtype for the name of the database.
Stores the name as an <code>Arc&lt;str&gt;</code> to avoid cloning the name around.</div></li><li><div class="item-name"><a class="struct" href="struct.EndNodeId.html" title="struct neo4rs::EndNodeId">EndNodeId</a></div><div class="desc docblock-short">Newtype to extract the end node id of a relationship during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Graph.html" title="struct neo4rs::Graph">Graph</a></div><div class="desc docblock-short">A neo4j database abstraction.
This type can be cloned and shared across threads, internal resources
are reference-counted.</div></li><li><div class="item-name"><a class="struct" href="struct.Id.html" title="struct neo4rs::Id">Id</a></div><div class="desc docblock-short">Newtype to extract the node id or relationship id during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Indices.html" title="struct neo4rs::Indices">Indices</a></div><div class="desc docblock-short">Newtype to extract the indices of a path during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Keys.html" title="struct neo4rs::Keys">Keys</a></div><div class="desc docblock-short">Newtype to extract the node property keys during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Labels.html" title="struct neo4rs::Labels">Labels</a></div><div class="desc docblock-short">Newtype to extract the node labels during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Node.html" title="struct neo4rs::Node">Node</a></div><div class="desc docblock-short">Snapshot of a node within a graph database</div></li><li><div class="item-name"><a class="struct" href="struct.Nodes.html" title="struct neo4rs::Nodes">Nodes</a></div><div class="desc docblock-short">Newtype to extract the nodes of a path during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Offset.html" title="struct neo4rs::Offset">Offset</a></div><div class="desc docblock-short">Newtype to extract the offset info of times during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Path.html" title="struct neo4rs::Path">Path</a></div><div class="desc docblock-short">Alternating sequence of nodes and relationships</div></li><li><div class="item-name"><a class="struct" href="struct.Point2D.html" title="struct neo4rs::Point2D">Point2D</a></div><div class="desc docblock-short">Represents a single location in 2-dimensional space</div></li><li><div class="item-name"><a class="struct" href="struct.Point3D.html" title="struct neo4rs::Point3D">Point3D</a></div><div class="desc docblock-short">Represents a single location in 3-dimensional space</div></li><li><div class="item-name"><a class="struct" href="struct.Query.html" title="struct neo4rs::Query">Query</a></div><div class="desc docblock-short">Abstracts a cypher query that is sent to neo4j server.</div></li><li><div class="item-name"><a class="struct" href="struct.Relation.html" title="struct neo4rs::Relation">Relation</a></div><div class="desc docblock-short">Snapshot of a relationship within a graph database</div></li><li><div class="item-name"><a class="struct" href="struct.Relationships.html" title="struct neo4rs::Relationships">Relationships</a></div><div class="desc docblock-short">Newtype to extract the relationships of a path during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Row.html" title="struct neo4rs::Row">Row</a></div><div class="desc docblock-short">Represents a row returned as a result of executing a query.</div></li><li><div class="item-name"><a class="struct" href="struct.RowStream.html" title="struct neo4rs::RowStream">RowStream</a></div><div class="desc docblock-short">An abstraction over a stream of rows, this is returned as a result of <a href="struct.Txn.html#method.execute" title="method neo4rs::Txn::execute"><code>crate::Txn::execute</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.StartNodeId.html" title="struct neo4rs::StartNodeId">StartNodeId</a></div><div class="desc docblock-short">Newtype to extract the start node id of a relationship during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Timezone.html" title="struct neo4rs::Timezone">Timezone</a></div><div class="desc docblock-short">Newtype to extract the timezone info of datetimes during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.Txn.html" title="struct neo4rs::Txn">Txn</a></div><div class="desc docblock-short">A handle which is used to control a transaction, created as a result of <a href="struct.Graph.html#method.start_txn" title="method neo4rs::Graph::start_txn"><code>crate::Graph::start_txn</code></a></div></li><li><div class="item-name"><a class="struct" href="struct.Type.html" title="struct neo4rs::Type">Type</a></div><div class="desc docblock-short">Newtype to extract the relationship type during deserialization.</div></li><li><div class="item-name"><a class="struct" href="struct.UnboundedRelation.html" title="struct neo4rs::UnboundedRelation">UnboundedRelation</a></div><div class="desc docblock-short">Relationship detail without start or end node information</div></li></ul><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.BoltType.html" title="enum neo4rs::BoltType">BoltType</a></div></li><li><div class="item-name"><a class="enum" href="enum.DeError.html" title="enum neo4rs::DeError">DeError</a></div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum neo4rs::Error">Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.Version.html" title="enum neo4rs::Version">Version</a></div></li></ul><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.query.html" title="fn neo4rs::query">query</a></div><div class="desc docblock-short">Returns a <a href="struct.Query.html" title="struct neo4rs::Query"><code>Query</code></a> which provides methods like <a href="struct.Query.html#method.param" title="method neo4rs::Query::param"><code>Query::param</code></a> to add parameters to the query</div></li><li><div class="item-name"><a class="fn" href="fn.unexpected.html" title="fn neo4rs::unexpected">unexpected</a></div></li></ul><h2 id="types" class="section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type neo4rs::Result">Result</a></div></li></ul></section></div></main></body></html>