<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generate reusable OpenAPI schema to be used together with `OpenApi`."><title>ToSchema in utoipa_gen - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="utoipa_gen" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../utoipa_gen/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../utoipa_gen/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In utoipa_gen</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Derive Macro <a href="index.html">utoipa_gen</a>::<wbr><a class="derive" href="#">ToSchema</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/utoipa_gen/lib.rs.html#49">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[derive(ToSchema)]
{
    // Attributes available to this derive:
    #[schema]
    #[aliases]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Generate reusable OpenAPI schema to be used
together with <a href="derive.OpenApi.html"><code>OpenApi</code></a>.</p>
<p>This is <code>#[derive]</code> implementation for <a href="trait.ToSchema.html"><code>ToSchema</code></a> trait. The macro accepts one
<code>schema</code>
attribute optionally which can be used to enhance generated documentation. The attribute can be placed
at item level or field level in struct and enums. Currently placing this attribute to unnamed field does
not have any effect.</p>
<p>You can use the Rust’s own <code>#[deprecated]</code> attribute on any struct, enum or field to mark it as deprecated and it will
reflect to the generated OpenAPI spec.</p>
<p><code>#[deprecated]</code> attribute supports adding additional details such as a reason and or since version but this is is not supported in
OpenAPI. OpenAPI has only a boolean flag to determine deprecation. While it is totally okay to declare deprecated with reason
<code>#[deprecated  = &quot;There is better way to do this&quot;]</code> the reason would not render in OpenAPI spec.</p>
<p>Doc comments on fields will resolve to field descriptions in generated OpenAPI doc. On struct
level doc comments will resolve to object descriptions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This is a pet
</span><span class="attr">#[derive(utoipa::ToSchema)]
</span><span class="kw">struct </span>Pet {
    <span class="doccomment">/// Name for your pet
    </span>name: String,
}</code></pre></div>
<h2 id="struct-optional-configuration-options-for-schema"><a href="#struct-optional-configuration-options-for-schema">Struct Optional Configuration Options for <code>#[schema(...)]</code></a></h2>
<ul>
<li><code>example = ...</code> Can be <em><code>json!(...)</code></em>. <em><code>json!(...)</code></em> should be something that
<em><code>serde_json::json!</code></em> can parse as a <em><code>serde_json::Value</code></em>.</li>
<li><code>xml(...)</code> Can be used to define <a href="openapi/xml/struct.Xml.html"><code>Xml</code></a> object properties applicable to Structs.</li>
<li><code>title = ...</code> Literal string value. Can be used to define title for struct in OpenAPI
document. Some OpenAPI code generation libraries also use this field as a name for the
struct.</li>
<li><code>rename_all = ...</code> Supports same syntax as <em>serde</em> <em><code>rename_all</code></em> attribute. Will rename all fields
of the structs accordingly. If both <em>serde</em> <code>rename_all</code> and <em>schema</em> <em><code>rename_all</code></em> are defined
<strong>serde</strong> will take precedence.</li>
<li><code>as = ...</code> Can be used to define alternative path and name for the schema what will be used in
the OpenAPI. E.g <em><code>as = path::to::Pet</code></em>. This would make the schema appear in the generated
OpenAPI spec as <em><code>path.to.Pet</code></em>.</li>
<li><code>default</code> Can be used to populate default values on all fields using the struct’s
<a href="https://doc.rust-lang.org/1.73.0/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> implementation.</li>
<li><code>deprecated</code> Can be used to mark all fields as deprecated in the generated OpenAPI spec but
not in the code. If you’d like to mark the fields as deprecated in the code as well use
Rust’s own <code>#[deprecated]</code> attribute instead.</li>
</ul>
<h2 id="enum-optional-configuration-options-for-schema"><a href="#enum-optional-configuration-options-for-schema">Enum Optional Configuration Options for <code>#[schema(...)]</code></a></h2>
<ul>
<li><code>example = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>default = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>title = ...</code> Literal string value. Can be used to define title for enum in OpenAPI
document. Some OpenAPI code generation libraries also use this field as a name for the
enum. <strong>Note!</strong>  <em><strong>Complex enum (enum with other than unit variants) does not support title!</strong></em></li>
<li><code>rename_all = ...</code> Supports same syntax as <em>serde</em> <em><code>rename_all</code></em> attribute. Will rename all
variants of the enum accordingly. If both <em>serde</em> <code>rename_all</code> and <em>schema</em> <em><code>rename_all</code></em>
are defined <strong>serde</strong> will take precedence.</li>
<li><code>as = ...</code> Can be used to define alternative path and name for the schema what will be used in
the OpenAPI. E.g <em><code>as = path::to::Pet</code></em>. This would make the schema appear in the generated
OpenAPI spec as <em><code>path.to.Pet</code></em>.</li>
<li><code>deprecated</code> Can be used to mark the enum as deprecated in the generated OpenAPI spec but
not in the code. If you’d like to mark the enum as deprecated in the code as well use
Rust’s own <code>#[deprecated]</code> attribute instead.</li>
</ul>
<h2 id="enum-variant-optional-configuration-options-for-schema"><a href="#enum-variant-optional-configuration-options-for-schema">Enum Variant Optional Configuration Options for <code>#[schema(...)]</code></a></h2>
<p>Supports all variant specific configuration options e.g. if variant is <em><code>UnnamedStruct</code></em> then
unnamed struct type configuration options are supported.</p>
<p>In addition to the variant type specific configuration options enum variants support custom
<em><code>rename</code></em> attribute. It behaves similarly to serde’s <em><code>rename</code></em> attribute. If both <em>serde</em>
<em><code>rename</code></em> and <em>schema</em> <em><code>rename</code></em> are defined <strong>serde</strong> will take precedence.</p>
<h2 id="unnamed-field-struct-optional-configuration-options-for-schema"><a href="#unnamed-field-struct-optional-configuration-options-for-schema">Unnamed Field Struct Optional Configuration Options for <code>#[schema(...)]</code></a></h2>
<ul>
<li><code>example = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>default = ...</code> Can be method reference or <em><code>json!(...)</code></em>. If no value is specified, and the struct has
only one field, the field’s default value in the schema will be set from the struct’s
<a href="https://doc.rust-lang.org/1.73.0/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> implementation.</li>
<li><code>format = ...</code> May either be variant of the <a href="openapi/schema/enum.KnownFormat.html"><code>KnownFormat</code></a> enum, or otherwise
an open value as a string. By default the format is derived from the type of the property
according OpenApi spec.</li>
<li><code>value_type = ...</code> Can be used to override default type derived from type of the field used in OpenAPI spec.
This is useful in cases where the default type does not correspond to the actual type e.g. when
any third-party types are used which are not <a href="trait.ToSchema.html"><code>ToSchema</code></a>s nor <a href="https://doc.rust-lang.org/std/primitive/index.html"><code>primitive</code> types</a>.
The value can be any Rust type what normally could be used to serialize to JSON or either virtual type <em><code>Object</code></em>
or <em><code>Value</code></em>, or an alias defined using <code>#[aliases(..)]</code>.
<em><code>Object</code></em> will be rendered as generic OpenAPI object <em>(<code>type: object</code>)</em>.
<em><code>Value</code></em> will be rendered as any OpenAPI value (i.e. no <code>type</code> restriction).</li>
<li><code>title = ...</code> Literal string value. Can be used to define title for struct in OpenAPI
document. Some OpenAPI code generation libraries also use this field as a name for the
struct.</li>
<li><code>as = ...</code> Can be used to define alternative path and name for the schema what will be used in
the OpenAPI. E.g <em><code>as = path::to::Pet</code></em>. This would make the schema appear in the generated
OpenAPI spec as <em><code>path.to.Pet</code></em>.</li>
<li><code>deprecated</code> Can be used to mark the field as deprecated in the generated OpenAPI spec but
not in the code. If you’d like to mark the field as deprecated in the code as well use
Rust’s own <code>#[deprecated]</code> attribute instead.</li>
</ul>
<h2 id="named-fields-optional-configuration-options-for-schema"><a href="#named-fields-optional-configuration-options-for-schema">Named Fields Optional Configuration Options for <code>#[schema(...)]</code></a></h2>
<ul>
<li><code>example = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>default = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>format = ...</code> May either be variant of the <a href="openapi/schema/enum.KnownFormat.html"><code>KnownFormat</code></a> enum, or otherwise
an open value as a string. By default the format is derived from the type of the property
according OpenApi spec.</li>
<li><code>write_only</code> Defines property is only used in <strong>write</strong> operations <em>POST,PUT,PATCH</em> but not in <em>GET</em></li>
<li><code>read_only</code> Defines property is only used in <strong>read</strong> operations <em>GET</em> but not in <em>POST,PUT,PATCH</em></li>
<li><code>xml(...)</code> Can be used to define <a href="openapi/xml/struct.Xml.html"><code>Xml</code></a> object properties applicable to named fields.
See configuration options at xml attributes of <a href="derive.ToSchema.html#xml-attribute-configuration-options" title="derive utoipa_gen::ToSchema"><code>ToSchema</code></a></li>
<li><code>value_type = ...</code> Can be used to override default type derived from type of the field used in OpenAPI spec.
This is useful in cases where the default type does not correspond to the actual type e.g. when
any third-party types are used which are not <a href="trait.ToSchema.html"><code>ToSchema</code></a>s nor <a href="https://doc.rust-lang.org/std/primitive/index.html"><code>primitive</code> types</a>.
The value can be any Rust type what normally could be used to serialize to JSON, or either virtual type <em><code>Object</code></em>
or <em><code>Value</code></em>, or an alias defined using <code>#[aliases(..)]</code>.
<em><code>Object</code></em> will be rendered as generic OpenAPI object <em>(<code>type: object</code>)</em>.
<em><code>Value</code></em> will be rendered as any OpenAPI value (i.e. no <code>type</code> restriction).</li>
<li><code>inline</code> If the type of this field implements <a href="trait.ToSchema.html"><code>ToSchema</code></a>, then the schema definition
will be inlined. <strong>warning:</strong> Don’t use this for recursive data types!</li>
<li><code>required = ...</code> Can be used to enforce required status for the field. <a href="derive.ToSchema.html#field-nullability-and-required-rules" title="derive utoipa_gen::ToSchema">See
rules</a></li>
<li><code>nullable</code> Defines property is nullable (note this is different to non-required).</li>
<li><code>rename = ...</code> Supports same syntax as <em>serde</em> <em><code>rename</code></em> attribute. Will rename field
accordingly. If both <em>serde</em> <code>rename</code> and <em>schema</em> <em><code>rename</code></em> are defined <strong>serde</strong> will take
precedence.</li>
<li><code>multiple_of = ...</code> Can be used to define multiplier for a value. Value is considered valid
division will result an <code>integer</code>. Value must be strictly above <em><code>0</code></em>.</li>
<li><code>maximum = ...</code> Can be used to define inclusive upper bound to a <code>number</code> value.</li>
<li><code>minimum = ...</code> Can be used to define inclusive lower bound to a <code>number</code> value.</li>
<li><code>exclusive_maximum = ...</code> Can be used to define exclusive upper bound to a <code>number</code> value.</li>
<li><code>exclusive_minimum = ...</code> Can be used to define exclusive lower bound to a <code>number</code> value.</li>
<li><code>max_length = ...</code> Can be used to define maximum length for <code>string</code> types.</li>
<li><code>min_length = ...</code> Can be used to define minimum length for <code>string</code> types.</li>
<li><code>pattern = ...</code> Can be used to define valid regular expression in <em>ECMA-262</em> dialect the field value must match.</li>
<li><code>max_items = ...</code> Can be used to define maximum items allowed for <code>array</code> fields. Value must
be non-negative integer.</li>
<li><code>min_items = ...</code> Can be used to define minimum items allowed for <code>array</code> fields. Value must
be non-negative integer.</li>
<li><code>schema_with = ...</code> Use <em><code>schema</code></em> created by provided function reference instead of the
default derived <em><code>schema</code></em>. The function must match to <code>fn() -&gt; Into&lt;RefOr&lt;Schema&gt;&gt;</code>. It does
not accept arguments and must return anything that can be converted into <code>RefOr&lt;Schema&gt;</code>.</li>
<li><code>additional_properties = ...</code> Can be used to define free form types for maps such as
<a href="https://doc.rust-lang.org/1.73.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap"><code>HashMap</code></a> and <a href="https://doc.rust-lang.org/1.73.0/alloc/collections/btree/map/struct.BTreeMap.html" title="struct alloc::collections::btree::map::BTreeMap"><code>BTreeMap</code></a>.
Free form type enables use of arbitrary types within map values.
Supports formats <em><code>additional_properties</code></em> and <em><code>additional_properties = true</code></em>.</li>
<li><code>deprecated</code> Can be used to mark the field as deprecated in the generated OpenAPI spec but
not in the code. If you’d like to mark the field as deprecated in the code as well use
Rust’s own <code>#[deprecated]</code> attribute instead.</li>
</ul>
<h5 id="field-nullability-and-required-rules"><a href="#field-nullability-and-required-rules">Field nullability and required rules</a></h5>
<p>Field is considered <em><code>required</code></em> if</p>
<ul>
<li>it is not <code>Option</code> field</li>
<li>and it does not have <em><code>skip_serializing_if</code></em> property</li>
<li>and it does not have <em><code>serde_with</code></em> <em><a href="https://docs.rs/serde_with/latest/serde_with/rust/double_option/index.html"><code>double_option</code></a></em></li>
<li>and it does not have default value provided with serde <em><code>default</code></em>
attribute</li>
</ul>
<p>Field is considered <em><code>nullable</code></em> when field type is <em><code>Option</code></em>.</p>
<h3 id="xml-attribute-configuration-options"><a href="#xml-attribute-configuration-options">Xml attribute Configuration Options</a></h3>
<ul>
<li><code>xml(name = &quot;...&quot;)</code> Will set name for property or type.</li>
<li><code>xml(namespace = &quot;...&quot;)</code> Will set namespace for xml element which needs to be valid uri.</li>
<li><code>xml(prefix = &quot;...&quot;)</code> Will set prefix for name.</li>
<li><code>xml(attribute)</code> Will translate property to xml attribute instead of xml element.</li>
<li><code>xml(wrapped)</code> Will make wrapped xml element.</li>
<li><code>xml(wrapped(name = &quot;wrap_name&quot;))</code> Will override the wrapper elements name.</li>
</ul>
<p>See <a href="openapi/xml/struct.Xml.html"><code>Xml</code></a> for more details.</p>
<h2 id="partial-serde-attributes-support"><a href="#partial-serde-attributes-support">Partial <code>#[serde(...)]</code> attributes support</a></h2>
<p>ToSchema derive has partial support for <a href="https://serde.rs/attributes.html">serde attributes</a>. These supported attributes will reflect to the
generated OpenAPI doc. For example if <em><code>#[serde(skip)]</code></em> is defined the attribute will not show up in the OpenAPI spec at all since it will not never
be serialized anyway. Similarly the <em><code>rename</code></em> and <em><code>rename_all</code></em> will reflect to the generated OpenAPI doc.</p>
<ul>
<li><code>rename_all = &quot;...&quot;</code> Supported at the container level.</li>
<li><code>rename = &quot;...&quot;</code> Supported <strong>only</strong> at the field or variant level.</li>
<li><code>skip = &quot;...&quot;</code> Supported  <strong>only</strong> at the field or variant level.</li>
<li><code>skip_serializing = &quot;...&quot;</code> Supported  <strong>only</strong> at the field or variant level.</li>
<li><code>skip_deserializing = &quot;...&quot;</code> Supported  <strong>only</strong> at the field or variant level.</li>
<li><code>skip_serializing_if = &quot;...&quot;</code> Supported  <strong>only</strong> at the field level.</li>
<li><code>with = ...</code> Supported <strong>only at field level.</strong></li>
<li><code>tag = &quot;...&quot;</code> Supported at the container level. <code>tag</code> attribute works as a <a href="openapi/schema/struct.Discriminator.html">discriminator field</a> for an enum.</li>
<li><code>content = &quot;...&quot;</code> Supported at the container level, allows <a href="https://serde.rs/enum-representations.html#adjacently-tagged">adjacently-tagged enums</a>.
This attribute requires that a <code>tag</code> is present, otherwise serde will trigger a compile-time
failure.</li>
<li><code>untagged</code> Supported at the container level. Allows <a href="https://serde.rs/enum-representations.html#untagged">untagged
enum representation</a>.</li>
<li><code>default</code> Supported at the container level and field level according to <a href="https://serde.rs/attributes.html">serde attributes</a>.</li>
<li><code>flatten</code> Supported at the field level.</li>
</ul>
<p>Other <em><code>serde</code></em> attributes works as is but does not have any effect on the generated OpenAPI doc.</p>
<p><strong>Note!</strong> <code>tag</code> attribute has some limitations like it cannot be used
with <strong>unnamed field structs</strong> and <strong>tuple types</strong>.  See more at
<a href="https://serde.rs/enum-representations.html">enum representation docs</a>.</p>
<p><strong>Note!</strong> <code>with</code> attribute is used in tandem with <a href="https://github.com/jonasbb/serde_with">serde_with</a> to recognize
<em><a href="https://docs.rs/serde_with/latest/serde_with/rust/double_option/index.html"><code>double_option</code></a></em> from <strong>field value</strong>.
<em><code>double_option</code></em> is <strong>only</strong> supported attribute from <em><code>serde_with</code></em> crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, ToSchema)]
</span><span class="kw">struct </span>Foo(String);

<span class="attr">#[derive(Serialize, ToSchema)]
#[serde(rename_all = <span class="string">&quot;camelCase&quot;</span>)]
</span><span class="kw">enum </span>Bar {
    UnitValue,
    <span class="attr">#[serde(rename_all = <span class="string">&quot;camelCase&quot;</span>)]
    </span>NamedFields {
        <span class="attr">#[serde(rename = <span class="string">&quot;id&quot;</span>)]
        </span>named_id: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str,
        name_list: <span class="prelude-ty">Option</span>&lt;Vec&lt;String&gt;&gt;
    },
    UnnamedFields(Foo),
    <span class="attr">#[serde(skip)]
    </span>SkipMe,
}</code></pre></div>
<p><em><strong>Add custom <code>tag</code> to change JSON representation to be internally tagged.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Serialize, ToSchema)]
</span><span class="kw">struct </span>Foo(String);

<span class="attr">#[derive(Serialize, ToSchema)]
#[serde(tag = <span class="string">&quot;tag&quot;</span>)]
</span><span class="kw">enum </span>Bar {
    UnitValue,
    NamedFields {
        id: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str,
        names: <span class="prelude-ty">Option</span>&lt;Vec&lt;String&gt;&gt;
    },
}</code></pre></div>
<p><em><strong>Add serde <code>default</code> attribute for MyValue struct. Similarly <code>default</code> could be added to
individual fields as well. If <code>default</code> is given the field’s affected will be treated
as optional.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[derive(utoipa::ToSchema, serde::Deserialize, Default)]
 #[serde(default)]
 </span><span class="kw">struct </span>MyValue {
     field: String
 }</code></pre></div>
<h2 id="repr-attribute-support"><a href="#repr-attribute-support"><code>#[repr(...)]</code> attribute support</a></h2>
<p><a href="https://github.com/dtolnay/serde-repr">Serde repr</a> allows field-less enums be represented by
their numeric value.</p>
<ul>
<li><code>repr(u*)</code> for unsigned integer.</li>
<li><code>repr(i*)</code> for signed integer.</li>
</ul>
<p><strong>Supported schema attributes</strong></p>
<ul>
<li><code>example = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>default = ...</code> Can be method reference or <em><code>json!(...)</code></em>.</li>
<li><code>title = ...</code> Literal string value. Can be used to define title for enum in OpenAPI
document. Some OpenAPI code generation libraries also use this field as a name for the
enum. <strong>Note!</strong>  <em><strong>Complex enum (enum with other than unit variants) does not support title!</strong></em></li>
<li><code>as = ...</code> Can be used to define alternative path and name for the schema what will be used in
the OpenAPI. E.g <em><code>as = path::to::Pet</code></em>. This would make the schema appear in the generated
OpenAPI spec as <em><code>path.to.Pet</code></em>.</li>
</ul>
<p><em><strong>Create enum with numeric values.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
#[repr(u8)]
#[schema(default = default_value, example = <span class="number">2</span>)]
</span><span class="kw">enum </span>Mode {
    One = <span class="number">1</span>,
    Two,
 }

<span class="kw">fn </span>default_value() -&gt; u8 {
    <span class="number">1
</span>}</code></pre></div>
<p><em><strong>You can use <code>skip</code> and <code>tag</code> attributes from serde.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema, serde::Serialize)]
#[repr(i8)]
#[serde(tag = <span class="string">&quot;code&quot;</span>)]
</span><span class="kw">enum </span>ExitCode {
    Error = -<span class="number">1</span>,
    <span class="attr">#[serde(skip)]
    </span>Unknown = <span class="number">0</span>,
    <span class="prelude-val">Ok </span>= <span class="number">1</span>,
 }</code></pre></div>
<h2 id="generic-schemas-with-aliases"><a href="#generic-schemas-with-aliases">Generic schemas with aliases</a></h2>
<p>Schemas can also be generic which allows reusing types. This enables certain behaviour patters
where super type declares common code for type aliases.</p>
<p>In this example we have common <code>Status</code> type which accepts one generic type. It is then defined
with <code>#[aliases(...)]</code> that it is going to be used with <a href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> and <a href="https://doc.rust-lang.org/1.73.0/std/primitive.i32.html" title="primitive i32"><code>i32</code></a> values.
The generic argument could also be another <a href="trait.ToSchema.html"><code>ToSchema</code></a> as well.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
#[aliases(StatusMessage = Status&lt;String&gt;, StatusNumber = Status&lt;i32&gt;)]
</span><span class="kw">struct </span>Status&lt;T&gt; {
    value: T
}

<span class="attr">#[derive(OpenApi)]
#[openapi(
    components(schemas(StatusMessage, StatusNumber))
)]
</span><span class="kw">struct </span>ApiDoc;</code></pre></div>
<p>The <code>#[aliases(...)]</code> is just syntactic sugar and will create Rust <a href="https://doc.rust-lang.org/reference/items/type-aliases.html">type aliases</a>
behind the scenes which then can be later referenced anywhere in code.</p>
<p><strong>Note!</strong> You should never register generic type itself in <code>components(...)</code> so according above example <code>Status&lt;...&gt;</code> should not be registered
because it will not render the type correctly and will cause an error in generated OpenAPI spec.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p><em><strong>Simple example of a Pet with descriptions and object level example.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// This is a pet.
</span><span class="attr">#[derive(ToSchema)]
#[schema(example = <span class="macro">json!</span>({<span class="string">&quot;name&quot;</span>: <span class="string">&quot;bob the cat&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="number">0</span>}))]
</span><span class="kw">struct </span>Pet {
    <span class="doccomment">/// Unique id of a pet.
    </span>id: u64,
    <span class="doccomment">/// Name of a pet.
    </span>name: String,
    <span class="doccomment">/// Age of a pet if known.
    </span>age: <span class="prelude-ty">Option</span>&lt;i32&gt;,
}</code></pre></div>
<p><em><strong>The <code>schema</code> attribute can also be placed at field level as follows.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">struct </span>Pet {
    <span class="attr">#[schema(example = <span class="number">1</span>, default = <span class="number">0</span>)]
    </span>id: u64,
    name: String,
    age: <span class="prelude-ty">Option</span>&lt;i32&gt;,
}</code></pre></div>
<p><em><strong>You can also use method reference for attribute values.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">struct </span>Pet {
    <span class="attr">#[schema(example = u64::default, default = u64::default)]
    </span>id: u64,
    <span class="attr">#[schema(default = default_name)]
    </span>name: String,
    age: <span class="prelude-ty">Option</span>&lt;i32&gt;,
}

<span class="kw">fn </span>default_name() -&gt; String {
    <span class="string">&quot;bob&quot;</span>.to_string()
}</code></pre></div>
<p><em><strong>For enums and unnamed field structs you can define <code>schema</code> at type level.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
#[schema(example = <span class="string">&quot;Bus&quot;</span>)]
</span><span class="kw">enum </span>VehicleType {
    Rocket, Car, Bus, Submarine
}</code></pre></div>
<p><em><strong>Also you write complex enum combining all above types.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">enum </span>ErrorResponse {
    InvalidCredentials,
    <span class="attr">#[schema(default = String::default, example = <span class="string">&quot;Pet not found&quot;</span>)]
    </span>NotFound(String),
    System {
        <span class="attr">#[schema(example = <span class="string">&quot;Unknown system failure&quot;</span>)]
        </span>details: String,
    }
}</code></pre></div>
<p><em><strong>It is possible to specify the title of each variant to help generators create named structures.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">enum </span>ErrorResponse {
    <span class="attr">#[schema(title = <span class="string">&quot;InvalidCredentials&quot;</span>)]
    </span>InvalidCredentials,
    <span class="attr">#[schema(title = <span class="string">&quot;NotFound&quot;</span>)]
    </span>NotFound(String),
}</code></pre></div>
<p><em><strong>Use <code>xml</code> attribute to manipulate xml output.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
#[schema(xml(name = <span class="string">&quot;user&quot;</span>, prefix = <span class="string">&quot;u&quot;</span>, namespace = <span class="string">&quot;https://user.xml.schema.test&quot;</span>))]
</span><span class="kw">struct </span>User {
    <span class="attr">#[schema(xml(attribute, prefix = <span class="string">&quot;u&quot;</span>))]
    </span>id: i64,
    <span class="attr">#[schema(xml(name = <span class="string">&quot;user_name&quot;</span>, prefix = <span class="string">&quot;u&quot;</span>))]
    </span>username: String,
    <span class="attr">#[schema(xml(wrapped(name = <span class="string">&quot;linkList&quot;</span>), name = <span class="string">&quot;link&quot;</span>))]
    </span>links: Vec&lt;String&gt;,
    <span class="attr">#[schema(xml(wrapped, name = <span class="string">&quot;photo_url&quot;</span>))]
    </span>photos_urls: Vec&lt;String&gt;
}</code></pre></div>
<p><em><strong>Use of Rust’s own <code>#[deprecated]</code> attribute will reflect to generated OpenAPI spec.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
#[deprecated]
</span><span class="kw">struct </span>User {
    id: i64,
    username: String,
    links: Vec&lt;String&gt;,
    <span class="attr">#[deprecated]
    </span>photos_urls: Vec&lt;String&gt;
}</code></pre></div>
<p><em><strong>Enforce type being used in OpenAPI spec to <a href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> with <code>value_type</code> and set format to octet stream
with <a href="openapi/schema/enum.KnownFormat.html#variant.Binary"><code>SchemaFormat::KnownFormat(KnownFormat::Binary)</code></a>.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">struct </span>Post {
    id: i32,
    <span class="attr">#[schema(value_type = String, format = Binary)]
    </span>value: Vec&lt;u8&gt;,
}</code></pre></div>
<p><em><strong>Enforce type being used in OpenAPI spec to <a href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> with <code>value_type</code> option.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
#[schema(value_type = String)]
</span><span class="kw">struct </span>Value(i64);</code></pre></div>
<p><em><strong>Override the <code>Bar</code> reference with a <code>custom::NewBar</code> reference.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">struct </span>Value {
    <span class="attr">#[schema(value_type = custom::NewBar)]
    </span>field: Bar,
};</code></pre></div>
<p><em><strong>Use a virtual <code>Object</code> type to render generic <code>object</code> <em>(<code>type: object</code>)</em> in OpenAPI spec.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(ToSchema)]
</span><span class="kw">struct </span>Value {
    <span class="attr">#[schema(value_type = Object)]
    </span>field: Bar,
};</code></pre></div>
<p><em><strong>Serde <code>rename</code> / <code>rename_all</code> will take precedence over schema <code>rename</code> / <code>rename_all</code>.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(utoipa::ToSchema, serde::Deserialize)]
#[serde(rename_all = <span class="string">&quot;lowercase&quot;</span>)]
#[schema(rename_all = <span class="string">&quot;UPPERCASE&quot;</span>)]
</span><span class="kw">enum </span>Random {
    <span class="attr">#[serde(rename = <span class="string">&quot;string_value&quot;</span>)]
    #[schema(rename = <span class="string">&quot;custom_value&quot;</span>)]
    </span>String(String),

    Number {
        id: i32,
    }
}</code></pre></div>
<p><em><strong>Add <code>title</code> to the enum.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(utoipa::ToSchema)]
#[schema(title = <span class="string">&quot;UserType&quot;</span>)]
</span><span class="kw">enum </span>UserType {
    Admin,
    Moderator,
    User,
}</code></pre></div>
<p><em><strong>Example with validation attributes.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(utoipa::ToSchema)]
</span><span class="kw">struct </span>Item {
    <span class="attr">#[schema(maximum = <span class="number">10</span>, minimum = <span class="number">5</span>, multiple_of = <span class="number">2.5</span>)]
    </span>id: i32,
    <span class="attr">#[schema(max_length = <span class="number">10</span>, min_length = <span class="number">5</span>, pattern = <span class="string">&quot;[a-z]*&quot;</span>)]
    </span>value: String,
    <span class="attr">#[schema(max_items = <span class="number">5</span>, min_items = <span class="number">1</span>)]
    </span>items: Vec&lt;String&gt;,
}</code></pre></div>
<p><em><strong>Use <code>schema_with</code> to manually implement schema for a field.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>custom_type() -&gt; Object {
    ObjectBuilder::new()
        .schema_type(utoipa::openapi::SchemaType::String)
        .format(<span class="prelude-val">Some</span>(utoipa::openapi::SchemaFormat::Custom(
            <span class="string">&quot;email&quot;</span>.to_string(),
        )))
        .description(<span class="prelude-val">Some</span>(<span class="string">&quot;this is the description&quot;</span>))
        .build()
}

<span class="attr">#[derive(utoipa::ToSchema)]
</span><span class="kw">struct </span>Value {
    <span class="attr">#[schema(schema_with = custom_type)]
    </span>id: String,
}</code></pre></div>
<p><em><strong>Use <code>as</code> attribute to change the name and the path of the schema in the generated OpenAPI
spec.</strong></em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[derive(utoipa::ToSchema)]
 #[schema(<span class="kw">as </span>= api::models::person::Person)]
 </span><span class="kw">struct </span>Person {
     name: String,
 }</code></pre></div>
<p>More examples for <em><code>value_type</code></em> in <a href="derive.IntoParams.html"><code>IntoParams</code> derive docs</a>.</p>
</div></details></section></div></main></body></html>