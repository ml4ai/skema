<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.TS2CAST.ts2cast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.TS2CAST.ts2cast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os.path
from typing import Any, Dict, List

from tree_sitter import Language, Parser

from skema.program_analysis.CAST2FN.cast import CAST
from skema.program_analysis.CAST2FN.model.cast import (
    Module,
    SourceRef,
    Assignment,
    LiteralValue,
    Var,
    VarType,
    Name,
    Operator,
    AstNode,
    SourceCodeDataType,
    ModelImport,
    FunctionDef,
    Loop,
    Call,
    ModelReturn,
    ModelIf,
)


from skema.program_analysis.TS2CAST.variable_context import VariableContext
from skema.program_analysis.TS2CAST.node_helper import NodeHelper
from skema.program_analysis.TS2CAST.util import generate_dummy_source_refs, preprocess

from skema.program_analysis.TS2CAST.build_tree_sitter_fortran import LANGUAGE_LIBRARY_REL_PATH

class TS2CAST(object):
    def __init__(self, source_file_path: str):
        # Initialize tree-sitter
        tree_sitter_fortran_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), LANGUAGE_LIBRARY_REL_PATH)
        self.tree_sitter_fortran = Language(tree_sitter_fortran_path, &#34;fortran&#34;)

        # We load the source code from a file
        self.source = None
        with open(source_file_path, &#34;r&#34;) as f:
            self.source = f.read()

        # Set up tree sitter parser
        self.parser = Parser()
        self.parser.set_language(self.tree_sitter_fortran)
        self.tree = self.parser.parse(bytes(self.source, &#34;utf8&#34;))

        # CAST objects
        self.module_name = None
        self.source_file_name = source_file_path
        self.module = Module()

        # Walking data
        self.variable_context = VariableContext()

        self.node_helper = NodeHelper(source_file_path, self.source)
        self.parse_dict = self.node_helper.parse_tree_to_dict(self.tree.root_node)
        # print(json.dumps(self.parse_dict))

        # Start visiting
        self.run(self.parse_dict)

        generate_dummy_source_refs(self.module)

        # Create outer cast wrapping
        self.out_cast = CAST([self.module], &#34;Fortran&#34;)
        # print(
        #            json.dumps(
        #               out_cast.to_json_object(), sort_keys=True, indent=None
        #            )
        #        )

    def run(self, root: Dict):
        self.module.source_refs = root[&#34;source_refs&#34;]
        self.module.body = []
        for child in root[&#34;children&#34;]:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                self.module.body.extend(child_cast)
            else:
                self.module.body.append(child_cast)

    def visit(self, node: Dict):
        if node[&#34;type&#34;] == &#34;program&#34;:
            return self.visit_program_statement(node)
        elif node[&#34;type&#34;] in [&#34;subroutine&#34;, &#34;function&#34;]:
            return self.visit_function_def(node)
        elif node[&#34;type&#34;] in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
            return self.visit_function_call(node)
        elif node[&#34;type&#34;] == &#34;use_statement&#34;:
            return self.visit_use_statement(node)
        elif node[&#34;type&#34;] == &#34;variable_declaration&#34;:
            return self.visit_variable_declaration(node)
        elif node[&#34;type&#34;] == &#34;assignment_statement&#34;:
            return self.visit_assignment_statement(node)
        elif node[&#34;type&#34;] == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node[&#34;type&#34;] == &#34;name&#34;:
            return self.visit_name(node)
        elif node[&#34;type&#34;] in [&#34;math_expression&#34;, &#34;relational_expression&#34;]:
            return self.visit_math_expression(node)
        elif node[&#34;type&#34;] in [
            &#34;number_literal&#34;,
            &#34;array_literal&#34;,
            &#34;string_literal&#34;,
            &#34;boolean_literal&#34;,
        ]:
            return self.visit_literal(node)
        elif node[&#34;type&#34;] == &#34;keyword_statement&#34;:
            return self.visit_keyword_statement(node)
        elif node[&#34;type&#34;] == &#34;extent_specifier&#34;:
            return self.visit_extent_specifier(node)
        elif node[&#34;type&#34;] == &#34;do_loop_statement&#34;:
            return self.visit_do_loop_statement(node)
        elif node[&#34;type&#34;] == &#34;if_statement&#34;:
            return self.visit_if_statement(node)
        else:
            return self._visit_passthrough(node)

    def visit_program_statement(self, node):
        program_body = []
        for child in node[&#34;children&#34;][1:]:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                program_body.extend(child_cast)
            else:
                program_body.append(child_cast)
        return program_body

    def visit_name(self, node):
        # Node structure
        # (name)
        assert len(node[&#34;children&#34;]) == 0

        # First, we will check if this name is already defined, and if it is
        if self.variable_context.is_variable(node[&#34;identifier&#34;]):
            return self.variable_context.get_node(node[&#34;identifier&#34;])

        return self.variable_context.add_variable(
            node[&#34;identifier&#34;], &#34;Unknown&#34;, node[&#34;source_refs&#34;]
        )

    def visit_function_def(self, node):
        # Node structure
        # (subroutine)
        #   (subroutine_statement)
        #     (subroutine)
        #     (name)
        #     (parameters) - Optional
        #   (body_node) ...
        # (function)
        #   (function_statement)
        #     (function)
        #     (intrinsic_type) - Optional
        #     (name)
        #     (parameters) - Optional
        #     (function_result) - Optional
        #       (identifier)
        #  (body_node) ...

        # Create a new variable context
        self.variable_context.push_context()

        # Top level statement node
        statement_node = node[&#34;children&#34;][0]
        name_node = self.node_helper.get_first_child_by_type(statement_node, &#34;name&#34;)
        self.visit(name_node)  # Visit the name node

        # If this is a function, check for return type and return value
        intrinsic_type = None
        return_value = None
        if node[&#34;type&#34;] == &#34;function&#34;:
            if intrinsic_type_node := self.node_helper.get_first_child_by_type(
                statement_node, &#34;intrinsic_type&#34;
            ):
                intrinsic_type = intrinsic_type_node[&#34;identifier&#34;]
                self.variable_context.add_variable(
                    name_node[&#34;identifier&#34;], intrinsic_type, None
                )
            if return_value_node := self.node_helper.get_first_child_by_type(
                statement_node, &#34;function_result&#34;
            ):
                return_value = self.visit(return_value_node[&#34;children&#34;][1])
                self.variable_context.add_return_value(return_value.val.name)
            else:
                # #TODO: What happens if function doesn&#39;t return anything?
                # If this is a function, and there is no explicit results variable, then we will assume the return value is the name of the function
                self.variable_context.add_return_value(name_node[&#34;identifier&#34;])

        # If funciton has both, then we also need to update the type of the return value in the variable context
        # It does not explicity have to be declared
        if return_value and intrinsic_type:
            self.variable_context.update_type(return_value.val.name, intrinsic_type)

        cast_func = FunctionDef()
        cast_func.source_refs = node[&#34;source_refs&#34;]
        cast_func.func_args = []
        cast_func.body = []
        cast_func.name = self.visit(name_node)

        # Generating the function arguments by walking the parameters node
        parameters_node = self.node_helper.get_first_child_by_type(
            statement_node, &#34;parameters&#34;
        )
        if parameters_node:
            for child in parameters_node[&#34;children&#34;]:
                # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
                # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
                self.variable_context.add_return_value(child[&#34;identifier&#34;])

                cast_func.func_args = TS2CAST.update_field(
                    cast_func.func_args, self.visit(child)
                )

        # The first child of function will be the function statement, the rest will be body nodes
        for child in node[&#34;children&#34;][1:]:
            cast_func.body = TS2CAST.update_field(cast_func.body, self.visit(child))

        # After creating the body, we can go back and update the var nodes we created for the arguments
        # We do this by looking for intent,in nodes
        for i, arg in enumerate(cast_func.func_args):
            cast_func.func_args[i].type = self.variable_context.get_type(arg.val.name)

        # TODO:
        # This logic can be made cleaner
        # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
        # If there is not, then we will create a dummy one
        return_found = False
        for child in cast_func.body:
            if isinstance(child, ModelReturn):
                return_found = True
        if not return_found:
            cast_func.body.append(self.visit_keyword_statement(node))

        # Pop variable context off of stack before leaving this scope
        self.variable_context.pop_context()

        return cast_func

    def visit_function_call(self, node):
        # Pull relevent nodes
        if node[&#34;type&#34;] == &#34;subroutine_call&#34;:
            function_node = node[&#34;children&#34;][1]
            arguments_node = node[&#34;children&#34;][2]
        elif node[&#34;type&#34;] == &#34;call_expression&#34;:
            function_node = node[&#34;children&#34;][0]
            arguments_node = node[&#34;children&#34;][1]

        function_identifier = function_node[&#34;identifier&#34;]

        # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
        # We will need to check if this is truly a function call or a subscript
        if self.variable_context.is_variable(function_identifier):
            if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
                return self._visit_get(
                    node
                )  # This overrides the visitor and forces us to visit another

        cast_call = Call()
        cast_call.source_refs = node[&#34;source_refs&#34;]

        # TODO: What should get a name node? Instrincit functions? Imported functions?
        # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
        if self.variable_context.is_variable(function_identifier):
            cast_call.func = self.variable_context.get_node(function_identifier)
        else:
            cast_call.func = Name(function_identifier, -1)

        # Add arguments to arguments list
        for child in arguments_node[&#34;children&#34;]:
            cast_call.arguments = TS2CAST.update_field(
                cast_call.arguments, self.visit(child)
            )

        return cast_call

    def visit_keyword_statement(self, node):
        # Currently, the only keyword_identifier produced by tree-sitter is Return
        # However, there may be other instances
        cast_return = ModelReturn(source_refs=node[&#34;source_refs&#34;])

        # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
        # We keep track of values that need to be returned in the variable context
        return_values = self.variable_context.context_return_values[
            -1
        ]  # TODO: Make function for this

        if len(return_values) == 1:
            cast_return.value = self.variable_context.get_node(return_values[0])
        elif len(return_values) &gt; 1:
            cast_tuple = LiteralValue(&#34;Tuple&#34;, [])

            for return_value in return_values:
                cast_var = Var()
                cast_var.val = self.variable_context.get_node(return_value)
                cast_var.type = self.variable_context.get_type(return_value)
                cast_tuple.value.append(cast_var)
            cast_return.value = cast_tuple
        else:
            cast_return.value = LiteralValue(None, None)

        return cast_return

    def visit_use_statement(self, node):
        ## Pull relevent child nodes
        module_name_node = node[&#34;children&#34;][0]
        included_items_nodes = self.node_helper.get_children_by_type(
            node,
            &#34;included_items&#34;,
        )

        import_all = len(included_items_nodes) == 0
        import_alias = None  # TODO: Look into local-name and use-name fields

        # We need to check if this import is a full import of a module, i.e. use module
        # Or a partial import i.e. use module,only: sub1, sub2
        if import_all:
            cast_import = ModelImport()
            cast_import.source_refs = node[&#34;source_refs&#34;]
            cast_import.name = module_name_node[&#34;identifier&#34;]
            cast_import.alias = import_alias
            cast_import.all = import_all
            cast_import.symbol = None

            return cast_import
        else:
            imports = []
            for child in included_items_nodes[0][&#34;children&#34;]:
                cast_import = ModelImport()
                cast_import.source_refs = child[&#34;source_refs&#34;]
                cast_import.name = module_name_node[&#34;identifier&#34;]
                cast_import.alias = import_alias
                cast_import.all = import_all
                cast_import.symbol = child[&#34;identifier&#34;]

                # Add the symbol to the variable context
                self.variable_context.add_variable(
                    cast_import.symbol, &#34;function&#34;, child[&#34;source_refs&#34;]
                )

                imports.append(cast_import)
            return imports

    def visit_do_loop_statement(self, node):
        # Node structure
        # Do loop
        # (do_loop_statement)
        #   (do) - TODO: Get rid of extraneous nodes like this
        #   (loop_control_expression)
        #     (...) ...
        #   (body) ...
        #
        # Do while
        # (do_loop_statement)
        #   (do)
        #   (while_statement)
        #     (while)
        #     (parenthesized_expression)
        #      (...) ...
        #   (body) ...
        # print(self.variable_context.context)
        assert len(node[&#34;children&#34;]) &gt; 2
        loop_type = node[&#34;children&#34;][1][&#34;type&#34;]

        cast_loop = Loop()
        cast_loop.source_refs = node[&#34;source_refs&#34;]
        cast_loop.pre = []
        cast_loop.post = []
        cast_loop.expr = None
        cast_loop.body = []

        # The body will be the same for both loops, like the function definition, its simply every child node after the first
        # TODO: This may not be the case
        for child in node[&#34;children&#34;][2:]:
            cast_loop.body = self.update_field(cast_loop.body, self.visit(child))

        # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop

        # PRE:
        # TODO: Why is this different from the schema
        # _next(_iter(range(start, stop, step)))
        loop_control_node = node[&#34;children&#34;][1]
        itterator = self.visit(loop_control_node[&#34;children&#34;][0])
        start = self.visit(loop_control_node[&#34;children&#34;][1])
        stop = self.visit(loop_control_node[&#34;children&#34;][2])

        if len(loop_control_node[&#34;children&#34;]) == 3:  # No step value
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_node[&#34;children&#34;]) == 4:
            step = self.visit(loop_control_node[&#34;children&#34;][3])

        range_name_node = self.get_gromet_function_node(&#34;range&#34;)
        iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
        next_name_node = self.get_gromet_function_node(&#34;next&#34;)
        generated_iter_name_node = self.variable_context.generate_iterator()
        stop_condition_name_node = self.variable_context.generate_stop_condition()

        # generated_iter_0 = iter(range(start, stop, step))
        cast_loop.pre.append(
            Assignment(
                left=Var(generated_iter_name_node, &#34;Iterator&#34;),
                right=Call(
                    iter_name_node,
                    arguments=[Call(range_name_node, arguments=[start, stop, step])],
                ),
            )
        )

        # (i, generated_iter_0, sc_0) = next(generated_iter_0)
        cast_loop.pre.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # EXPR
        cast_loop.expr = Operator(
            op=&#34;!=&#34;,  # TODO: Should this be == or !=
            operands=[
                Var(stop_condition_name_node, &#34;Boolean&#34;),
                LiteralValue(&#34;Boolean&#34;, True),
            ],
        )

        # BODY
        # At this point, the body nodes have already been visited
        # We just need to append the iterator next call
        cast_loop.body.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # POST
        cast_loop.post.append(
            Assignment(
                left=itterator,
                right=Operator(op=&#34;+&#34;, operands=[itterator, step]),
            )
        )

        return cast_loop

    def visit_if_statement(self, node):
        # (if_statement)
        #  (if)
        #  (parenthesised_expression)
        #  (then)
        #  (body_nodes) ...
        #  (elseif_clauses) ..
        #  (else_clause)
        #  (end_if_statement)

        child_types = [child[&#34;type&#34;] for child in node[&#34;children&#34;]]

        try:
            elseif_index = child_types.index(&#34;elseif_clause&#34;)
        except ValueError:
            elseif_index = -1

        try:
            else_index = child_types.index(&#34;else_clause&#34;)
        except ValueError:
            else_index = -1

        if elseif_index != -1:
            body_stop_index = elseif_index
        else:
            body_stop_index = else_index

        prev = None
        orelse = None
        # If there are else_if statements, they need
        if elseif_index != -1:
            orelse = ModelIf()
            prev = orelse
            for condition in node[&#34;children&#34;][elseif_index:else_index]:
                elseif_expr = self.visit(condition[&#34;children&#34;][2])
                elseif_body = [self.visit(child) for child in condition[&#34;children&#34;][4:]]

                prev.orelse = ModelIf(elseif_expr, elseif_body, None)
                prev = prev.orelse

        if else_index != -1:
            else_body = [
                self.visit(child)
                for child in node[&#34;children&#34;][else_index][&#34;children&#34;][1:]
            ]
            if prev:
                prev.orelse = else_body
            else:
                orelse = else_body

        if isinstance(orelse, ModelIf):
            orelse = orelse.orelse

        return ModelIf(
            expr=self.visit(node[&#34;children&#34;][1]),
            body=[self.visit(child) for child in node[&#34;children&#34;][3:body_stop_index]],
            orelse=orelse,
        )

    def visit_assignment_statement(self, node):
        cast_assignment = Assignment()
        cast_assignment.source_refs = node[&#34;source_refs&#34;]

        assert len(node[&#34;children&#34;]) == 2
        left, right = node[&#34;children&#34;]

        # We need to check if the left side is a multidimensional array,
        # Since tree-sitter incorrectly shows this assignment as a call_expression
        if left[&#34;type&#34;] == &#34;call_expression&#34;:
            return self._visit_set(node)

        cast_assignment.left = self.visit(left)
        cast_assignment.right = self.visit(right)

        return cast_assignment

    def visit_literal(self, node):
        literal_type = node[&#34;type&#34;]
        literal_value = node[&#34;identifier&#34;]

        cast_literal = LiteralValue()
        cast_literal.source_refs = node[&#34;source_refs&#34;]

        if literal_type == &#34;number_literal&#34;:
            # Check if this is a real value, or an Integer
            if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
                cast_literal.value_type = &#34;AbstractFloat&#34;
                cast_literal.source_code_data_type = [
                    &#34;Fortran&#34;,
                    &#34;Fortran95&#34;,
                    &#34;real&#34;,
                ]
            else:
                cast_literal.value_type = &#34;Integer&#34;
                cast_literal.source_code_data_type = [
                    &#34;Fortran&#34;,
                    &#34;Fortran95&#34;,
                    &#34;integer&#34;,
                ]
            cast_literal.value = literal_value

        elif literal_type == &#34;string_literal&#34;:
            cast_literal.value_type = &#34;Character&#34;
            cast_literal.source_code_data_type = [
                &#34;Fortran&#34;,
                &#34;Fortran95&#34;,
                &#34;character&#34;,
            ]
            cast_literal.value = literal_value

        elif literal_type == &#34;boolean_literal&#34;:
            cast_literal.value_type = &#34;Boolean&#34;
            cast_literal.source_code_data_type = [&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;logical&#34;]
            cast_literal.value = literal_value

        elif literal_type == &#34;array_literal&#34;:
            cast_literal.value_type = &#34;List&#34;
            cast_literal.source_code_data_type = [
                &#34;Fortran&#34;,
                &#34;Fortran95&#34;,
                &#34;dimension&#34;,
            ]
            cast_literal.value = None

        return cast_literal

    def visit_identifier(self, node):
        cast_var = Var()
        cast_var.source_refs = node[&#34;source_refs&#34;]

        # By default, this is unknown, but can be updated by other visitors
        if self.variable_context.is_variable(node[&#34;identifier&#34;]):
            cast_var.type = self.variable_context.get_type(node[&#34;identifier&#34;])
        else:
            cast_var.type = &#34;Unknown&#34;

        # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
        # Fortran does have optional arguments introduced in F90, but these do not specify a default
        cast_var.default_value = None

        # This is another case where we need to override the visitor to explicitly visit another node
        cast_var.val = self.visit_name(node)

        return cast_var

    def visit_math_expression(self, node):
        op = node[&#34;control&#34;][0]  # The operator will be the first control character

        cast_op = Operator()
        cast_op.source_refs = node[&#34;source_refs&#34;]

        cast_op.source_language = &#34;Fortran&#34;
        cast_op.interpreter = None
        cast_op.version = None

        cast_op.op = op[&#34;identifier&#34;]

        for child in node[&#34;children&#34;]:
            cast_op.operands = TS2CAST.update_field(cast_op.operands, self.visit(child))

        return cast_op

    def visit_variable_declaration(self, node):
        # Node structure
        # (variable_declaration)
        #   (intrinsic_type)
        #   (type_qualifier)
        #     (qualifier)
        #     (value)
        #   (identifier) ...
        #   (assignment_statement) ...

        # The type will be determined from the child intrensic_type node
        # TODO: Expand this type map and move it somewhere else
        type_map = {
            &#34;integer&#34;: &#34;Integer&#34;,
            &#34;real&#34;: &#34;AbstractFloat&#34;,
            &#34;complex&#34;: None,
            &#34;logical&#34;: &#34;Boolean&#34;,
            &#34;character&#34;: &#34;String&#34;,
        }

        intrinsic_type = type_map[node[&#34;children&#34;][0][&#34;identifier&#34;]]
        variable_intent = &#34;TODO&#34;

        type_qualifiers = self.node_helper.get_children_by_type(node, &#34;type_qualifier&#34;)
        identifiers = self.node_helper.get_children_by_type(node, &#34;identifier&#34;)
        assignment_statements = self.node_helper.get_children_by_type(
            node, &#34;assignment_statement&#34;
        )

        # We then need to determine if we are creating an array (dimension) or a single variable
        for type_qualifier in type_qualifiers:
            qualifier = type_qualifier[&#34;children&#34;][0][&#34;identifier&#34;]
            try:
                value = type_qualifier[&#34;children&#34;][1][&#34;identifier&#34;]
            except IndexError:
                # There are a few cases of qualifiers without values such as parameter. These are not currently being handled
                continue

            if qualifier == &#34;dimension&#34;:
                intrinsic_type = &#34;List&#34;
            elif qualifier == &#34;intent&#34;:
                variable_intent = value

        # You can declare multiple variables of the same type in a single statement, so we need to create a Var node for each instance
        vars = []
        for identifier in identifiers:
            cast_var = self.visit(identifier)
            cast_var.type = intrinsic_type
            self.variable_context.update_type(cast_var.val.name, intrinsic_type)

            vars.append(cast_var)

        for assignment_statement in assignment_statements:
            cast_assignment = self.visit(assignment_statement)
            cast_assignment.left.type = intrinsic_type
            self.variable_context.update_type(
                cast_assignment.left.val.name, intrinsic_type
            )

            vars.append(cast_assignment)

        # If the intent is out, we need to add all these variables to the return values
        # TODO: But what if one branch has a different return value? Are ifs going to be a seperate context
        if variable_intent == &#34;in&#34;:
            for var in vars:
                self.variable_context.remove_return_value(var.val.name)

        return vars

    def visit_extent_specifier(self, node):
        # Node structure
        # (extent_specifier)
        #   (identifier)
        #   (identifier)

        # The extent specifier is the same as a slice, it can have a start, stop, and step
        # We can determine these by looking at the number of control characters in this node.
        # Fortran uses the character &#39;:&#39; to differentiate these values
        cast_call = Call()
        cast_call.source_refs = node[&#34;source_refs&#34;]
        cast_call.func = self.get_gromet_function_node(&#34;slice&#34;)
        cast_call.arguments = [
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
        ]
        argument_pointer = 0

        for child in node[&#34;original_children_order&#34;]:
            if child[&#34;type&#34;] == &#34;:&#34;:
                argument_pointer += 1
            else:
                cast_call.arguments[argument_pointer] = self.visit(child)

        return cast_call

    # NOTE: This function starts with _ because it will never be dispatched to directly. There is not a get node in the tree-sitter parse tree.
    # From context, we will determine when we are accessing an element of a List, and call this function,
    def _visit_get(self, node):
        # Node structure
        # (call_expression)
        #  (identifier)
        #  (argument_list)

        assert len(node[&#34;children&#34;]) == 2
        identifier = node[&#34;children&#34;][0]
        arguments = node[&#34;children&#34;][1][&#34;children&#34;]

        # This is a call to the get Gromet function
        cast_call = Call()
        cast_call.source_refs = node[&#34;source_refs&#34;]

        # We can generate/get the name node for the &#34;get&#34; function by passing the identifier node to the name visitor
        cast_call.func = self.get_gromet_function_node(&#34;get&#34;)

        # First argument to get is the List itself. We can get this by passing the identifier to the identifier visitor
        cast_call.arguments = []
        cast_call.arguments.append(self.visit(identifier))

        # If there are more than one arguments, then this is a multi dimensional array and we need to use an extended slice
        if len(arguments) &gt; 1:
            dimension_list = LiteralValue()
            dimension_list.source_refs = node[&#34;children&#34;][1][&#34;source_refs&#34;]
            dimension_list.value_type = &#34;List&#34;
            dimension_list.value = []
            for argument in arguments:
                dimension_list.value.append(self.visit(argument))

            extslice_call = Call()
            extslice_call.source_refs = node[&#34;source_refs&#34;]
            extslice_call.func = self.get_gromet_function_node(&#34;ext_slice&#34;)
            extslice_call.arguments = []
            extslice_call.arguments.append(dimension_list)

            cast_call.arguments.append(extslice_call)
        else:
            cast_call.arguments.append(self.visit(arguments[0]))

        return cast_call

    def _visit_set(self, node):
        # Node structure
        # (assignment_statement)
        #  (call_expression)
        #  (right side)

        assert (len(node[&#34;children&#34;])) == 2
        left, right = node[&#34;children&#34;]

        # The left side is equivilent to a call gromet &#34;get&#34;, so we will first pass the left side to the get visitor
        # Then we can easily convert this to a &#34;set&#34; call by modifying the fields and then appending the right side to the function arguments
        cast_call = self._visit_get(left)
        cast_call.source_refs = node[&#34;source_refs&#34;]
        cast_call.func = self.get_gromet_function_node(&#34;set&#34;)
        cast_call.arguments.append(self.visit(right))

        return cast_call

    def _visit_passthrough(self, node):
        if len(node[&#34;children&#34;]) == 0:
            return []

        return self.visit(node[&#34;children&#34;][0])

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        node_dict = {&#34;identifier&#34;: func_name, &#34;source_refs&#34;: [], &#34;children&#34;: []}
        cast_name = self.visit_name(node_dict)

        return cast_name

    @staticmethod
    def update_field(field: Any, element: Any) -&gt; List:
        if not field:
            field = []

        if element:
            if isinstance(element, List):
                field.extend(element)
            else:
                field.append(element)

        return field</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST"><code class="flex name class">
<span>class <span class="ident">TS2CAST</span></span>
<span>(</span><span>source_file_path:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TS2CAST(object):
    def __init__(self, source_file_path: str):
        # Initialize tree-sitter
        tree_sitter_fortran_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), LANGUAGE_LIBRARY_REL_PATH)
        self.tree_sitter_fortran = Language(tree_sitter_fortran_path, &#34;fortran&#34;)

        # We load the source code from a file
        self.source = None
        with open(source_file_path, &#34;r&#34;) as f:
            self.source = f.read()

        # Set up tree sitter parser
        self.parser = Parser()
        self.parser.set_language(self.tree_sitter_fortran)
        self.tree = self.parser.parse(bytes(self.source, &#34;utf8&#34;))

        # CAST objects
        self.module_name = None
        self.source_file_name = source_file_path
        self.module = Module()

        # Walking data
        self.variable_context = VariableContext()

        self.node_helper = NodeHelper(source_file_path, self.source)
        self.parse_dict = self.node_helper.parse_tree_to_dict(self.tree.root_node)
        # print(json.dumps(self.parse_dict))

        # Start visiting
        self.run(self.parse_dict)

        generate_dummy_source_refs(self.module)

        # Create outer cast wrapping
        self.out_cast = CAST([self.module], &#34;Fortran&#34;)
        # print(
        #            json.dumps(
        #               out_cast.to_json_object(), sort_keys=True, indent=None
        #            )
        #        )

    def run(self, root: Dict):
        self.module.source_refs = root[&#34;source_refs&#34;]
        self.module.body = []
        for child in root[&#34;children&#34;]:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                self.module.body.extend(child_cast)
            else:
                self.module.body.append(child_cast)

    def visit(self, node: Dict):
        if node[&#34;type&#34;] == &#34;program&#34;:
            return self.visit_program_statement(node)
        elif node[&#34;type&#34;] in [&#34;subroutine&#34;, &#34;function&#34;]:
            return self.visit_function_def(node)
        elif node[&#34;type&#34;] in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
            return self.visit_function_call(node)
        elif node[&#34;type&#34;] == &#34;use_statement&#34;:
            return self.visit_use_statement(node)
        elif node[&#34;type&#34;] == &#34;variable_declaration&#34;:
            return self.visit_variable_declaration(node)
        elif node[&#34;type&#34;] == &#34;assignment_statement&#34;:
            return self.visit_assignment_statement(node)
        elif node[&#34;type&#34;] == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node[&#34;type&#34;] == &#34;name&#34;:
            return self.visit_name(node)
        elif node[&#34;type&#34;] in [&#34;math_expression&#34;, &#34;relational_expression&#34;]:
            return self.visit_math_expression(node)
        elif node[&#34;type&#34;] in [
            &#34;number_literal&#34;,
            &#34;array_literal&#34;,
            &#34;string_literal&#34;,
            &#34;boolean_literal&#34;,
        ]:
            return self.visit_literal(node)
        elif node[&#34;type&#34;] == &#34;keyword_statement&#34;:
            return self.visit_keyword_statement(node)
        elif node[&#34;type&#34;] == &#34;extent_specifier&#34;:
            return self.visit_extent_specifier(node)
        elif node[&#34;type&#34;] == &#34;do_loop_statement&#34;:
            return self.visit_do_loop_statement(node)
        elif node[&#34;type&#34;] == &#34;if_statement&#34;:
            return self.visit_if_statement(node)
        else:
            return self._visit_passthrough(node)

    def visit_program_statement(self, node):
        program_body = []
        for child in node[&#34;children&#34;][1:]:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                program_body.extend(child_cast)
            else:
                program_body.append(child_cast)
        return program_body

    def visit_name(self, node):
        # Node structure
        # (name)
        assert len(node[&#34;children&#34;]) == 0

        # First, we will check if this name is already defined, and if it is
        if self.variable_context.is_variable(node[&#34;identifier&#34;]):
            return self.variable_context.get_node(node[&#34;identifier&#34;])

        return self.variable_context.add_variable(
            node[&#34;identifier&#34;], &#34;Unknown&#34;, node[&#34;source_refs&#34;]
        )

    def visit_function_def(self, node):
        # Node structure
        # (subroutine)
        #   (subroutine_statement)
        #     (subroutine)
        #     (name)
        #     (parameters) - Optional
        #   (body_node) ...
        # (function)
        #   (function_statement)
        #     (function)
        #     (intrinsic_type) - Optional
        #     (name)
        #     (parameters) - Optional
        #     (function_result) - Optional
        #       (identifier)
        #  (body_node) ...

        # Create a new variable context
        self.variable_context.push_context()

        # Top level statement node
        statement_node = node[&#34;children&#34;][0]
        name_node = self.node_helper.get_first_child_by_type(statement_node, &#34;name&#34;)
        self.visit(name_node)  # Visit the name node

        # If this is a function, check for return type and return value
        intrinsic_type = None
        return_value = None
        if node[&#34;type&#34;] == &#34;function&#34;:
            if intrinsic_type_node := self.node_helper.get_first_child_by_type(
                statement_node, &#34;intrinsic_type&#34;
            ):
                intrinsic_type = intrinsic_type_node[&#34;identifier&#34;]
                self.variable_context.add_variable(
                    name_node[&#34;identifier&#34;], intrinsic_type, None
                )
            if return_value_node := self.node_helper.get_first_child_by_type(
                statement_node, &#34;function_result&#34;
            ):
                return_value = self.visit(return_value_node[&#34;children&#34;][1])
                self.variable_context.add_return_value(return_value.val.name)
            else:
                # #TODO: What happens if function doesn&#39;t return anything?
                # If this is a function, and there is no explicit results variable, then we will assume the return value is the name of the function
                self.variable_context.add_return_value(name_node[&#34;identifier&#34;])

        # If funciton has both, then we also need to update the type of the return value in the variable context
        # It does not explicity have to be declared
        if return_value and intrinsic_type:
            self.variable_context.update_type(return_value.val.name, intrinsic_type)

        cast_func = FunctionDef()
        cast_func.source_refs = node[&#34;source_refs&#34;]
        cast_func.func_args = []
        cast_func.body = []
        cast_func.name = self.visit(name_node)

        # Generating the function arguments by walking the parameters node
        parameters_node = self.node_helper.get_first_child_by_type(
            statement_node, &#34;parameters&#34;
        )
        if parameters_node:
            for child in parameters_node[&#34;children&#34;]:
                # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
                # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
                self.variable_context.add_return_value(child[&#34;identifier&#34;])

                cast_func.func_args = TS2CAST.update_field(
                    cast_func.func_args, self.visit(child)
                )

        # The first child of function will be the function statement, the rest will be body nodes
        for child in node[&#34;children&#34;][1:]:
            cast_func.body = TS2CAST.update_field(cast_func.body, self.visit(child))

        # After creating the body, we can go back and update the var nodes we created for the arguments
        # We do this by looking for intent,in nodes
        for i, arg in enumerate(cast_func.func_args):
            cast_func.func_args[i].type = self.variable_context.get_type(arg.val.name)

        # TODO:
        # This logic can be made cleaner
        # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
        # If there is not, then we will create a dummy one
        return_found = False
        for child in cast_func.body:
            if isinstance(child, ModelReturn):
                return_found = True
        if not return_found:
            cast_func.body.append(self.visit_keyword_statement(node))

        # Pop variable context off of stack before leaving this scope
        self.variable_context.pop_context()

        return cast_func

    def visit_function_call(self, node):
        # Pull relevent nodes
        if node[&#34;type&#34;] == &#34;subroutine_call&#34;:
            function_node = node[&#34;children&#34;][1]
            arguments_node = node[&#34;children&#34;][2]
        elif node[&#34;type&#34;] == &#34;call_expression&#34;:
            function_node = node[&#34;children&#34;][0]
            arguments_node = node[&#34;children&#34;][1]

        function_identifier = function_node[&#34;identifier&#34;]

        # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
        # We will need to check if this is truly a function call or a subscript
        if self.variable_context.is_variable(function_identifier):
            if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
                return self._visit_get(
                    node
                )  # This overrides the visitor and forces us to visit another

        cast_call = Call()
        cast_call.source_refs = node[&#34;source_refs&#34;]

        # TODO: What should get a name node? Instrincit functions? Imported functions?
        # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
        if self.variable_context.is_variable(function_identifier):
            cast_call.func = self.variable_context.get_node(function_identifier)
        else:
            cast_call.func = Name(function_identifier, -1)

        # Add arguments to arguments list
        for child in arguments_node[&#34;children&#34;]:
            cast_call.arguments = TS2CAST.update_field(
                cast_call.arguments, self.visit(child)
            )

        return cast_call

    def visit_keyword_statement(self, node):
        # Currently, the only keyword_identifier produced by tree-sitter is Return
        # However, there may be other instances
        cast_return = ModelReturn(source_refs=node[&#34;source_refs&#34;])

        # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
        # We keep track of values that need to be returned in the variable context
        return_values = self.variable_context.context_return_values[
            -1
        ]  # TODO: Make function for this

        if len(return_values) == 1:
            cast_return.value = self.variable_context.get_node(return_values[0])
        elif len(return_values) &gt; 1:
            cast_tuple = LiteralValue(&#34;Tuple&#34;, [])

            for return_value in return_values:
                cast_var = Var()
                cast_var.val = self.variable_context.get_node(return_value)
                cast_var.type = self.variable_context.get_type(return_value)
                cast_tuple.value.append(cast_var)
            cast_return.value = cast_tuple
        else:
            cast_return.value = LiteralValue(None, None)

        return cast_return

    def visit_use_statement(self, node):
        ## Pull relevent child nodes
        module_name_node = node[&#34;children&#34;][0]
        included_items_nodes = self.node_helper.get_children_by_type(
            node,
            &#34;included_items&#34;,
        )

        import_all = len(included_items_nodes) == 0
        import_alias = None  # TODO: Look into local-name and use-name fields

        # We need to check if this import is a full import of a module, i.e. use module
        # Or a partial import i.e. use module,only: sub1, sub2
        if import_all:
            cast_import = ModelImport()
            cast_import.source_refs = node[&#34;source_refs&#34;]
            cast_import.name = module_name_node[&#34;identifier&#34;]
            cast_import.alias = import_alias
            cast_import.all = import_all
            cast_import.symbol = None

            return cast_import
        else:
            imports = []
            for child in included_items_nodes[0][&#34;children&#34;]:
                cast_import = ModelImport()
                cast_import.source_refs = child[&#34;source_refs&#34;]
                cast_import.name = module_name_node[&#34;identifier&#34;]
                cast_import.alias = import_alias
                cast_import.all = import_all
                cast_import.symbol = child[&#34;identifier&#34;]

                # Add the symbol to the variable context
                self.variable_context.add_variable(
                    cast_import.symbol, &#34;function&#34;, child[&#34;source_refs&#34;]
                )

                imports.append(cast_import)
            return imports

    def visit_do_loop_statement(self, node):
        # Node structure
        # Do loop
        # (do_loop_statement)
        #   (do) - TODO: Get rid of extraneous nodes like this
        #   (loop_control_expression)
        #     (...) ...
        #   (body) ...
        #
        # Do while
        # (do_loop_statement)
        #   (do)
        #   (while_statement)
        #     (while)
        #     (parenthesized_expression)
        #      (...) ...
        #   (body) ...
        # print(self.variable_context.context)
        assert len(node[&#34;children&#34;]) &gt; 2
        loop_type = node[&#34;children&#34;][1][&#34;type&#34;]

        cast_loop = Loop()
        cast_loop.source_refs = node[&#34;source_refs&#34;]
        cast_loop.pre = []
        cast_loop.post = []
        cast_loop.expr = None
        cast_loop.body = []

        # The body will be the same for both loops, like the function definition, its simply every child node after the first
        # TODO: This may not be the case
        for child in node[&#34;children&#34;][2:]:
            cast_loop.body = self.update_field(cast_loop.body, self.visit(child))

        # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop

        # PRE:
        # TODO: Why is this different from the schema
        # _next(_iter(range(start, stop, step)))
        loop_control_node = node[&#34;children&#34;][1]
        itterator = self.visit(loop_control_node[&#34;children&#34;][0])
        start = self.visit(loop_control_node[&#34;children&#34;][1])
        stop = self.visit(loop_control_node[&#34;children&#34;][2])

        if len(loop_control_node[&#34;children&#34;]) == 3:  # No step value
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_node[&#34;children&#34;]) == 4:
            step = self.visit(loop_control_node[&#34;children&#34;][3])

        range_name_node = self.get_gromet_function_node(&#34;range&#34;)
        iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
        next_name_node = self.get_gromet_function_node(&#34;next&#34;)
        generated_iter_name_node = self.variable_context.generate_iterator()
        stop_condition_name_node = self.variable_context.generate_stop_condition()

        # generated_iter_0 = iter(range(start, stop, step))
        cast_loop.pre.append(
            Assignment(
                left=Var(generated_iter_name_node, &#34;Iterator&#34;),
                right=Call(
                    iter_name_node,
                    arguments=[Call(range_name_node, arguments=[start, stop, step])],
                ),
            )
        )

        # (i, generated_iter_0, sc_0) = next(generated_iter_0)
        cast_loop.pre.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # EXPR
        cast_loop.expr = Operator(
            op=&#34;!=&#34;,  # TODO: Should this be == or !=
            operands=[
                Var(stop_condition_name_node, &#34;Boolean&#34;),
                LiteralValue(&#34;Boolean&#34;, True),
            ],
        )

        # BODY
        # At this point, the body nodes have already been visited
        # We just need to append the iterator next call
        cast_loop.body.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # POST
        cast_loop.post.append(
            Assignment(
                left=itterator,
                right=Operator(op=&#34;+&#34;, operands=[itterator, step]),
            )
        )

        return cast_loop

    def visit_if_statement(self, node):
        # (if_statement)
        #  (if)
        #  (parenthesised_expression)
        #  (then)
        #  (body_nodes) ...
        #  (elseif_clauses) ..
        #  (else_clause)
        #  (end_if_statement)

        child_types = [child[&#34;type&#34;] for child in node[&#34;children&#34;]]

        try:
            elseif_index = child_types.index(&#34;elseif_clause&#34;)
        except ValueError:
            elseif_index = -1

        try:
            else_index = child_types.index(&#34;else_clause&#34;)
        except ValueError:
            else_index = -1

        if elseif_index != -1:
            body_stop_index = elseif_index
        else:
            body_stop_index = else_index

        prev = None
        orelse = None
        # If there are else_if statements, they need
        if elseif_index != -1:
            orelse = ModelIf()
            prev = orelse
            for condition in node[&#34;children&#34;][elseif_index:else_index]:
                elseif_expr = self.visit(condition[&#34;children&#34;][2])
                elseif_body = [self.visit(child) for child in condition[&#34;children&#34;][4:]]

                prev.orelse = ModelIf(elseif_expr, elseif_body, None)
                prev = prev.orelse

        if else_index != -1:
            else_body = [
                self.visit(child)
                for child in node[&#34;children&#34;][else_index][&#34;children&#34;][1:]
            ]
            if prev:
                prev.orelse = else_body
            else:
                orelse = else_body

        if isinstance(orelse, ModelIf):
            orelse = orelse.orelse

        return ModelIf(
            expr=self.visit(node[&#34;children&#34;][1]),
            body=[self.visit(child) for child in node[&#34;children&#34;][3:body_stop_index]],
            orelse=orelse,
        )

    def visit_assignment_statement(self, node):
        cast_assignment = Assignment()
        cast_assignment.source_refs = node[&#34;source_refs&#34;]

        assert len(node[&#34;children&#34;]) == 2
        left, right = node[&#34;children&#34;]

        # We need to check if the left side is a multidimensional array,
        # Since tree-sitter incorrectly shows this assignment as a call_expression
        if left[&#34;type&#34;] == &#34;call_expression&#34;:
            return self._visit_set(node)

        cast_assignment.left = self.visit(left)
        cast_assignment.right = self.visit(right)

        return cast_assignment

    def visit_literal(self, node):
        literal_type = node[&#34;type&#34;]
        literal_value = node[&#34;identifier&#34;]

        cast_literal = LiteralValue()
        cast_literal.source_refs = node[&#34;source_refs&#34;]

        if literal_type == &#34;number_literal&#34;:
            # Check if this is a real value, or an Integer
            if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
                cast_literal.value_type = &#34;AbstractFloat&#34;
                cast_literal.source_code_data_type = [
                    &#34;Fortran&#34;,
                    &#34;Fortran95&#34;,
                    &#34;real&#34;,
                ]
            else:
                cast_literal.value_type = &#34;Integer&#34;
                cast_literal.source_code_data_type = [
                    &#34;Fortran&#34;,
                    &#34;Fortran95&#34;,
                    &#34;integer&#34;,
                ]
            cast_literal.value = literal_value

        elif literal_type == &#34;string_literal&#34;:
            cast_literal.value_type = &#34;Character&#34;
            cast_literal.source_code_data_type = [
                &#34;Fortran&#34;,
                &#34;Fortran95&#34;,
                &#34;character&#34;,
            ]
            cast_literal.value = literal_value

        elif literal_type == &#34;boolean_literal&#34;:
            cast_literal.value_type = &#34;Boolean&#34;
            cast_literal.source_code_data_type = [&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;logical&#34;]
            cast_literal.value = literal_value

        elif literal_type == &#34;array_literal&#34;:
            cast_literal.value_type = &#34;List&#34;
            cast_literal.source_code_data_type = [
                &#34;Fortran&#34;,
                &#34;Fortran95&#34;,
                &#34;dimension&#34;,
            ]
            cast_literal.value = None

        return cast_literal

    def visit_identifier(self, node):
        cast_var = Var()
        cast_var.source_refs = node[&#34;source_refs&#34;]

        # By default, this is unknown, but can be updated by other visitors
        if self.variable_context.is_variable(node[&#34;identifier&#34;]):
            cast_var.type = self.variable_context.get_type(node[&#34;identifier&#34;])
        else:
            cast_var.type = &#34;Unknown&#34;

        # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
        # Fortran does have optional arguments introduced in F90, but these do not specify a default
        cast_var.default_value = None

        # This is another case where we need to override the visitor to explicitly visit another node
        cast_var.val = self.visit_name(node)

        return cast_var

    def visit_math_expression(self, node):
        op = node[&#34;control&#34;][0]  # The operator will be the first control character

        cast_op = Operator()
        cast_op.source_refs = node[&#34;source_refs&#34;]

        cast_op.source_language = &#34;Fortran&#34;
        cast_op.interpreter = None
        cast_op.version = None

        cast_op.op = op[&#34;identifier&#34;]

        for child in node[&#34;children&#34;]:
            cast_op.operands = TS2CAST.update_field(cast_op.operands, self.visit(child))

        return cast_op

    def visit_variable_declaration(self, node):
        # Node structure
        # (variable_declaration)
        #   (intrinsic_type)
        #   (type_qualifier)
        #     (qualifier)
        #     (value)
        #   (identifier) ...
        #   (assignment_statement) ...

        # The type will be determined from the child intrensic_type node
        # TODO: Expand this type map and move it somewhere else
        type_map = {
            &#34;integer&#34;: &#34;Integer&#34;,
            &#34;real&#34;: &#34;AbstractFloat&#34;,
            &#34;complex&#34;: None,
            &#34;logical&#34;: &#34;Boolean&#34;,
            &#34;character&#34;: &#34;String&#34;,
        }

        intrinsic_type = type_map[node[&#34;children&#34;][0][&#34;identifier&#34;]]
        variable_intent = &#34;TODO&#34;

        type_qualifiers = self.node_helper.get_children_by_type(node, &#34;type_qualifier&#34;)
        identifiers = self.node_helper.get_children_by_type(node, &#34;identifier&#34;)
        assignment_statements = self.node_helper.get_children_by_type(
            node, &#34;assignment_statement&#34;
        )

        # We then need to determine if we are creating an array (dimension) or a single variable
        for type_qualifier in type_qualifiers:
            qualifier = type_qualifier[&#34;children&#34;][0][&#34;identifier&#34;]
            try:
                value = type_qualifier[&#34;children&#34;][1][&#34;identifier&#34;]
            except IndexError:
                # There are a few cases of qualifiers without values such as parameter. These are not currently being handled
                continue

            if qualifier == &#34;dimension&#34;:
                intrinsic_type = &#34;List&#34;
            elif qualifier == &#34;intent&#34;:
                variable_intent = value

        # You can declare multiple variables of the same type in a single statement, so we need to create a Var node for each instance
        vars = []
        for identifier in identifiers:
            cast_var = self.visit(identifier)
            cast_var.type = intrinsic_type
            self.variable_context.update_type(cast_var.val.name, intrinsic_type)

            vars.append(cast_var)

        for assignment_statement in assignment_statements:
            cast_assignment = self.visit(assignment_statement)
            cast_assignment.left.type = intrinsic_type
            self.variable_context.update_type(
                cast_assignment.left.val.name, intrinsic_type
            )

            vars.append(cast_assignment)

        # If the intent is out, we need to add all these variables to the return values
        # TODO: But what if one branch has a different return value? Are ifs going to be a seperate context
        if variable_intent == &#34;in&#34;:
            for var in vars:
                self.variable_context.remove_return_value(var.val.name)

        return vars

    def visit_extent_specifier(self, node):
        # Node structure
        # (extent_specifier)
        #   (identifier)
        #   (identifier)

        # The extent specifier is the same as a slice, it can have a start, stop, and step
        # We can determine these by looking at the number of control characters in this node.
        # Fortran uses the character &#39;:&#39; to differentiate these values
        cast_call = Call()
        cast_call.source_refs = node[&#34;source_refs&#34;]
        cast_call.func = self.get_gromet_function_node(&#34;slice&#34;)
        cast_call.arguments = [
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
        ]
        argument_pointer = 0

        for child in node[&#34;original_children_order&#34;]:
            if child[&#34;type&#34;] == &#34;:&#34;:
                argument_pointer += 1
            else:
                cast_call.arguments[argument_pointer] = self.visit(child)

        return cast_call

    # NOTE: This function starts with _ because it will never be dispatched to directly. There is not a get node in the tree-sitter parse tree.
    # From context, we will determine when we are accessing an element of a List, and call this function,
    def _visit_get(self, node):
        # Node structure
        # (call_expression)
        #  (identifier)
        #  (argument_list)

        assert len(node[&#34;children&#34;]) == 2
        identifier = node[&#34;children&#34;][0]
        arguments = node[&#34;children&#34;][1][&#34;children&#34;]

        # This is a call to the get Gromet function
        cast_call = Call()
        cast_call.source_refs = node[&#34;source_refs&#34;]

        # We can generate/get the name node for the &#34;get&#34; function by passing the identifier node to the name visitor
        cast_call.func = self.get_gromet_function_node(&#34;get&#34;)

        # First argument to get is the List itself. We can get this by passing the identifier to the identifier visitor
        cast_call.arguments = []
        cast_call.arguments.append(self.visit(identifier))

        # If there are more than one arguments, then this is a multi dimensional array and we need to use an extended slice
        if len(arguments) &gt; 1:
            dimension_list = LiteralValue()
            dimension_list.source_refs = node[&#34;children&#34;][1][&#34;source_refs&#34;]
            dimension_list.value_type = &#34;List&#34;
            dimension_list.value = []
            for argument in arguments:
                dimension_list.value.append(self.visit(argument))

            extslice_call = Call()
            extslice_call.source_refs = node[&#34;source_refs&#34;]
            extslice_call.func = self.get_gromet_function_node(&#34;ext_slice&#34;)
            extslice_call.arguments = []
            extslice_call.arguments.append(dimension_list)

            cast_call.arguments.append(extslice_call)
        else:
            cast_call.arguments.append(self.visit(arguments[0]))

        return cast_call

    def _visit_set(self, node):
        # Node structure
        # (assignment_statement)
        #  (call_expression)
        #  (right side)

        assert (len(node[&#34;children&#34;])) == 2
        left, right = node[&#34;children&#34;]

        # The left side is equivilent to a call gromet &#34;get&#34;, so we will first pass the left side to the get visitor
        # Then we can easily convert this to a &#34;set&#34; call by modifying the fields and then appending the right side to the function arguments
        cast_call = self._visit_get(left)
        cast_call.source_refs = node[&#34;source_refs&#34;]
        cast_call.func = self.get_gromet_function_node(&#34;set&#34;)
        cast_call.arguments.append(self.visit(right))

        return cast_call

    def _visit_passthrough(self, node):
        if len(node[&#34;children&#34;]) == 0:
            return []

        return self.visit(node[&#34;children&#34;][0])

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        node_dict = {&#34;identifier&#34;: func_name, &#34;source_refs&#34;: [], &#34;children&#34;: []}
        cast_name = self.visit_name(node_dict)

        return cast_name

    @staticmethod
    def update_field(field: Any, element: Any) -&gt; List:
        if not field:
            field = []

        if element:
            if isinstance(element, List):
                field.extend(element)
            else:
                field.append(element)

        return field</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.update_field"><code class="name flex">
<span>def <span class="ident">update_field</span></span>(<span>field:Â Any, element:Â Any) â>Â List[~T]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def update_field(field: Any, element: Any) -&gt; List:
    if not field:
        field = []

    if element:
        if isinstance(element, List):
            field.extend(element)
        else:
            field.append(element)

    return field</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.get_gromet_function_node"><code class="name flex">
<span>def <span class="ident">get_gromet_function_node</span></span>(<span>self, func_name:Â str) â>Â <a title="skema.program_analysis.CAST2FN.model.cast.name.Name" href="../CAST2FN/model/cast/name.html#skema.program_analysis.CAST2FN.model.cast.name.Name">Name</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gromet_function_node(self, func_name: str) -&gt; Name:
    node_dict = {&#34;identifier&#34;: func_name, &#34;source_refs&#34;: [], &#34;children&#34;: []}
    cast_name = self.visit_name(node_dict)

    return cast_name</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, root:Â Dict[~KT,Â ~VT])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, root: Dict):
    self.module.source_refs = root[&#34;source_refs&#34;]
    self.module.body = []
    for child in root[&#34;children&#34;]:
        child_cast = self.visit(child)
        if isinstance(child_cast, List):
            self.module.body.extend(child_cast)
        else:
            self.module.body.append(child_cast)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node:Â Dict[~KT,Â ~VT])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node: Dict):
    if node[&#34;type&#34;] == &#34;program&#34;:
        return self.visit_program_statement(node)
    elif node[&#34;type&#34;] in [&#34;subroutine&#34;, &#34;function&#34;]:
        return self.visit_function_def(node)
    elif node[&#34;type&#34;] in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
        return self.visit_function_call(node)
    elif node[&#34;type&#34;] == &#34;use_statement&#34;:
        return self.visit_use_statement(node)
    elif node[&#34;type&#34;] == &#34;variable_declaration&#34;:
        return self.visit_variable_declaration(node)
    elif node[&#34;type&#34;] == &#34;assignment_statement&#34;:
        return self.visit_assignment_statement(node)
    elif node[&#34;type&#34;] == &#34;identifier&#34;:
        return self.visit_identifier(node)
    elif node[&#34;type&#34;] == &#34;name&#34;:
        return self.visit_name(node)
    elif node[&#34;type&#34;] in [&#34;math_expression&#34;, &#34;relational_expression&#34;]:
        return self.visit_math_expression(node)
    elif node[&#34;type&#34;] in [
        &#34;number_literal&#34;,
        &#34;array_literal&#34;,
        &#34;string_literal&#34;,
        &#34;boolean_literal&#34;,
    ]:
        return self.visit_literal(node)
    elif node[&#34;type&#34;] == &#34;keyword_statement&#34;:
        return self.visit_keyword_statement(node)
    elif node[&#34;type&#34;] == &#34;extent_specifier&#34;:
        return self.visit_extent_specifier(node)
    elif node[&#34;type&#34;] == &#34;do_loop_statement&#34;:
        return self.visit_do_loop_statement(node)
    elif node[&#34;type&#34;] == &#34;if_statement&#34;:
        return self.visit_if_statement(node)
    else:
        return self._visit_passthrough(node)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_assignment_statement"><code class="name flex">
<span>def <span class="ident">visit_assignment_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_assignment_statement(self, node):
    cast_assignment = Assignment()
    cast_assignment.source_refs = node[&#34;source_refs&#34;]

    assert len(node[&#34;children&#34;]) == 2
    left, right = node[&#34;children&#34;]

    # We need to check if the left side is a multidimensional array,
    # Since tree-sitter incorrectly shows this assignment as a call_expression
    if left[&#34;type&#34;] == &#34;call_expression&#34;:
        return self._visit_set(node)

    cast_assignment.left = self.visit(left)
    cast_assignment.right = self.visit(right)

    return cast_assignment</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_do_loop_statement"><code class="name flex">
<span>def <span class="ident">visit_do_loop_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_do_loop_statement(self, node):
    # Node structure
    # Do loop
    # (do_loop_statement)
    #   (do) - TODO: Get rid of extraneous nodes like this
    #   (loop_control_expression)
    #     (...) ...
    #   (body) ...
    #
    # Do while
    # (do_loop_statement)
    #   (do)
    #   (while_statement)
    #     (while)
    #     (parenthesized_expression)
    #      (...) ...
    #   (body) ...
    # print(self.variable_context.context)
    assert len(node[&#34;children&#34;]) &gt; 2
    loop_type = node[&#34;children&#34;][1][&#34;type&#34;]

    cast_loop = Loop()
    cast_loop.source_refs = node[&#34;source_refs&#34;]
    cast_loop.pre = []
    cast_loop.post = []
    cast_loop.expr = None
    cast_loop.body = []

    # The body will be the same for both loops, like the function definition, its simply every child node after the first
    # TODO: This may not be the case
    for child in node[&#34;children&#34;][2:]:
        cast_loop.body = self.update_field(cast_loop.body, self.visit(child))

    # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop

    # PRE:
    # TODO: Why is this different from the schema
    # _next(_iter(range(start, stop, step)))
    loop_control_node = node[&#34;children&#34;][1]
    itterator = self.visit(loop_control_node[&#34;children&#34;][0])
    start = self.visit(loop_control_node[&#34;children&#34;][1])
    stop = self.visit(loop_control_node[&#34;children&#34;][2])

    if len(loop_control_node[&#34;children&#34;]) == 3:  # No step value
        step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
    elif len(loop_control_node[&#34;children&#34;]) == 4:
        step = self.visit(loop_control_node[&#34;children&#34;][3])

    range_name_node = self.get_gromet_function_node(&#34;range&#34;)
    iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
    next_name_node = self.get_gromet_function_node(&#34;next&#34;)
    generated_iter_name_node = self.variable_context.generate_iterator()
    stop_condition_name_node = self.variable_context.generate_stop_condition()

    # generated_iter_0 = iter(range(start, stop, step))
    cast_loop.pre.append(
        Assignment(
            left=Var(generated_iter_name_node, &#34;Iterator&#34;),
            right=Call(
                iter_name_node,
                arguments=[Call(range_name_node, arguments=[start, stop, step])],
            ),
        )
    )

    # (i, generated_iter_0, sc_0) = next(generated_iter_0)
    cast_loop.pre.append(
        Assignment(
            left=LiteralValue(
                &#34;Tuple&#34;,
                [
                    itterator,
                    Var(generated_iter_name_node, &#34;Iterator&#34;),
                    Var(stop_condition_name_node, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_name_node,
                arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
            ),
        )
    )

    # EXPR
    cast_loop.expr = Operator(
        op=&#34;!=&#34;,  # TODO: Should this be == or !=
        operands=[
            Var(stop_condition_name_node, &#34;Boolean&#34;),
            LiteralValue(&#34;Boolean&#34;, True),
        ],
    )

    # BODY
    # At this point, the body nodes have already been visited
    # We just need to append the iterator next call
    cast_loop.body.append(
        Assignment(
            left=LiteralValue(
                &#34;Tuple&#34;,
                [
                    itterator,
                    Var(generated_iter_name_node, &#34;Iterator&#34;),
                    Var(stop_condition_name_node, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_name_node,
                arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
            ),
        )
    )

    # POST
    cast_loop.post.append(
        Assignment(
            left=itterator,
            right=Operator(op=&#34;+&#34;, operands=[itterator, step]),
        )
    )

    return cast_loop</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_extent_specifier"><code class="name flex">
<span>def <span class="ident">visit_extent_specifier</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_extent_specifier(self, node):
    # Node structure
    # (extent_specifier)
    #   (identifier)
    #   (identifier)

    # The extent specifier is the same as a slice, it can have a start, stop, and step
    # We can determine these by looking at the number of control characters in this node.
    # Fortran uses the character &#39;:&#39; to differentiate these values
    cast_call = Call()
    cast_call.source_refs = node[&#34;source_refs&#34;]
    cast_call.func = self.get_gromet_function_node(&#34;slice&#34;)
    cast_call.arguments = [
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
    ]
    argument_pointer = 0

    for child in node[&#34;original_children_order&#34;]:
        if child[&#34;type&#34;] == &#34;:&#34;:
            argument_pointer += 1
        else:
            cast_call.arguments[argument_pointer] = self.visit(child)

    return cast_call</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_function_call"><code class="name flex">
<span>def <span class="ident">visit_function_call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_call(self, node):
    # Pull relevent nodes
    if node[&#34;type&#34;] == &#34;subroutine_call&#34;:
        function_node = node[&#34;children&#34;][1]
        arguments_node = node[&#34;children&#34;][2]
    elif node[&#34;type&#34;] == &#34;call_expression&#34;:
        function_node = node[&#34;children&#34;][0]
        arguments_node = node[&#34;children&#34;][1]

    function_identifier = function_node[&#34;identifier&#34;]

    # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
    # We will need to check if this is truly a function call or a subscript
    if self.variable_context.is_variable(function_identifier):
        if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
            return self._visit_get(
                node
            )  # This overrides the visitor and forces us to visit another

    cast_call = Call()
    cast_call.source_refs = node[&#34;source_refs&#34;]

    # TODO: What should get a name node? Instrincit functions? Imported functions?
    # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
    if self.variable_context.is_variable(function_identifier):
        cast_call.func = self.variable_context.get_node(function_identifier)
    else:
        cast_call.func = Name(function_identifier, -1)

    # Add arguments to arguments list
    for child in arguments_node[&#34;children&#34;]:
        cast_call.arguments = TS2CAST.update_field(
            cast_call.arguments, self.visit(child)
        )

    return cast_call</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_function_def"><code class="name flex">
<span>def <span class="ident">visit_function_def</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_def(self, node):
    # Node structure
    # (subroutine)
    #   (subroutine_statement)
    #     (subroutine)
    #     (name)
    #     (parameters) - Optional
    #   (body_node) ...
    # (function)
    #   (function_statement)
    #     (function)
    #     (intrinsic_type) - Optional
    #     (name)
    #     (parameters) - Optional
    #     (function_result) - Optional
    #       (identifier)
    #  (body_node) ...

    # Create a new variable context
    self.variable_context.push_context()

    # Top level statement node
    statement_node = node[&#34;children&#34;][0]
    name_node = self.node_helper.get_first_child_by_type(statement_node, &#34;name&#34;)
    self.visit(name_node)  # Visit the name node

    # If this is a function, check for return type and return value
    intrinsic_type = None
    return_value = None
    if node[&#34;type&#34;] == &#34;function&#34;:
        if intrinsic_type_node := self.node_helper.get_first_child_by_type(
            statement_node, &#34;intrinsic_type&#34;
        ):
            intrinsic_type = intrinsic_type_node[&#34;identifier&#34;]
            self.variable_context.add_variable(
                name_node[&#34;identifier&#34;], intrinsic_type, None
            )
        if return_value_node := self.node_helper.get_first_child_by_type(
            statement_node, &#34;function_result&#34;
        ):
            return_value = self.visit(return_value_node[&#34;children&#34;][1])
            self.variable_context.add_return_value(return_value.val.name)
        else:
            # #TODO: What happens if function doesn&#39;t return anything?
            # If this is a function, and there is no explicit results variable, then we will assume the return value is the name of the function
            self.variable_context.add_return_value(name_node[&#34;identifier&#34;])

    # If funciton has both, then we also need to update the type of the return value in the variable context
    # It does not explicity have to be declared
    if return_value and intrinsic_type:
        self.variable_context.update_type(return_value.val.name, intrinsic_type)

    cast_func = FunctionDef()
    cast_func.source_refs = node[&#34;source_refs&#34;]
    cast_func.func_args = []
    cast_func.body = []
    cast_func.name = self.visit(name_node)

    # Generating the function arguments by walking the parameters node
    parameters_node = self.node_helper.get_first_child_by_type(
        statement_node, &#34;parameters&#34;
    )
    if parameters_node:
        for child in parameters_node[&#34;children&#34;]:
            # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
            # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
            self.variable_context.add_return_value(child[&#34;identifier&#34;])

            cast_func.func_args = TS2CAST.update_field(
                cast_func.func_args, self.visit(child)
            )

    # The first child of function will be the function statement, the rest will be body nodes
    for child in node[&#34;children&#34;][1:]:
        cast_func.body = TS2CAST.update_field(cast_func.body, self.visit(child))

    # After creating the body, we can go back and update the var nodes we created for the arguments
    # We do this by looking for intent,in nodes
    for i, arg in enumerate(cast_func.func_args):
        cast_func.func_args[i].type = self.variable_context.get_type(arg.val.name)

    # TODO:
    # This logic can be made cleaner
    # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
    # If there is not, then we will create a dummy one
    return_found = False
    for child in cast_func.body:
        if isinstance(child, ModelReturn):
            return_found = True
    if not return_found:
        cast_func.body.append(self.visit_keyword_statement(node))

    # Pop variable context off of stack before leaving this scope
    self.variable_context.pop_context()

    return cast_func</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_identifier"><code class="name flex">
<span>def <span class="ident">visit_identifier</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_identifier(self, node):
    cast_var = Var()
    cast_var.source_refs = node[&#34;source_refs&#34;]

    # By default, this is unknown, but can be updated by other visitors
    if self.variable_context.is_variable(node[&#34;identifier&#34;]):
        cast_var.type = self.variable_context.get_type(node[&#34;identifier&#34;])
    else:
        cast_var.type = &#34;Unknown&#34;

    # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
    # Fortran does have optional arguments introduced in F90, but these do not specify a default
    cast_var.default_value = None

    # This is another case where we need to override the visitor to explicitly visit another node
    cast_var.val = self.visit_name(node)

    return cast_var</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_if_statement"><code class="name flex">
<span>def <span class="ident">visit_if_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_if_statement(self, node):
    # (if_statement)
    #  (if)
    #  (parenthesised_expression)
    #  (then)
    #  (body_nodes) ...
    #  (elseif_clauses) ..
    #  (else_clause)
    #  (end_if_statement)

    child_types = [child[&#34;type&#34;] for child in node[&#34;children&#34;]]

    try:
        elseif_index = child_types.index(&#34;elseif_clause&#34;)
    except ValueError:
        elseif_index = -1

    try:
        else_index = child_types.index(&#34;else_clause&#34;)
    except ValueError:
        else_index = -1

    if elseif_index != -1:
        body_stop_index = elseif_index
    else:
        body_stop_index = else_index

    prev = None
    orelse = None
    # If there are else_if statements, they need
    if elseif_index != -1:
        orelse = ModelIf()
        prev = orelse
        for condition in node[&#34;children&#34;][elseif_index:else_index]:
            elseif_expr = self.visit(condition[&#34;children&#34;][2])
            elseif_body = [self.visit(child) for child in condition[&#34;children&#34;][4:]]

            prev.orelse = ModelIf(elseif_expr, elseif_body, None)
            prev = prev.orelse

    if else_index != -1:
        else_body = [
            self.visit(child)
            for child in node[&#34;children&#34;][else_index][&#34;children&#34;][1:]
        ]
        if prev:
            prev.orelse = else_body
        else:
            orelse = else_body

    if isinstance(orelse, ModelIf):
        orelse = orelse.orelse

    return ModelIf(
        expr=self.visit(node[&#34;children&#34;][1]),
        body=[self.visit(child) for child in node[&#34;children&#34;][3:body_stop_index]],
        orelse=orelse,
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_keyword_statement"><code class="name flex">
<span>def <span class="ident">visit_keyword_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_keyword_statement(self, node):
    # Currently, the only keyword_identifier produced by tree-sitter is Return
    # However, there may be other instances
    cast_return = ModelReturn(source_refs=node[&#34;source_refs&#34;])

    # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
    # We keep track of values that need to be returned in the variable context
    return_values = self.variable_context.context_return_values[
        -1
    ]  # TODO: Make function for this

    if len(return_values) == 1:
        cast_return.value = self.variable_context.get_node(return_values[0])
    elif len(return_values) &gt; 1:
        cast_tuple = LiteralValue(&#34;Tuple&#34;, [])

        for return_value in return_values:
            cast_var = Var()
            cast_var.val = self.variable_context.get_node(return_value)
            cast_var.type = self.variable_context.get_type(return_value)
            cast_tuple.value.append(cast_var)
        cast_return.value = cast_tuple
    else:
        cast_return.value = LiteralValue(None, None)

    return cast_return</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_literal"><code class="name flex">
<span>def <span class="ident">visit_literal</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_literal(self, node):
    literal_type = node[&#34;type&#34;]
    literal_value = node[&#34;identifier&#34;]

    cast_literal = LiteralValue()
    cast_literal.source_refs = node[&#34;source_refs&#34;]

    if literal_type == &#34;number_literal&#34;:
        # Check if this is a real value, or an Integer
        if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
            cast_literal.value_type = &#34;AbstractFloat&#34;
            cast_literal.source_code_data_type = [
                &#34;Fortran&#34;,
                &#34;Fortran95&#34;,
                &#34;real&#34;,
            ]
        else:
            cast_literal.value_type = &#34;Integer&#34;
            cast_literal.source_code_data_type = [
                &#34;Fortran&#34;,
                &#34;Fortran95&#34;,
                &#34;integer&#34;,
            ]
        cast_literal.value = literal_value

    elif literal_type == &#34;string_literal&#34;:
        cast_literal.value_type = &#34;Character&#34;
        cast_literal.source_code_data_type = [
            &#34;Fortran&#34;,
            &#34;Fortran95&#34;,
            &#34;character&#34;,
        ]
        cast_literal.value = literal_value

    elif literal_type == &#34;boolean_literal&#34;:
        cast_literal.value_type = &#34;Boolean&#34;
        cast_literal.source_code_data_type = [&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;logical&#34;]
        cast_literal.value = literal_value

    elif literal_type == &#34;array_literal&#34;:
        cast_literal.value_type = &#34;List&#34;
        cast_literal.source_code_data_type = [
            &#34;Fortran&#34;,
            &#34;Fortran95&#34;,
            &#34;dimension&#34;,
        ]
        cast_literal.value = None

    return cast_literal</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_math_expression"><code class="name flex">
<span>def <span class="ident">visit_math_expression</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_math_expression(self, node):
    op = node[&#34;control&#34;][0]  # The operator will be the first control character

    cast_op = Operator()
    cast_op.source_refs = node[&#34;source_refs&#34;]

    cast_op.source_language = &#34;Fortran&#34;
    cast_op.interpreter = None
    cast_op.version = None

    cast_op.op = op[&#34;identifier&#34;]

    for child in node[&#34;children&#34;]:
        cast_op.operands = TS2CAST.update_field(cast_op.operands, self.visit(child))

    return cast_op</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_name"><code class="name flex">
<span>def <span class="ident">visit_name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_name(self, node):
    # Node structure
    # (name)
    assert len(node[&#34;children&#34;]) == 0

    # First, we will check if this name is already defined, and if it is
    if self.variable_context.is_variable(node[&#34;identifier&#34;]):
        return self.variable_context.get_node(node[&#34;identifier&#34;])

    return self.variable_context.add_variable(
        node[&#34;identifier&#34;], &#34;Unknown&#34;, node[&#34;source_refs&#34;]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_program_statement"><code class="name flex">
<span>def <span class="ident">visit_program_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_program_statement(self, node):
    program_body = []
    for child in node[&#34;children&#34;][1:]:
        child_cast = self.visit(child)
        if isinstance(child_cast, List):
            program_body.extend(child_cast)
        else:
            program_body.append(child_cast)
    return program_body</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_use_statement"><code class="name flex">
<span>def <span class="ident">visit_use_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_use_statement(self, node):
    ## Pull relevent child nodes
    module_name_node = node[&#34;children&#34;][0]
    included_items_nodes = self.node_helper.get_children_by_type(
        node,
        &#34;included_items&#34;,
    )

    import_all = len(included_items_nodes) == 0
    import_alias = None  # TODO: Look into local-name and use-name fields

    # We need to check if this import is a full import of a module, i.e. use module
    # Or a partial import i.e. use module,only: sub1, sub2
    if import_all:
        cast_import = ModelImport()
        cast_import.source_refs = node[&#34;source_refs&#34;]
        cast_import.name = module_name_node[&#34;identifier&#34;]
        cast_import.alias = import_alias
        cast_import.all = import_all
        cast_import.symbol = None

        return cast_import
    else:
        imports = []
        for child in included_items_nodes[0][&#34;children&#34;]:
            cast_import = ModelImport()
            cast_import.source_refs = child[&#34;source_refs&#34;]
            cast_import.name = module_name_node[&#34;identifier&#34;]
            cast_import.alias = import_alias
            cast_import.all = import_all
            cast_import.symbol = child[&#34;identifier&#34;]

            # Add the symbol to the variable context
            self.variable_context.add_variable(
                cast_import.symbol, &#34;function&#34;, child[&#34;source_refs&#34;]
            )

            imports.append(cast_import)
        return imports</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_variable_declaration"><code class="name flex">
<span>def <span class="ident">visit_variable_declaration</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_variable_declaration(self, node):
    # Node structure
    # (variable_declaration)
    #   (intrinsic_type)
    #   (type_qualifier)
    #     (qualifier)
    #     (value)
    #   (identifier) ...
    #   (assignment_statement) ...

    # The type will be determined from the child intrensic_type node
    # TODO: Expand this type map and move it somewhere else
    type_map = {
        &#34;integer&#34;: &#34;Integer&#34;,
        &#34;real&#34;: &#34;AbstractFloat&#34;,
        &#34;complex&#34;: None,
        &#34;logical&#34;: &#34;Boolean&#34;,
        &#34;character&#34;: &#34;String&#34;,
    }

    intrinsic_type = type_map[node[&#34;children&#34;][0][&#34;identifier&#34;]]
    variable_intent = &#34;TODO&#34;

    type_qualifiers = self.node_helper.get_children_by_type(node, &#34;type_qualifier&#34;)
    identifiers = self.node_helper.get_children_by_type(node, &#34;identifier&#34;)
    assignment_statements = self.node_helper.get_children_by_type(
        node, &#34;assignment_statement&#34;
    )

    # We then need to determine if we are creating an array (dimension) or a single variable
    for type_qualifier in type_qualifiers:
        qualifier = type_qualifier[&#34;children&#34;][0][&#34;identifier&#34;]
        try:
            value = type_qualifier[&#34;children&#34;][1][&#34;identifier&#34;]
        except IndexError:
            # There are a few cases of qualifiers without values such as parameter. These are not currently being handled
            continue

        if qualifier == &#34;dimension&#34;:
            intrinsic_type = &#34;List&#34;
        elif qualifier == &#34;intent&#34;:
            variable_intent = value

    # You can declare multiple variables of the same type in a single statement, so we need to create a Var node for each instance
    vars = []
    for identifier in identifiers:
        cast_var = self.visit(identifier)
        cast_var.type = intrinsic_type
        self.variable_context.update_type(cast_var.val.name, intrinsic_type)

        vars.append(cast_var)

    for assignment_statement in assignment_statements:
        cast_assignment = self.visit(assignment_statement)
        cast_assignment.left.type = intrinsic_type
        self.variable_context.update_type(
            cast_assignment.left.val.name, intrinsic_type
        )

        vars.append(cast_assignment)

    # If the intent is out, we need to add all these variables to the return values
    # TODO: But what if one branch has a different return value? Are ifs going to be a seperate context
    if variable_intent == &#34;in&#34;:
        for var in vars:
            self.variable_context.remove_return_value(var.val.name)

    return vars</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis.TS2CAST" href="index.html">skema.program_analysis.TS2CAST</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST">TS2CAST</a></code></h4>
<ul class="">
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.get_gromet_function_node" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.get_gromet_function_node">get_gromet_function_node</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.run" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.run">run</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.update_field" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.update_field">update_field</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit">visit</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_assignment_statement" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_assignment_statement">visit_assignment_statement</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_do_loop_statement" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_do_loop_statement">visit_do_loop_statement</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_extent_specifier" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_extent_specifier">visit_extent_specifier</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_function_call" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_function_call">visit_function_call</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_function_def" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_function_def">visit_function_def</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_identifier" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_identifier">visit_identifier</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_if_statement" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_if_statement">visit_if_statement</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_keyword_statement" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_keyword_statement">visit_keyword_statement</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_literal" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_literal">visit_literal</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_math_expression" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_math_expression">visit_math_expression</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_name" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_name">visit_name</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_program_statement" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_program_statement">visit_program_statement</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_use_statement" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_use_statement">visit_use_statement</a></code></li>
<li><code><a title="skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_variable_declaration" href="#skema.program_analysis.TS2CAST.ts2cast.TS2CAST.visit_variable_declaration">visit_variable_declaration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>