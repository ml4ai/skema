<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.CAST2FN.ann_cast.variable_version_pass API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.CAST2FN.ann_cast.variable_version_pass</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import typing
from functools import singledispatchmethod

from skema.model_assembly.metadata import VariableCreationReason, LambdaType
from skema.model_assembly.networks import load_lambda_function
from skema.program_analysis.CAST2FN.ann_cast.ann_cast_helpers import (
    ELSEBODY,
    IFBODY,
    IFEXPR,
    LOOP_VAR_UPDATED_VERSION,
    LOOPPRE,
    LOOPBODY,
    LOOPEXPR,
    LOOPPOST,
    VAR_EXIT_VERSION,
    VAR_INIT_VERSION,
    GrfnAssignment,
    add_metadata_from_name_node,
    add_metadata_to_grfn_var,
    build_fullid,
    call_argument_name,
    call_container_name,
    call_param_name,
    call_ret_val_name,
    con_scope_to_str,
    create_grfn_literal_node,
    create_grfn_var,
    create_lambda_node_metadata,
    func_def_argument_name,
    func_def_ret_val_name,
    generate_from_source_metadata,
    is_func_def_main,
    specialized_global_name,
)
from skema.program_analysis.CAST2FN.ann_cast.annotated_cast import *
from skema.program_analysis.CAST2FN.model.cast import (
    ScalarType,
    StructureType,
    ValueConstructor,
)


class VariableVersionPass:
    def __init__(self, pipeline_state: PipelineState):
        self.pipeline_state = pipeline_state
        self.nodes = self.pipeline_state.nodes

        # dict mapping container scopes strs to dicts which
        # map Name id to highest version in that container scope
        self.con_scope_to_highest_var_vers = {}

        for node in self.pipeline_state.nodes:
            # when visitor starts, assign_lhs is False
            self.visit(node, False)

    def init_highest_var_vers_dict(self, con_scopestr, var_ids):
        &#34;&#34;&#34;
        Initialize highest var version dict for scope `con_scopestr`
        If the scope is the module, then use a defaultdict starting at zero
        otherwise, create a dictionary mapping each of the ids to zero
        &#34;&#34;&#34;
        self.con_scope_to_highest_var_vers[con_scopestr] = {}
        for id in var_ids:
            self.con_scope_to_highest_var_vers[con_scopestr][id] = 0
        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(
                f&#34;initialized highest_vars_vers_dict {self.con_scope_to_highest_var_vers[con_scopestr]}&#34;
            )

    def get_highest_ver_in_con_scope(self, con_scopestr, id):
        &#34;&#34;&#34;
        Grab the current version of `id` in scope for `con_scopestr`
        Should only be called after `con_scopestr` is in the `self.con_scope_to_highest_var_vers`
        &#34;&#34;&#34;
        return self.con_scope_to_highest_var_vers[con_scopestr][id]

    def is_var_in_con_scope(self, con_scopestr: str, id: int):
        return id in self.con_scope_to_highest_var_vers[con_scopestr]

    def incr_version_in_con_scope(
        self, con_scopestr: str, id: int, var_name: str
    ):
        &#34;&#34;&#34;
        Grab the next version of `id` in scope for `con_scopestr`
        Should only be called after `con_scopestr` is in the `self.con_scope_to_highest_var_vers`

        Also creates a GrFN variable for the newly added version
        &#34;&#34;&#34;
        # NOTE: we should have added id to con_scope_to_highest_var_vers when we call
        # init_highest_var_vers_dict
        # if this does not happen, some logic has failed
        assert id in self.con_scope_to_highest_var_vers[con_scopestr]
        self.con_scope_to_highest_var_vers[con_scopestr][id] += 1
        version = self.con_scope_to_highest_var_vers[con_scopestr][id]
        grfn_var = create_grfn_var(var_name, id, version, con_scopestr)
        fullid = build_fullid(var_name, id, version, con_scopestr)
        self.pipeline_state.store_grfn_var(fullid, grfn_var)

    def incr_vars_in_con_scope(self, scopestr, vars):
        &#34;&#34;&#34;
        This will increment all versions of variables in `scopestr` that are
        in the dict `vars` which contains variable ids mapped to AnnCastName nodes
        &#34;&#34;&#34;
        for var_id, var_name in vars.items():
            self.incr_version_in_con_scope(scopestr, var_id, var_name)

    def add_default_bot_interface_metadata(self, interface_vars):
        &#34;&#34;&#34;
        Adds a bot interface metadata to interface_vars
        &#34;&#34;&#34;
        for fullid in interface_vars.values():
            grfn_var = self.pipeline_state.get_grfn_var(fullid)
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.BOT_IFACE_INTRO
            )
            add_metadata_to_grfn_var(
                grfn_var, from_source_mdata=from_source_mdata
            )

    def fix_for_python_gcc_declaration_distinction(
        self, con_scopestr, id, var_name
    ):
        &#34;&#34;&#34;
        This function adds a dummy GrfnAssignment to `None` for variable with id `id`
        in the container for con_scopestr

        The motivation for this is the difference between how the gcc and Python handle
        variable declaration.

        For gcc, all variable declaration are placed at the top
        of the enclosing FunctionDef.  Currently, we rely on this for If and Loop container
        top interfaces.

        The Python AST follows Python semantics, and variables are introduced inline dynamically.
        This leads to many challenges creating interfaces e.g.

        ```python
        def func():
            x = 5
            if x == 5:
                z = 3
        ```
        In this code example, what happens to z along the else branch?  GrFN If containers always make a
        selection between two values, but this does not align with dynamic/conditional variable creation in Python,
        as in the above code example.
        &#34;&#34;&#34;
        version = self.con_scope_to_highest_var_vers[con_scopestr][id]
        # this function should only be called in cases where we need to implement a dummy assignment
        # which creates a version 1 variable
        assert version == VAR_INIT_VERSION
        # increment the version, and create an GrFN variable for the incremented version
        self.incr_version_in_con_scope(con_scopestr, id, var_name)
        new_version = self.con_scope_to_highest_var_vers[con_scopestr][id]
        new_fullid = build_fullid(var_name, id, new_version, con_scopestr)
        grfn_var = self.pipeline_state.get_grfn_var(new_fullid)
        from_source_mdata = generate_from_source_metadata(
            False, VariableCreationReason.DUMMY_ASSIGN
        )
        add_metadata_to_grfn_var(grfn_var, from_source_mdata)

        # create a literal GrFN assignment for this dummy assignment
        assign_metadata = create_lambda_node_metadata(source_refs=[])
        literal_node = create_grfn_literal_node(assign_metadata)
        lambda_expr = &#34;lambda: None&#34;
        literal_node.func_str = lambda_expr
        literal_node.function = load_lambda_function(literal_node.func_str)
        dummy_assignment = GrfnAssignment(
            literal_node, LambdaType.LITERAL, lambda_expr=lambda_expr
        )
        dummy_assignment.outputs[new_fullid] = grfn_var.uid

        # add dummy assignment to function def node
        assert self.pipeline_state.is_con_scopestr_func_def(con_scopestr)
        func_def_node = self.pipeline_state.func_def_node_from_scopestr(
            con_scopestr
        )

        func_def_node.dummy_grfn_assignments.append(dummy_assignment)

    def populate_interface(self, con_scopestr, vars, interface):
        &#34;&#34;&#34;
        Parameters:
          - `con_scopestr`: a cached container scope
          - `vars`: a dict mapping numerical ids to variable names
          - `interface`: a dict mapping numerical variable ids to fullids
                         (e.g. the top or bottom interface of a container node)

        For each variable from `vars`, put the highest version of that variable
        from container `con_scopestr` into `interface`
        &#34;&#34;&#34;
        # add vars to interface
        for id, var_name in vars.items():
            highest_ver = self.get_highest_ver_in_con_scope(con_scopestr, id)
            # if con_scopestr is a FunctionDef container, and highest_ver is VAR_INIT_VERSION
            # we call fix_for_python_gcc_declaration_distinction
            # this creates a dummy assignment to the variable in the FunctionDef container
            # most likely, this is not the ideal long term solution
            scopestr_is_func = self.pipeline_state.is_con_scopestr_func_def(
                con_scopestr
            )
            local_var = (
                scopestr_is_func
                and self.pipeline_state.is_var_local_to_func(con_scopestr, id)
            )
            if local_var and highest_ver == VAR_INIT_VERSION:
                self.fix_for_python_gcc_declaration_distinction(
                    con_scopestr, id, var_name
                )
                # update highest ver after the dummy assignment
                highest_ver = self.get_highest_ver_in_con_scope(
                    con_scopestr, id
                )
            fullid = build_fullid(var_name, id, highest_ver, con_scopestr)
            interface[id] = fullid

    def populate_loop_interfaces(self, node: AnnCastLoop):
        # populate interfaces and increment versions in previous scope of modified variables
        prev_scopestr = con_scope_to_str(node.con_scope[:-1])
        # populate top interface initial
        # these are all used variables
        node.top_interface_vars = node.used_vars
        self.populate_interface(
            prev_scopestr, node.top_interface_vars, node.top_interface_initial
        )
        # increment versions of modified vars
        self.incr_vars_in_con_scope(prev_scopestr, node.modified_vars)
        # populate bot interface out
        node.bot_interface_vars = node.modified_vars
        self.populate_interface(
            prev_scopestr, node.bot_interface_vars, node.bot_interface_out
        )
        self.add_default_bot_interface_metadata(node.bot_interface_out)

        # populate &#34;inside&#34; of interfaces
        con_scopestr = con_scope_to_str(node.con_scope)
        # populate top interface updated
        # these are all modified variables
        node.top_interface_updated_vars = node.modified_vars
        for id, var_name in node.top_interface_updated_vars.items():
            version = LOOP_VAR_UPDATED_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.top_interface_updated[id] = fullid
        # populate top interface out
        # the top interface chooses between initial and updated versions;
        # by convention the produced version is `VAR_INIT_VERSION`
        # which is consistent with other containers
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.top_interface_out[id] = fullid
        # populate bot interface in
        # the bot interface takes `VAR_EXIT_VERSION` modified variables
        # During GrFN Variable Creation, these versions will be aliased to
        # the highest version occuring in the loop expr
        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.bot_interface_in[id] = fullid

    def populate_model_if_interfaces(self, node: AnnCastModelIf):
        # populate interfaces and increment versions in previous scope of modified variables
        prev_scopestr = con_scope_to_str(node.con_scope[:-1])
        # populate top interface in
        node.top_interface_vars = node.used_vars
        self.populate_interface(
            prev_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # increment versions
        self.incr_vars_in_con_scope(prev_scopestr, node.modified_vars)
        # populate bot interface out
        node.bot_interface_vars = node.modified_vars
        self.populate_interface(
            prev_scopestr, node.bot_interface_vars, node.bot_interface_out
        )
        self.add_default_bot_interface_metadata(node.bot_interface_out)

        # populate &#34;inside&#34; of interfaces
        con_scopestr = con_scope_to_str(node.con_scope)
        # populate top interface out
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # and these are propagated to if expr, if body, and else body
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.top_interface_out[id] = fullid
        # populate bot interface in
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        # these versions are produced by the Decision node
        # and they are created during GrfnVariableCreationPass
        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.bot_interface_in[id] = fullid

    def func_def_top_interface_args(self, node: AnnCastFunctionDef):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`
        &#34;&#34;&#34;
        # function container is used to scope parameters
        param_con_scopestr = con_scope_to_str(node.con_scope)
        # enclosing container is used to scope arguments
        enclosing_con_scope = node.con_scope[:-1]
        arg_con_scopestr = con_scope_to_str(enclosing_con_scope)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        for i, param in enumerate(node.func_args):
            # argument name and scope str
            arg_name = func_def_argument_name(node, i)

            # parameter name and scopestr
            assert isinstance(param, AnnCastVar)
            param_name = param.val.name

            # argument and parameter share id, and start with initial version
            id = param.val.id
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            # store metadata in paramter GrFN Var
            add_metadata_from_name_node(param_grfn_var, param.val)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;After func_def_top_iface_args():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def func_def_ret_val_creation(self, node: AnnCastFunctionDef):
        &#34;&#34;&#34;
        Creates two GrFN variables for the FunctionDef&#39;s return value.
        One is in the interior of the container and links
        to the bot interface in.  The other is outside the container and
        links to the bot interface out.
        &#34;&#34;&#34;
        # Create new GrFN for return value for bot interface in and bot interface out
        var_name = func_def_ret_val_name(node)
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # interior container scope
        func_scopestr = con_scope_to_str(node.con_scope)

        in_ret_val = create_grfn_var(var_name, id, version, func_scopestr)
        in_fullid = build_fullid(var_name, id, version, func_scopestr)
        self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_RET_VAL
        )
        add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

        # exterior container scope
        enclosing_con = node.con_scope[:-1]
        enclosing_scopestr = con_scope_to_str(enclosing_con)
        out_ret_val = create_grfn_var(
            var_name, id, version, enclosing_scopestr
        )
        out_fullid = build_fullid(var_name, id, version, enclosing_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
        # create From Source metadata for the GrFN var
        add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

        # store created fullid and grfn_id in node&#39;s ret_val
        node.out_ret_val[id] = out_fullid
        node.in_ret_val[id] = in_fullid
        # link ret values on bot interface
        node.bot_interface_in[id] = in_fullid
        node.bot_interface_out[id] = out_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;\tAfter func_def_ret_val_creation():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def add_globals_to_main_func_def_interfaces(
        self, node: AnnCastFunctionDef
    ):
        &#34;&#34;&#34;
        Populates top and bot interface of main FunctionDef with global variables
          - Adds incoming global variable version to top_interface_in
          - Increments modified globals versions in enclosing scope
          - Adds incremented version to bot_interface_out
          - Creates VAR_INIT_VERSION global variables and adds to top_interface_out
          - Add `body_highest_var_vers` global variables to bot_interface_in
        &#34;&#34;&#34;
        # in the enclosing scope, increment all versions of global variables
        # that are modified by main
        enclosing_con_scope = node.con_scope[:-1]
        enclosing_scopestr = con_scope_to_str(enclosing_con_scope)

        # add globals to exterior interfaces
        # add global variables to top_interface_in these are all used globals
        node.top_interface_vars = node.used_globals
        self.populate_interface(
            enclosing_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # the bot interface globals are all modified globals
        node.bot_interface_vars = node.modified_globals
        # increment versions of all modified global variables
        self.incr_vars_in_con_scope(
            enclosing_scopestr, node.bot_interface_vars
        )
        # add modified globals to bot interface out
        self.populate_interface(
            enclosing_scopestr, node.bot_interface_vars, node.bot_interface_out
        )

        # add globals to interior interfaces
        # interior container scope
        func_scopestr = con_scope_to_str(node.con_scope)
        # create globals for top_interface_out and bot interface in
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            init_fullid = build_fullid(var_name, id, version, func_scopestr)
            init_global = create_grfn_var(var_name, id, version, func_scopestr)
            self.pipeline_state.store_grfn_var(init_fullid, init_global)
            node.top_interface_out[id] = init_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(init_global, from_source_mdata)

        # we do not create the GrFN VariableNode for the highest version global
        # here, since it is done while visitng Assignment node during GrfnVarCreation pass
        for id, var_name in node.bot_interface_vars.items():
            version = node.body_highest_var_vers[id]
            exit_fullid = build_fullid(var_name, id, version, func_scopestr)
            node.bot_interface_in[id] = exit_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;\tAfter add_globals_to_main_func_def_interfaces():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def add_globals_to_non_main_func_def_interfaces(
        self, node: AnnCastFunctionDef
    ):
        &#34;&#34;&#34;
        Populates top and bot interface of FunctionDef with global variables
        For each global, we make an addtional global whose name is specialized to
        this function.  This is to separate the globals that &#34;main&#34; uses
        from the globals that are used in other FunctionDef&#39;s because of main&#39;s
        special role.
          - Creates VAR_INIT_VERSION version for each specialized global and
            Links these specialized globals through the `top_interface_in` and `top_interface_out`
          - Creates VAR_EXIT_VERSION version for each specialized global and
            Links these specialized globals through the `bot_interface_in` and `bot_interface_out`
        &#34;&#34;&#34;
        enclosing_con_scope = node.con_scope[:-1]
        enclosing_scopestr = con_scope_to_str(enclosing_con_scope)
        # interior container scope
        func_scopestr = con_scope_to_str(node.con_scope)

        # add global variables to top_interface_in
        # these are all used globals
        node.top_interface_vars = node.used_globals
        # the bot interface globals are all modified globals
        node.bot_interface_vars = node.modified_globals

        # we create specialized globals for this function def, in the enclosing scope.
        # this is to accomodate interfaces, since they expect the same id
        # on either side
        # this is similar to how we handle arguments from enclosing scope linking to
        # parameters in the interior of a container

        # create specialized globals for top interface
        # by convention the top interface produces version VAR_INIT_VERSION variables
        version = VAR_INIT_VERSION
        for id, var_name in node.top_interface_vars.items():
            # exterior specialized top global
            specialized_name = specialized_global_name(node, var_name)
            in_fullid = build_fullid(
                specialized_name, id, version, enclosing_scopestr
            )
            in_global = create_grfn_var(
                specialized_name, id, version, enclosing_scopestr
            )
            self.pipeline_state.store_grfn_var(in_fullid, in_global)
            node.top_interface_in[id] = in_fullid
            # create From Source metadata for the GrFN var
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.DUP_GLOBAL
            )
            add_metadata_to_grfn_var(in_global, from_source_mdata)
            # interior top global
            out_fullid = build_fullid(var_name, id, version, func_scopestr)
            out_global = create_grfn_var(var_name, id, version, func_scopestr)
            self.pipeline_state.store_grfn_var(out_fullid, out_global)
            node.top_interface_out[id] = out_fullid
            # create From Source metadata for the GrFN var
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(in_global, from_source_mdata)

        # create specialized globals for bot interface
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.bot_interface_vars.items():
            # interior bot global
            # we do not create the GrFN VariableNode for the highest version global
            # here, since it is done while visitng Assignment node during GrfnVarCreation pass
            version = node.body_highest_var_vers[id]
            in_fullid = build_fullid(var_name, id, version, func_scopestr)
            node.bot_interface_in[id] = in_fullid
            # exterior specialized bot global
            version = VAR_EXIT_VERSION
            specialized_name = specialized_global_name(node, var_name)
            out_fullid = build_fullid(
                specialized_name, id, version, enclosing_scopestr
            )
            out_global = create_grfn_var(
                specialized_name, id, version, enclosing_scopestr
            )
            self.pipeline_state.store_grfn_var(out_fullid, out_global)
            node.bot_interface_out[id] = out_fullid
            # create From Source metadata for the GrFN var
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.DUP_GLOBAL
            )
            add_metadata_to_grfn_var(out_global, from_source_mdata)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;\tAfter add_globals_to_non_main_func_def_interfaces():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)
            print(f&#34;\ttop_interface_vars = {node.top_interface_vars}&#34;)
            print(f&#34;\tbot_interface_in = {node.bot_interface_in}&#34;)
            print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)
            print(f&#34;\tbot_interface_vars = {node.bot_interface_vars}&#34;)

    def call_top_interface_args_with_func_def(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`

        During GrfnAssignmentPass,
        for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
        &#34;&#34;&#34;
        # call container is used to scope parameters
        call_con_name = call_container_name(node)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        for i, n in enumerate(node.arguments):
            # parameter name and scopestr
            func_def = self.pipeline_state.func_def_node_from_id(node.func.id)
            if i &lt; len(func_def.func_args):  # NOTE: M7 Placeholder
                # argument name and scope str
                arg_name = call_argument_name(node, i)
                arg_con_scopestr = con_scope_to_str(node.func.con_scope)

                param = func_def.func_args[i]
                assert isinstance(param, AnnCastVar)
                param_name = param.val.name
                param_con_scopestr = con_scope_to_str(
                    node.func.con_scope + [call_con_name]
                )

                # argument and parameter share id, and start with initial version
                id = self.pipeline_state.next_collapsed_id()
                version = VAR_INIT_VERSION

                # build and store GrFN variables for argument and parameter
                arg_grfn_var = create_grfn_var(
                    arg_name, id, version, arg_con_scopestr
                )
                arg_fullid = build_fullid(
                    arg_name, id, version, arg_con_scopestr
                )
                self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
                # store arg_fullid
                node.arg_index_to_fullid[i] = arg_fullid
                # create From Source metadata for the GrFN var
                from_source = False
                from_source_mdata = generate_from_source_metadata(
                    from_source, VariableCreationReason.FUNC_ARG
                )
                add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

                param_grfn_var = create_grfn_var(
                    param_name, id, version, param_con_scopestr
                )
                param_fullid = build_fullid(
                    param_name, id, version, param_con_scopestr
                )
                self.pipeline_state.store_grfn_var(
                    param_fullid, param_grfn_var
                )
                # store param_fullid
                node.param_index_to_fullid[i] = param_fullid
                # create From Source metadata for the GrFN var
                add_metadata_from_name_node(param_grfn_var, param.val)

                # link argument and parameter through top interface
                node.top_interface_in[id] = arg_fullid
                node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After create_call_args_and_params():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def call_top_interface_args_with_no_func_def(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`

        During GrfnAssignmentPass,
        for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
        &#34;&#34;&#34;
        # call container is used to scope parameters
        call_con_name = call_container_name(node)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        for i, n in enumerate(node.arguments):
            # argument name and scope str
            arg_name = call_argument_name(node, i)
            arg_con_scopestr = con_scope_to_str(node.func.con_scope)

            # parameter name and scopestr
            param_name = call_param_name(node, i)
            param_con_scopestr = con_scope_to_str(
                node.func.con_scope + [call_con_name]
            )

            # argument and parameter share id, and start with initial version
            id = self.pipeline_state.next_collapsed_id()
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            # create From Source metadata for the GrFN var
            # when we don&#39;t have the function def, we create a paramter with a default name
            add_metadata_to_grfn_var(param_grfn_var, from_source_mdata)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After create_call_args_and_params():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def populate_call_bot_interface_with_ret_val(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates two GrFN variables for the Call&#39;s return value.
        One is in the interior of the container and links
        to the bot interface in.  The other is outside the container and
        links to the bot interface out.
        &#34;&#34;&#34;
        # Create new GrFN for return value for bot interface in and bot interface out
        var_name = call_ret_val_name(node)
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )

        in_ret_val = create_grfn_var(var_name, id, version, call_con_scopestr)
        in_fullid = build_fullid(var_name, id, version, call_con_scopestr)
        self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_RET_VAL
        )
        add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

        # exterior container scope
        con_scopestr = con_scope_to_str(node.func.con_scope)
        out_ret_val = create_grfn_var(var_name, id, version, con_scopestr)
        out_fullid = build_fullid(var_name, id, version, con_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
        add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

        # store created fullid and grfn_id in node&#39;s ret_val
        node.out_ret_val[id] = out_fullid
        node.in_ret_val[id] = in_fullid
        # link ret values on bot interface
        node.bot_interface_in[id] = in_fullid
        node.bot_interface_out[id] = out_fullid

    def grfn_2_2_call_top_interface_args(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`

        During GrfnAssignmentPass,
        for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
        &#34;&#34;&#34;
        # call container is used to scope parameters
        call_con_name = call_container_name(node)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        # if we are generating GrFN 2.2, we would like the parameter to lie in the
        # copied function def container, we do this by aliasing versions during GrfnVarCreation pass
        for i, n in enumerate(node.arguments):
            # argument name and scope str
            arg_name = call_argument_name(node, i)
            arg_con_scopestr = con_scope_to_str(node.func.con_scope)

            # parameter name and scopestr
            param = node.func_def_copy.func_args[i]
            assert isinstance(param, AnnCastVar)
            param_name = param.val.name
            param_con_scopestr = con_scope_to_str(
                node.func.con_scope + [call_con_name]
            )

            # argument and parameter share id, and start with initial version
            id = self.pipeline_state.next_collapsed_id()
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            add_metadata_from_name_node(param_grfn_var, param.val)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After create_call_args_and_params():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def grfn_2_2_call_ret_val_creation(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates two GrFN variables for the Call&#39;s return value.
        One is in the interior of the container and links
        to the bot interface in.  The other is outside the container and
        links to the bot interface out.
        &#34;&#34;&#34;
        # Create new GrFN for return value for bot interface in and bot interface out
        var_name = call_ret_val_name(node)
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )

        in_ret_val = create_grfn_var(var_name, id, version, call_con_scopestr)
        in_fullid = build_fullid(var_name, id, version, call_con_scopestr)
        self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_RET_VAL
        )
        add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

        # exterior container scope
        con_scopestr = con_scope_to_str(node.func.con_scope)
        out_ret_val = create_grfn_var(var_name, id, version, con_scopestr)
        out_fullid = build_fullid(var_name, id, version, con_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
        # create From Source metadata for the GrFN var
        add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

        # store created fullid and grfn_id in node&#39;s ret_val
        node.out_ret_val[id] = out_fullid
        node.in_ret_val[id] = in_fullid
        # link ret values on bot interface
        node.bot_interface_in[id] = in_fullid
        node.bot_interface_out[id] = out_fullid

        # also, store the created ret_val in the copied function def
        # this is done so that we can assign to the ret val when
        # parsing return statements
        node.func_def_copy.in_ret_val[id] = in_fullid

    def add_globals_to_grfn_2_2_call_interfaces(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Populates top and bot interface with global variables
          - Adds incoming global variable version to top_interface_in
          - Increments modified globals versions in enclosing scope
          - Adds incremented version to bot_interface_out
          - Creates VAR_INIT_VERSION global variables in Call contianer scope and
            adds them to top_interface_out
          - Creates VAR_INIT_VERSION global variables in copied FunctionDef scope and
            aliases them to their corresponding Call container scope globals
          - Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in
        &#34;&#34;&#34;
        # in the current scope, increment all versions of global variables
        # that are modified by this call
        # the calling container scope is stored in the Call&#39;s AnnCastName node
        calling_scopestr = con_scope_to_str(node.func.con_scope)

        # add globals to exterior interfaces
        # add global variables to top_interface_in
        # these are all used globals
        node.top_interface_vars = node.func_def_copy.used_globals
        self.populate_interface(
            calling_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # the bot interface globals are all modified globals
        node.bot_interface_vars = node.func_def_copy.modified_globals
        # increment versions of all modified global variables
        self.incr_vars_in_con_scope(calling_scopestr, node.bot_interface_vars)
        # add modified globals to bot interface out
        self.populate_interface(
            calling_scopestr, node.bot_interface_vars, node.bot_interface_out
        )

        # add globals to interior interfaces
        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )
        copied_func_scopestr = con_scope_to_str(node.func_def_copy.con_scope)
        # create globals for top_interface_out and bot interface in
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            call_init_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            call_init_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(
                call_init_fullid, call_init_global
            )
            node.top_interface_out[id] = call_init_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(call_init_global, from_source_mdata)

            # alias the func copies init version
            func_copy_init_fullid = build_fullid(
                var_name, id, version, copied_func_scopestr
            )
            self.pipeline_state.alias_grfn_vars(
                func_copy_init_fullid, call_init_fullid
            )

        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            exit_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            exit_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(exit_fullid, exit_global)
            node.bot_interface_in[id] = exit_fullid
            # we intentionally do not add metadata to the GrFN variable here, since
            # the highest version from the copied FunctionDef will be aliased to this
            # variable, and the metadata for this GrFN variable will be populated from
            # that highest version

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After adding globals for GrFN 2.2 call ():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)

    def add_globals_to_call_interfaces(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Populates top and bot interface with global variables
          - Adds incoming global variable version to top_interface_in
          - Increments modified globals versions in enclosing scope
          - Adds incremented version to bot_interface_out
          - Creates VAR_INIT_VERSION global variables and adds to top_interface_out
          - Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in
        &#34;&#34;&#34;
        # in the current scope, increment all versions of global variables
        # that are modified by this call
        # the calling container scope is stored in the Call&#39;s AnnCastName node
        calling_scopestr = con_scope_to_str(node.func.con_scope)
        func_def = self.pipeline_state.func_def_node_from_id(node.func.id)

        # add globals to exterior interfaces
        # top interface globals are globals which are accessed before modification
        node.top_interface_vars = func_def.used_globals

        # add global variables to top_interface_in
        self.populate_interface(
            calling_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # the bot interface globals are all modified globals
        node.bot_interface_vars = func_def.modified_globals
        # increment versions of all modified global variables
        self.incr_vars_in_con_scope(calling_scopestr, node.bot_interface_vars)
        # add modified globals to bot interface out
        self.populate_interface(
            calling_scopestr, node.bot_interface_vars, node.bot_interface_out
        )

        # add globals to interior interfaces
        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )
        # create globals for top_interface_out and bot interface in
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            init_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            init_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(init_fullid, init_global)
            node.top_interface_out[id] = init_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(init_global, from_source_mdata)

        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            exit_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            exit_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(exit_fullid, exit_global)
            node.bot_interface_in[id] = exit_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.BOT_IFACE_INTRO
            )
            add_metadata_to_grfn_var(exit_global, from_source_mdata)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After adding globals for GrFN 2.3 call ():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)

    def visit(self, node: AnnCastNode, assign_lhs: bool):
        # print current node being visited.
        # this can be useful for debugging
        # class_name = node.__class__.__name__
        # print(f&#34;\nProcessing node type {class_name}&#34;)
        return self._visit(node, assign_lhs)

    @singledispatchmethod
    def _visit(self, node: AnnCastNode, assign_lhs: bool):
        &#34;&#34;&#34;
        Visit each AnnCastNode
        Parameters:
          - `assign_lhs`: this denotes whether we are visiting the LHS or RHS of an AnnCastAssignment
                      This is used to determine whether a variable (AnnCastName node) is
                      accessed or modified in that context
        &#34;&#34;&#34;
        raise Exception(f&#34;Unimplemented AST node of type: {type(node)}&#34;)

    def visit_node_list(self, node_list: typing.List[AnnCastNode], assign_lhs):
        return [self.visit(node, assign_lhs) for node in node_list]

    @_visit.register
    def visit_assignment(self, node: AnnCastAssignment, assign_lhs: bool):
        self.visit(node.right, assign_lhs)
        # The AnnCastTuple is added to handle scenarios where an assignment
        # is made by assigning to a tuple of values, as opposed to one singular value
        assert (
            isinstance(node.left, AnnCastVar)
            or (isinstance(node.left, AnnCastLiteralValue) and (node.left.value_type == StructureType.TUPLE))
            or isinstance(node.left, AnnCastAssignment)
            or isinstance(node.left, AnnCastAttribute) or isinstance(node.left, AnnCastCall)
        ), f&#34;container_scope: visit_assigment: node.left is {type(node.left)}&#34;
        self.visit(node.left, True)

    @_visit.register
    def visit_attribute(self, node: AnnCastAttribute, assign_lhs: bool):
        pass

    @_visit.register
    def visit_call(self, node: AnnCastCall, assign_lhs: bool):
        assert isinstance(node.func, AnnCastName) or isinstance(
            node.func, AnnCastAttribute
        )

        if node.is_grfn_2_2:
            self.visit_call_grfn_2_2(node, assign_lhs)
            return

        self.visit_node_list(node.arguments, assign_lhs)
        # populate call nodes&#39;s top interface with arguments
        # The pattern for the top interface is as follows:
        # For each argument, we create a GrFN variable using the arguments index
        # E.g. Arg0, Arg1, ...
        # top interface inputs: Arg0, Arg1,...
        # top interface outputs: Param0, Param1, ...
        # if this Call has a FunctionDef, then we can fill in correct paramter names
        # if it doesn&#39;t we need to provide default parameter names
        # if we have the FunctionDef for the call, we can also add globals to the interfaces
        if node.has_func_def:
            self.call_top_interface_args_with_func_def(node)
            self.add_globals_to_call_interfaces(node)
            func_node = node.func.id
            func_def_node = self.pipeline_state.func_def_node_from_id(
                func_node
            )
            node.has_ret_val = func_def_node.has_ret_val
        # if we do not have the FunctionDef, we will not add any globals to the interfaces
        else:
            self.call_top_interface_args_with_no_func_def(node)

        # add return value to bot interface out
        if node.has_ret_val:
            self.populate_call_bot_interface_with_ret_val(node)

    def visit_call_grfn_2_2(self, node: AnnCastCall, assign_lhs: bool):
        assert isinstance(node.func, AnnCastName)
        self.visit_node_list(node.arguments, assign_lhs)
        # populate call nodes&#39;s top interface with arguments
        # The pattern for the top interface is as follows:
        # For each argument, we create a GrFN variable using the arguments index
        # E.g. Arg0, Arg1, ...
        # top interface inputs: Arg0, Arg1,...
        # top interface outputs: NamedParam0, NamedParam1, ...
        self.grfn_2_2_call_top_interface_args(node)

        node.has_ret_val = node.func_def_copy.has_ret_val
        # add return value to bot interface out if function_copy has a ret_val
        if node.func_def_copy.has_ret_val:
            self.grfn_2_2_call_ret_val_creation(node)

        # we visit the function def copy to version globals appearing in its body
        call_assign_lhs = False
        self.visit_function_def_copy(node.func_def_copy, call_assign_lhs)

        # add globals to call interface
        self.add_globals_to_grfn_2_2_call_interfaces(node)

    @_visit.register
    def visit_record_def(self, node: AnnCastRecordDef, assign_lhs: bool):
        # Visit the function defs within this class to make sure
        # Everything is versioned correctly
        self.visit_node_list(node.funcs, assign_lhs)

    def visit_function_def_copy(
        self, node: AnnCastFunctionDef, assign_lhs: bool
    ):
        &#34;&#34;&#34;
        Used for GrFN 2.2 Generation
        &#34;&#34;&#34;
        # Initialize scope_to_highest_var_vers
        con_scopestr = con_scope_to_str(node.con_scope)
        # create VAR_INIT_VERSION of any modified or accessed variables
        self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())

        # visit children
        self.visit_node_list(node.func_args, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)

        # store highest var version
        node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
            con_scopestr
        ]

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor FUNCTION COPY: {con_scopestr}&#34;)
            print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)

    @_visit.register
    def visit_function_def(self, node: AnnCastFunctionDef, assign_lhs: bool):
        # Initialize scope_to_highest_var_vers
        con_scopestr = con_scope_to_str(node.con_scope)
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())

        # visit children
        self.visit_node_list(node.func_args, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)

        # store highest var version
        node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
            con_scopestr
        ]

        # populate FunctionDef nodes&#39;s top interface with arguments
        # The pattern for the top interface is as follows:
        # For each argument, we create a GrFN variable using the arguments index
        # E.g. Arg0, Arg1, ...
        # top interface inputs: Arg0, Arg1,...
        # top interface outputs: NamedParam0, NamedParam1, ...
        self.func_def_top_interface_args(node)

        # add return value to bot interface out if functiondef has a ret_val
        if node.has_ret_val:
            self.func_def_ret_val_creation(node)

        # add globals to functiondef integfaces
        if is_func_def_main(node):
            self.add_globals_to_main_func_def_interfaces(node)
        else:
            self.add_globals_to_non_main_func_def_interfaces(node)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor FUNCTION: {con_scopestr}&#34;)
            print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)

    @_visit.register
    def visit_literal_value(self, node: AnnCastLiteralValue, assign_side):
        if node.value_type == &#34;List[Any]&#34;:
            # val has
            # operator - string
            # size - Var node or a LiteralValue node (for number)
            # initial_value - LiteralValue node
            val = node.value

            # visit size&#39;s anncast name node
            self.visit(val.size, assign_side)

            # List literal doesn&#39;t need to add any other changes
            # to the anncast at this pass

        elif node.value_type == StructureType.TUPLE: # or node.value_type == StructureType.LIST:
            self.visit_node_list(node.value, assign_side)
        elif node.value_type == ScalarType.INTEGER:
            pass
        elif node.value_type == ScalarType.ABSTRACTFLOAT:
            pass
        pass

    @_visit.register
    def visit_loop(self, node: AnnCastLoop, assign_lhs: bool):
        # Initialize scope_to_highest_var_version
        if len(node.pre) &gt; 0:
            pre_scopestr = con_scope_to_str(node.con_scope + [LOOPPRE])
        expr_scopestr = con_scope_to_str(node.con_scope + [LOOPEXPR])
        body_scopestr = con_scope_to_str(node.con_scope + [LOOPBODY])
        if len(node.post) &gt; 0:
            post_scopestr = con_scope_to_str(node.con_scope + [LOOPPOST])

        # Initialize LoopInit
        # create versions 0 of any modified or accessed variables
        if len(node.pre) &gt; 0:
            self.init_highest_var_vers_dict(
                pre_scopestr, node.used_vars.keys()
            )

        # Initialize LoopExpr
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(expr_scopestr, node.used_vars.keys())

        # Initialize LoopBody
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(body_scopestr, node.used_vars.keys())

        # Initialize LoopPost
        if len(node.post) &gt; 0:
            self.init_highest_var_vers_dict(
                post_scopestr, node.used_vars.keys()
            )

        ######## visit children ########
        if len(node.pre) &gt; 0:
            self.visit_node_list(node.pre, assign_lhs)

        self.visit(node.expr, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)

        if len(node.post) &gt; 0:
            self.visit_node_list(node.post, assign_lhs)

        # print(node.used_vars)

        # store highest var version
        if len(node.pre) &gt; 0:
            node.pre_highest_var_vers = self.con_scope_to_highest_var_vers[
                pre_scopestr
            ]

        node.expr_highest_var_vers = self.con_scope_to_highest_var_vers[
            expr_scopestr
        ]
        node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
            body_scopestr
        ]

        if len(node.post) &gt; 0:
            node.post_highest_var_vers = self.con_scope_to_highest_var_vers[
                post_scopestr
            ]

        # populate all of this loops interfaces
        self.populate_loop_interfaces(node)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor LOOP: {con_scope_to_str(node.con_scope)}&#34;)
            if len(node.pre) &gt; 0:
                print(f&#34;  PreHighestVers: {node.pre_highest_var_vers}&#34;)
            print(f&#34;  ExprHighestVers: {node.expr_highest_var_vers}&#34;)
            print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)
            if len(node.Post) &gt; 0:
                print(f&#34;  PostHighestVers: {node.post_highest_var_vers}&#34;)

    @_visit.register
    def visit_model_break(self, node: AnnCastModelBreak, assign_lhs: bool):
        pass

    @_visit.register
    def visit_model_continue(
        self, node: AnnCastModelContinue, assign_lhs: bool
    ):
        pass

    @_visit.register
    def visit_model_import(self, node: AnnCastModelImport, assign_lhs: bool):
        pass

    @_visit.register
    def visit_model_if(self, node: AnnCastModelIf, assign_lhs: bool):
        # Initialize scope_to_highest_var_version
        expr_scopestr = con_scope_to_str(node.con_scope + [IFEXPR])
        ifbody_scopestr = con_scope_to_str(node.con_scope + [IFBODY])
        elsebody_scopestr = con_scope_to_str(node.con_scope + [ELSEBODY])
        # initialize IfExpr
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(expr_scopestr, node.used_vars.keys())

        # initialize IfBody
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(ifbody_scopestr, node.used_vars.keys())

        # initialize ElseBody
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(
            elsebody_scopestr, node.used_vars.keys()
        )

        # visit children
        self.visit(node.expr, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)
        self.visit_node_list(node.orelse, assign_lhs)

        # store highest var versions
        node.expr_highest_var_vers = self.con_scope_to_highest_var_vers[
            expr_scopestr
        ]
        node.ifbody_highest_var_vers = self.con_scope_to_highest_var_vers[
            ifbody_scopestr
        ]
        node.elsebody_highest_var_vers = self.con_scope_to_highest_var_vers[
            elsebody_scopestr
        ]

        # populate interfaces
        self.populate_model_if_interfaces(node)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor IF: {con_scope_to_str(node.con_scope)}&#34;)
            print(f&#34;  ExprHighestVers: {node.expr_highest_var_vers}&#34;)
            print(f&#34;  IfBodyHighestVers: {node.ifbody_highest_var_vers}&#34;)
            print(f&#34;  ElseBodyHighestVers: {node.elsebody_highest_var_vers}&#34;)

    @_visit.register
    def visit_return(self, node: AnnCastModelReturn, assign_lhs: bool):
        self.visit(node.value, assign_lhs)

    @_visit.register
    def visit_module(self, node: AnnCastModule, assign_lhs: bool):
        con_scopestr = con_scope_to_str(node.con_scope)
        # create VAR_INIT_VERSION of any modified or accessed variables
        self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())
        self.visit_node_list(node.body, assign_lhs)

    @_visit.register
    def visit_name(self, node: AnnCastName, assign_lhs: bool):
        con_scopestr = con_scope_to_str(node.con_scope)
        if assign_lhs:
            self.incr_version_in_con_scope(con_scopestr, node.id, node.name)

        node.version = self.get_highest_ver_in_con_scope(con_scopestr, node.id)

    @_visit.register
    def visit_operator(self, node: AnnCastOperator, assign_lhs: bool):
        # visit operands
        self.visit_node_list(node.operands, assign_lhs)

    @_visit.register
    def visit_set(self, node: AnnCastSet, assign_lhs: bool):
        pass

    @_visit.register
    def visit_tuple(self, node: AnnCastTuple, assign_lhs: bool):
        self.visit_node_list(node.values, assign_lhs)

    @_visit.register
    def visit_var(self, node: AnnCastVar, assign_lhs: bool):
        self.visit(node.val, assign_lhs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass"><code class="flex name class">
<span>class <span class="ident">VariableVersionPass</span></span>
<span>(</span><span>pipeline_state:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.PipelineState" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.PipelineState">PipelineState</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableVersionPass:
    def __init__(self, pipeline_state: PipelineState):
        self.pipeline_state = pipeline_state
        self.nodes = self.pipeline_state.nodes

        # dict mapping container scopes strs to dicts which
        # map Name id to highest version in that container scope
        self.con_scope_to_highest_var_vers = {}

        for node in self.pipeline_state.nodes:
            # when visitor starts, assign_lhs is False
            self.visit(node, False)

    def init_highest_var_vers_dict(self, con_scopestr, var_ids):
        &#34;&#34;&#34;
        Initialize highest var version dict for scope `con_scopestr`
        If the scope is the module, then use a defaultdict starting at zero
        otherwise, create a dictionary mapping each of the ids to zero
        &#34;&#34;&#34;
        self.con_scope_to_highest_var_vers[con_scopestr] = {}
        for id in var_ids:
            self.con_scope_to_highest_var_vers[con_scopestr][id] = 0
        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(
                f&#34;initialized highest_vars_vers_dict {self.con_scope_to_highest_var_vers[con_scopestr]}&#34;
            )

    def get_highest_ver_in_con_scope(self, con_scopestr, id):
        &#34;&#34;&#34;
        Grab the current version of `id` in scope for `con_scopestr`
        Should only be called after `con_scopestr` is in the `self.con_scope_to_highest_var_vers`
        &#34;&#34;&#34;
        return self.con_scope_to_highest_var_vers[con_scopestr][id]

    def is_var_in_con_scope(self, con_scopestr: str, id: int):
        return id in self.con_scope_to_highest_var_vers[con_scopestr]

    def incr_version_in_con_scope(
        self, con_scopestr: str, id: int, var_name: str
    ):
        &#34;&#34;&#34;
        Grab the next version of `id` in scope for `con_scopestr`
        Should only be called after `con_scopestr` is in the `self.con_scope_to_highest_var_vers`

        Also creates a GrFN variable for the newly added version
        &#34;&#34;&#34;
        # NOTE: we should have added id to con_scope_to_highest_var_vers when we call
        # init_highest_var_vers_dict
        # if this does not happen, some logic has failed
        assert id in self.con_scope_to_highest_var_vers[con_scopestr]
        self.con_scope_to_highest_var_vers[con_scopestr][id] += 1
        version = self.con_scope_to_highest_var_vers[con_scopestr][id]
        grfn_var = create_grfn_var(var_name, id, version, con_scopestr)
        fullid = build_fullid(var_name, id, version, con_scopestr)
        self.pipeline_state.store_grfn_var(fullid, grfn_var)

    def incr_vars_in_con_scope(self, scopestr, vars):
        &#34;&#34;&#34;
        This will increment all versions of variables in `scopestr` that are
        in the dict `vars` which contains variable ids mapped to AnnCastName nodes
        &#34;&#34;&#34;
        for var_id, var_name in vars.items():
            self.incr_version_in_con_scope(scopestr, var_id, var_name)

    def add_default_bot_interface_metadata(self, interface_vars):
        &#34;&#34;&#34;
        Adds a bot interface metadata to interface_vars
        &#34;&#34;&#34;
        for fullid in interface_vars.values():
            grfn_var = self.pipeline_state.get_grfn_var(fullid)
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.BOT_IFACE_INTRO
            )
            add_metadata_to_grfn_var(
                grfn_var, from_source_mdata=from_source_mdata
            )

    def fix_for_python_gcc_declaration_distinction(
        self, con_scopestr, id, var_name
    ):
        &#34;&#34;&#34;
        This function adds a dummy GrfnAssignment to `None` for variable with id `id`
        in the container for con_scopestr

        The motivation for this is the difference between how the gcc and Python handle
        variable declaration.

        For gcc, all variable declaration are placed at the top
        of the enclosing FunctionDef.  Currently, we rely on this for If and Loop container
        top interfaces.

        The Python AST follows Python semantics, and variables are introduced inline dynamically.
        This leads to many challenges creating interfaces e.g.

        ```python
        def func():
            x = 5
            if x == 5:
                z = 3
        ```
        In this code example, what happens to z along the else branch?  GrFN If containers always make a
        selection between two values, but this does not align with dynamic/conditional variable creation in Python,
        as in the above code example.
        &#34;&#34;&#34;
        version = self.con_scope_to_highest_var_vers[con_scopestr][id]
        # this function should only be called in cases where we need to implement a dummy assignment
        # which creates a version 1 variable
        assert version == VAR_INIT_VERSION
        # increment the version, and create an GrFN variable for the incremented version
        self.incr_version_in_con_scope(con_scopestr, id, var_name)
        new_version = self.con_scope_to_highest_var_vers[con_scopestr][id]
        new_fullid = build_fullid(var_name, id, new_version, con_scopestr)
        grfn_var = self.pipeline_state.get_grfn_var(new_fullid)
        from_source_mdata = generate_from_source_metadata(
            False, VariableCreationReason.DUMMY_ASSIGN
        )
        add_metadata_to_grfn_var(grfn_var, from_source_mdata)

        # create a literal GrFN assignment for this dummy assignment
        assign_metadata = create_lambda_node_metadata(source_refs=[])
        literal_node = create_grfn_literal_node(assign_metadata)
        lambda_expr = &#34;lambda: None&#34;
        literal_node.func_str = lambda_expr
        literal_node.function = load_lambda_function(literal_node.func_str)
        dummy_assignment = GrfnAssignment(
            literal_node, LambdaType.LITERAL, lambda_expr=lambda_expr
        )
        dummy_assignment.outputs[new_fullid] = grfn_var.uid

        # add dummy assignment to function def node
        assert self.pipeline_state.is_con_scopestr_func_def(con_scopestr)
        func_def_node = self.pipeline_state.func_def_node_from_scopestr(
            con_scopestr
        )

        func_def_node.dummy_grfn_assignments.append(dummy_assignment)

    def populate_interface(self, con_scopestr, vars, interface):
        &#34;&#34;&#34;
        Parameters:
          - `con_scopestr`: a cached container scope
          - `vars`: a dict mapping numerical ids to variable names
          - `interface`: a dict mapping numerical variable ids to fullids
                         (e.g. the top or bottom interface of a container node)

        For each variable from `vars`, put the highest version of that variable
        from container `con_scopestr` into `interface`
        &#34;&#34;&#34;
        # add vars to interface
        for id, var_name in vars.items():
            highest_ver = self.get_highest_ver_in_con_scope(con_scopestr, id)
            # if con_scopestr is a FunctionDef container, and highest_ver is VAR_INIT_VERSION
            # we call fix_for_python_gcc_declaration_distinction
            # this creates a dummy assignment to the variable in the FunctionDef container
            # most likely, this is not the ideal long term solution
            scopestr_is_func = self.pipeline_state.is_con_scopestr_func_def(
                con_scopestr
            )
            local_var = (
                scopestr_is_func
                and self.pipeline_state.is_var_local_to_func(con_scopestr, id)
            )
            if local_var and highest_ver == VAR_INIT_VERSION:
                self.fix_for_python_gcc_declaration_distinction(
                    con_scopestr, id, var_name
                )
                # update highest ver after the dummy assignment
                highest_ver = self.get_highest_ver_in_con_scope(
                    con_scopestr, id
                )
            fullid = build_fullid(var_name, id, highest_ver, con_scopestr)
            interface[id] = fullid

    def populate_loop_interfaces(self, node: AnnCastLoop):
        # populate interfaces and increment versions in previous scope of modified variables
        prev_scopestr = con_scope_to_str(node.con_scope[:-1])
        # populate top interface initial
        # these are all used variables
        node.top_interface_vars = node.used_vars
        self.populate_interface(
            prev_scopestr, node.top_interface_vars, node.top_interface_initial
        )
        # increment versions of modified vars
        self.incr_vars_in_con_scope(prev_scopestr, node.modified_vars)
        # populate bot interface out
        node.bot_interface_vars = node.modified_vars
        self.populate_interface(
            prev_scopestr, node.bot_interface_vars, node.bot_interface_out
        )
        self.add_default_bot_interface_metadata(node.bot_interface_out)

        # populate &#34;inside&#34; of interfaces
        con_scopestr = con_scope_to_str(node.con_scope)
        # populate top interface updated
        # these are all modified variables
        node.top_interface_updated_vars = node.modified_vars
        for id, var_name in node.top_interface_updated_vars.items():
            version = LOOP_VAR_UPDATED_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.top_interface_updated[id] = fullid
        # populate top interface out
        # the top interface chooses between initial and updated versions;
        # by convention the produced version is `VAR_INIT_VERSION`
        # which is consistent with other containers
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.top_interface_out[id] = fullid
        # populate bot interface in
        # the bot interface takes `VAR_EXIT_VERSION` modified variables
        # During GrFN Variable Creation, these versions will be aliased to
        # the highest version occuring in the loop expr
        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.bot_interface_in[id] = fullid

    def populate_model_if_interfaces(self, node: AnnCastModelIf):
        # populate interfaces and increment versions in previous scope of modified variables
        prev_scopestr = con_scope_to_str(node.con_scope[:-1])
        # populate top interface in
        node.top_interface_vars = node.used_vars
        self.populate_interface(
            prev_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # increment versions
        self.incr_vars_in_con_scope(prev_scopestr, node.modified_vars)
        # populate bot interface out
        node.bot_interface_vars = node.modified_vars
        self.populate_interface(
            prev_scopestr, node.bot_interface_vars, node.bot_interface_out
        )
        self.add_default_bot_interface_metadata(node.bot_interface_out)

        # populate &#34;inside&#34; of interfaces
        con_scopestr = con_scope_to_str(node.con_scope)
        # populate top interface out
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # and these are propagated to if expr, if body, and else body
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.top_interface_out[id] = fullid
        # populate bot interface in
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        # these versions are produced by the Decision node
        # and they are created during GrfnVariableCreationPass
        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            fullid = build_fullid(var_name, id, version, con_scopestr)
            node.bot_interface_in[id] = fullid

    def func_def_top_interface_args(self, node: AnnCastFunctionDef):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`
        &#34;&#34;&#34;
        # function container is used to scope parameters
        param_con_scopestr = con_scope_to_str(node.con_scope)
        # enclosing container is used to scope arguments
        enclosing_con_scope = node.con_scope[:-1]
        arg_con_scopestr = con_scope_to_str(enclosing_con_scope)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        for i, param in enumerate(node.func_args):
            # argument name and scope str
            arg_name = func_def_argument_name(node, i)

            # parameter name and scopestr
            assert isinstance(param, AnnCastVar)
            param_name = param.val.name

            # argument and parameter share id, and start with initial version
            id = param.val.id
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            # store metadata in paramter GrFN Var
            add_metadata_from_name_node(param_grfn_var, param.val)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;After func_def_top_iface_args():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def func_def_ret_val_creation(self, node: AnnCastFunctionDef):
        &#34;&#34;&#34;
        Creates two GrFN variables for the FunctionDef&#39;s return value.
        One is in the interior of the container and links
        to the bot interface in.  The other is outside the container and
        links to the bot interface out.
        &#34;&#34;&#34;
        # Create new GrFN for return value for bot interface in and bot interface out
        var_name = func_def_ret_val_name(node)
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # interior container scope
        func_scopestr = con_scope_to_str(node.con_scope)

        in_ret_val = create_grfn_var(var_name, id, version, func_scopestr)
        in_fullid = build_fullid(var_name, id, version, func_scopestr)
        self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_RET_VAL
        )
        add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

        # exterior container scope
        enclosing_con = node.con_scope[:-1]
        enclosing_scopestr = con_scope_to_str(enclosing_con)
        out_ret_val = create_grfn_var(
            var_name, id, version, enclosing_scopestr
        )
        out_fullid = build_fullid(var_name, id, version, enclosing_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
        # create From Source metadata for the GrFN var
        add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

        # store created fullid and grfn_id in node&#39;s ret_val
        node.out_ret_val[id] = out_fullid
        node.in_ret_val[id] = in_fullid
        # link ret values on bot interface
        node.bot_interface_in[id] = in_fullid
        node.bot_interface_out[id] = out_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;\tAfter func_def_ret_val_creation():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def add_globals_to_main_func_def_interfaces(
        self, node: AnnCastFunctionDef
    ):
        &#34;&#34;&#34;
        Populates top and bot interface of main FunctionDef with global variables
          - Adds incoming global variable version to top_interface_in
          - Increments modified globals versions in enclosing scope
          - Adds incremented version to bot_interface_out
          - Creates VAR_INIT_VERSION global variables and adds to top_interface_out
          - Add `body_highest_var_vers` global variables to bot_interface_in
        &#34;&#34;&#34;
        # in the enclosing scope, increment all versions of global variables
        # that are modified by main
        enclosing_con_scope = node.con_scope[:-1]
        enclosing_scopestr = con_scope_to_str(enclosing_con_scope)

        # add globals to exterior interfaces
        # add global variables to top_interface_in these are all used globals
        node.top_interface_vars = node.used_globals
        self.populate_interface(
            enclosing_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # the bot interface globals are all modified globals
        node.bot_interface_vars = node.modified_globals
        # increment versions of all modified global variables
        self.incr_vars_in_con_scope(
            enclosing_scopestr, node.bot_interface_vars
        )
        # add modified globals to bot interface out
        self.populate_interface(
            enclosing_scopestr, node.bot_interface_vars, node.bot_interface_out
        )

        # add globals to interior interfaces
        # interior container scope
        func_scopestr = con_scope_to_str(node.con_scope)
        # create globals for top_interface_out and bot interface in
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            init_fullid = build_fullid(var_name, id, version, func_scopestr)
            init_global = create_grfn_var(var_name, id, version, func_scopestr)
            self.pipeline_state.store_grfn_var(init_fullid, init_global)
            node.top_interface_out[id] = init_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(init_global, from_source_mdata)

        # we do not create the GrFN VariableNode for the highest version global
        # here, since it is done while visitng Assignment node during GrfnVarCreation pass
        for id, var_name in node.bot_interface_vars.items():
            version = node.body_highest_var_vers[id]
            exit_fullid = build_fullid(var_name, id, version, func_scopestr)
            node.bot_interface_in[id] = exit_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;\tAfter add_globals_to_main_func_def_interfaces():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def add_globals_to_non_main_func_def_interfaces(
        self, node: AnnCastFunctionDef
    ):
        &#34;&#34;&#34;
        Populates top and bot interface of FunctionDef with global variables
        For each global, we make an addtional global whose name is specialized to
        this function.  This is to separate the globals that &#34;main&#34; uses
        from the globals that are used in other FunctionDef&#39;s because of main&#39;s
        special role.
          - Creates VAR_INIT_VERSION version for each specialized global and
            Links these specialized globals through the `top_interface_in` and `top_interface_out`
          - Creates VAR_EXIT_VERSION version for each specialized global and
            Links these specialized globals through the `bot_interface_in` and `bot_interface_out`
        &#34;&#34;&#34;
        enclosing_con_scope = node.con_scope[:-1]
        enclosing_scopestr = con_scope_to_str(enclosing_con_scope)
        # interior container scope
        func_scopestr = con_scope_to_str(node.con_scope)

        # add global variables to top_interface_in
        # these are all used globals
        node.top_interface_vars = node.used_globals
        # the bot interface globals are all modified globals
        node.bot_interface_vars = node.modified_globals

        # we create specialized globals for this function def, in the enclosing scope.
        # this is to accomodate interfaces, since they expect the same id
        # on either side
        # this is similar to how we handle arguments from enclosing scope linking to
        # parameters in the interior of a container

        # create specialized globals for top interface
        # by convention the top interface produces version VAR_INIT_VERSION variables
        version = VAR_INIT_VERSION
        for id, var_name in node.top_interface_vars.items():
            # exterior specialized top global
            specialized_name = specialized_global_name(node, var_name)
            in_fullid = build_fullid(
                specialized_name, id, version, enclosing_scopestr
            )
            in_global = create_grfn_var(
                specialized_name, id, version, enclosing_scopestr
            )
            self.pipeline_state.store_grfn_var(in_fullid, in_global)
            node.top_interface_in[id] = in_fullid
            # create From Source metadata for the GrFN var
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.DUP_GLOBAL
            )
            add_metadata_to_grfn_var(in_global, from_source_mdata)
            # interior top global
            out_fullid = build_fullid(var_name, id, version, func_scopestr)
            out_global = create_grfn_var(var_name, id, version, func_scopestr)
            self.pipeline_state.store_grfn_var(out_fullid, out_global)
            node.top_interface_out[id] = out_fullid
            # create From Source metadata for the GrFN var
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(in_global, from_source_mdata)

        # create specialized globals for bot interface
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.bot_interface_vars.items():
            # interior bot global
            # we do not create the GrFN VariableNode for the highest version global
            # here, since it is done while visitng Assignment node during GrfnVarCreation pass
            version = node.body_highest_var_vers[id]
            in_fullid = build_fullid(var_name, id, version, func_scopestr)
            node.bot_interface_in[id] = in_fullid
            # exterior specialized bot global
            version = VAR_EXIT_VERSION
            specialized_name = specialized_global_name(node, var_name)
            out_fullid = build_fullid(
                specialized_name, id, version, enclosing_scopestr
            )
            out_global = create_grfn_var(
                specialized_name, id, version, enclosing_scopestr
            )
            self.pipeline_state.store_grfn_var(out_fullid, out_global)
            node.bot_interface_out[id] = out_fullid
            # create From Source metadata for the GrFN var
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.DUP_GLOBAL
            )
            add_metadata_to_grfn_var(out_global, from_source_mdata)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;For FunctionDef {node.name.name}&#34;)
            print(&#34;\tAfter add_globals_to_non_main_func_def_interfaces():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)
            print(f&#34;\ttop_interface_vars = {node.top_interface_vars}&#34;)
            print(f&#34;\tbot_interface_in = {node.bot_interface_in}&#34;)
            print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)
            print(f&#34;\tbot_interface_vars = {node.bot_interface_vars}&#34;)

    def call_top_interface_args_with_func_def(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`

        During GrfnAssignmentPass,
        for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
        &#34;&#34;&#34;
        # call container is used to scope parameters
        call_con_name = call_container_name(node)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        for i, n in enumerate(node.arguments):
            # parameter name and scopestr
            func_def = self.pipeline_state.func_def_node_from_id(node.func.id)
            if i &lt; len(func_def.func_args):  # NOTE: M7 Placeholder
                # argument name and scope str
                arg_name = call_argument_name(node, i)
                arg_con_scopestr = con_scope_to_str(node.func.con_scope)

                param = func_def.func_args[i]
                assert isinstance(param, AnnCastVar)
                param_name = param.val.name
                param_con_scopestr = con_scope_to_str(
                    node.func.con_scope + [call_con_name]
                )

                # argument and parameter share id, and start with initial version
                id = self.pipeline_state.next_collapsed_id()
                version = VAR_INIT_VERSION

                # build and store GrFN variables for argument and parameter
                arg_grfn_var = create_grfn_var(
                    arg_name, id, version, arg_con_scopestr
                )
                arg_fullid = build_fullid(
                    arg_name, id, version, arg_con_scopestr
                )
                self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
                # store arg_fullid
                node.arg_index_to_fullid[i] = arg_fullid
                # create From Source metadata for the GrFN var
                from_source = False
                from_source_mdata = generate_from_source_metadata(
                    from_source, VariableCreationReason.FUNC_ARG
                )
                add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

                param_grfn_var = create_grfn_var(
                    param_name, id, version, param_con_scopestr
                )
                param_fullid = build_fullid(
                    param_name, id, version, param_con_scopestr
                )
                self.pipeline_state.store_grfn_var(
                    param_fullid, param_grfn_var
                )
                # store param_fullid
                node.param_index_to_fullid[i] = param_fullid
                # create From Source metadata for the GrFN var
                add_metadata_from_name_node(param_grfn_var, param.val)

                # link argument and parameter through top interface
                node.top_interface_in[id] = arg_fullid
                node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After create_call_args_and_params():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def call_top_interface_args_with_no_func_def(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`

        During GrfnAssignmentPass,
        for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
        &#34;&#34;&#34;
        # call container is used to scope parameters
        call_con_name = call_container_name(node)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        for i, n in enumerate(node.arguments):
            # argument name and scope str
            arg_name = call_argument_name(node, i)
            arg_con_scopestr = con_scope_to_str(node.func.con_scope)

            # parameter name and scopestr
            param_name = call_param_name(node, i)
            param_con_scopestr = con_scope_to_str(
                node.func.con_scope + [call_con_name]
            )

            # argument and parameter share id, and start with initial version
            id = self.pipeline_state.next_collapsed_id()
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            # create From Source metadata for the GrFN var
            # when we don&#39;t have the function def, we create a paramter with a default name
            add_metadata_to_grfn_var(param_grfn_var, from_source_mdata)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After create_call_args_and_params():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def populate_call_bot_interface_with_ret_val(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates two GrFN variables for the Call&#39;s return value.
        One is in the interior of the container and links
        to the bot interface in.  The other is outside the container and
        links to the bot interface out.
        &#34;&#34;&#34;
        # Create new GrFN for return value for bot interface in and bot interface out
        var_name = call_ret_val_name(node)
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )

        in_ret_val = create_grfn_var(var_name, id, version, call_con_scopestr)
        in_fullid = build_fullid(var_name, id, version, call_con_scopestr)
        self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_RET_VAL
        )
        add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

        # exterior container scope
        con_scopestr = con_scope_to_str(node.func.con_scope)
        out_ret_val = create_grfn_var(var_name, id, version, con_scopestr)
        out_fullid = build_fullid(var_name, id, version, con_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
        add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

        # store created fullid and grfn_id in node&#39;s ret_val
        node.out_ret_val[id] = out_fullid
        node.in_ret_val[id] = in_fullid
        # link ret values on bot interface
        node.bot_interface_in[id] = in_fullid
        node.bot_interface_out[id] = out_fullid

    def grfn_2_2_call_top_interface_args(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates initial version for each argument and each formal parameter
        Links these argument and parameters through the `top_interface_in` and `top_interface_out`

        During GrfnAssignmentPass,
        for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
        &#34;&#34;&#34;
        # call container is used to scope parameters
        call_con_name = call_container_name(node)

        # create argument and parameter variables
        # argument variables are inputs to the top interface
        # paramter variables are outputs of the top interface
        # if we are generating GrFN 2.2, we would like the parameter to lie in the
        # copied function def container, we do this by aliasing versions during GrfnVarCreation pass
        for i, n in enumerate(node.arguments):
            # argument name and scope str
            arg_name = call_argument_name(node, i)
            arg_con_scopestr = con_scope_to_str(node.func.con_scope)

            # parameter name and scopestr
            param = node.func_def_copy.func_args[i]
            assert isinstance(param, AnnCastVar)
            param_name = param.val.name
            param_con_scopestr = con_scope_to_str(
                node.func.con_scope + [call_con_name]
            )

            # argument and parameter share id, and start with initial version
            id = self.pipeline_state.next_collapsed_id()
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            add_metadata_from_name_node(param_grfn_var, param.val)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After create_call_args_and_params():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)

    def grfn_2_2_call_ret_val_creation(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Creates two GrFN variables for the Call&#39;s return value.
        One is in the interior of the container and links
        to the bot interface in.  The other is outside the container and
        links to the bot interface out.
        &#34;&#34;&#34;
        # Create new GrFN for return value for bot interface in and bot interface out
        var_name = call_ret_val_name(node)
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )

        in_ret_val = create_grfn_var(var_name, id, version, call_con_scopestr)
        in_fullid = build_fullid(var_name, id, version, call_con_scopestr)
        self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_RET_VAL
        )
        add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

        # exterior container scope
        con_scopestr = con_scope_to_str(node.func.con_scope)
        out_ret_val = create_grfn_var(var_name, id, version, con_scopestr)
        out_fullid = build_fullid(var_name, id, version, con_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
        # create From Source metadata for the GrFN var
        add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

        # store created fullid and grfn_id in node&#39;s ret_val
        node.out_ret_val[id] = out_fullid
        node.in_ret_val[id] = in_fullid
        # link ret values on bot interface
        node.bot_interface_in[id] = in_fullid
        node.bot_interface_out[id] = out_fullid

        # also, store the created ret_val in the copied function def
        # this is done so that we can assign to the ret val when
        # parsing return statements
        node.func_def_copy.in_ret_val[id] = in_fullid

    def add_globals_to_grfn_2_2_call_interfaces(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Populates top and bot interface with global variables
          - Adds incoming global variable version to top_interface_in
          - Increments modified globals versions in enclosing scope
          - Adds incremented version to bot_interface_out
          - Creates VAR_INIT_VERSION global variables in Call contianer scope and
            adds them to top_interface_out
          - Creates VAR_INIT_VERSION global variables in copied FunctionDef scope and
            aliases them to their corresponding Call container scope globals
          - Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in
        &#34;&#34;&#34;
        # in the current scope, increment all versions of global variables
        # that are modified by this call
        # the calling container scope is stored in the Call&#39;s AnnCastName node
        calling_scopestr = con_scope_to_str(node.func.con_scope)

        # add globals to exterior interfaces
        # add global variables to top_interface_in
        # these are all used globals
        node.top_interface_vars = node.func_def_copy.used_globals
        self.populate_interface(
            calling_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # the bot interface globals are all modified globals
        node.bot_interface_vars = node.func_def_copy.modified_globals
        # increment versions of all modified global variables
        self.incr_vars_in_con_scope(calling_scopestr, node.bot_interface_vars)
        # add modified globals to bot interface out
        self.populate_interface(
            calling_scopestr, node.bot_interface_vars, node.bot_interface_out
        )

        # add globals to interior interfaces
        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )
        copied_func_scopestr = con_scope_to_str(node.func_def_copy.con_scope)
        # create globals for top_interface_out and bot interface in
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            call_init_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            call_init_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(
                call_init_fullid, call_init_global
            )
            node.top_interface_out[id] = call_init_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(call_init_global, from_source_mdata)

            # alias the func copies init version
            func_copy_init_fullid = build_fullid(
                var_name, id, version, copied_func_scopestr
            )
            self.pipeline_state.alias_grfn_vars(
                func_copy_init_fullid, call_init_fullid
            )

        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            exit_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            exit_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(exit_fullid, exit_global)
            node.bot_interface_in[id] = exit_fullid
            # we intentionally do not add metadata to the GrFN variable here, since
            # the highest version from the copied FunctionDef will be aliased to this
            # variable, and the metadata for this GrFN variable will be populated from
            # that highest version

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After adding globals for GrFN 2.2 call ():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)

    def add_globals_to_call_interfaces(self, node: AnnCastCall):
        &#34;&#34;&#34;
        Populates top and bot interface with global variables
          - Adds incoming global variable version to top_interface_in
          - Increments modified globals versions in enclosing scope
          - Adds incremented version to bot_interface_out
          - Creates VAR_INIT_VERSION global variables and adds to top_interface_out
          - Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in
        &#34;&#34;&#34;
        # in the current scope, increment all versions of global variables
        # that are modified by this call
        # the calling container scope is stored in the Call&#39;s AnnCastName node
        calling_scopestr = con_scope_to_str(node.func.con_scope)
        func_def = self.pipeline_state.func_def_node_from_id(node.func.id)

        # add globals to exterior interfaces
        # top interface globals are globals which are accessed before modification
        node.top_interface_vars = func_def.used_globals

        # add global variables to top_interface_in
        self.populate_interface(
            calling_scopestr, node.top_interface_vars, node.top_interface_in
        )
        # the bot interface globals are all modified globals
        node.bot_interface_vars = func_def.modified_globals
        # increment versions of all modified global variables
        self.incr_vars_in_con_scope(calling_scopestr, node.bot_interface_vars)
        # add modified globals to bot interface out
        self.populate_interface(
            calling_scopestr, node.bot_interface_vars, node.bot_interface_out
        )

        # add globals to interior interfaces
        # interior container scope
        call_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_container_name(node)]
        )
        # create globals for top_interface_out and bot interface in
        # by convention the top interface produces version VAR_INIT_VERSION variables
        # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
        for id, var_name in node.top_interface_vars.items():
            version = VAR_INIT_VERSION
            init_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            init_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(init_fullid, init_global)
            node.top_interface_out[id] = init_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.TOP_IFACE_INTRO
            )
            add_metadata_to_grfn_var(init_global, from_source_mdata)

        for id, var_name in node.bot_interface_vars.items():
            version = VAR_EXIT_VERSION
            exit_fullid = build_fullid(
                var_name, id, version, call_con_scopestr
            )
            exit_global = create_grfn_var(
                var_name, id, version, call_con_scopestr
            )
            self.pipeline_state.store_grfn_var(exit_fullid, exit_global)
            node.bot_interface_in[id] = exit_fullid
            # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
            from_source = (
                True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
            )
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.BOT_IFACE_INTRO
            )
            add_metadata_to_grfn_var(exit_global, from_source_mdata)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(&#34;After adding globals for GrFN 2.3 call ():&#34;)
            print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
            print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)

    def visit(self, node: AnnCastNode, assign_lhs: bool):
        # print current node being visited.
        # this can be useful for debugging
        # class_name = node.__class__.__name__
        # print(f&#34;\nProcessing node type {class_name}&#34;)
        return self._visit(node, assign_lhs)

    @singledispatchmethod
    def _visit(self, node: AnnCastNode, assign_lhs: bool):
        &#34;&#34;&#34;
        Visit each AnnCastNode
        Parameters:
          - `assign_lhs`: this denotes whether we are visiting the LHS or RHS of an AnnCastAssignment
                      This is used to determine whether a variable (AnnCastName node) is
                      accessed or modified in that context
        &#34;&#34;&#34;
        raise Exception(f&#34;Unimplemented AST node of type: {type(node)}&#34;)

    def visit_node_list(self, node_list: typing.List[AnnCastNode], assign_lhs):
        return [self.visit(node, assign_lhs) for node in node_list]

    @_visit.register
    def visit_assignment(self, node: AnnCastAssignment, assign_lhs: bool):
        self.visit(node.right, assign_lhs)
        # The AnnCastTuple is added to handle scenarios where an assignment
        # is made by assigning to a tuple of values, as opposed to one singular value
        assert (
            isinstance(node.left, AnnCastVar)
            or (isinstance(node.left, AnnCastLiteralValue) and (node.left.value_type == StructureType.TUPLE))
            or isinstance(node.left, AnnCastAssignment)
            or isinstance(node.left, AnnCastAttribute) or isinstance(node.left, AnnCastCall)
        ), f&#34;container_scope: visit_assigment: node.left is {type(node.left)}&#34;
        self.visit(node.left, True)

    @_visit.register
    def visit_attribute(self, node: AnnCastAttribute, assign_lhs: bool):
        pass

    @_visit.register
    def visit_call(self, node: AnnCastCall, assign_lhs: bool):
        assert isinstance(node.func, AnnCastName) or isinstance(
            node.func, AnnCastAttribute
        )

        if node.is_grfn_2_2:
            self.visit_call_grfn_2_2(node, assign_lhs)
            return

        self.visit_node_list(node.arguments, assign_lhs)
        # populate call nodes&#39;s top interface with arguments
        # The pattern for the top interface is as follows:
        # For each argument, we create a GrFN variable using the arguments index
        # E.g. Arg0, Arg1, ...
        # top interface inputs: Arg0, Arg1,...
        # top interface outputs: Param0, Param1, ...
        # if this Call has a FunctionDef, then we can fill in correct paramter names
        # if it doesn&#39;t we need to provide default parameter names
        # if we have the FunctionDef for the call, we can also add globals to the interfaces
        if node.has_func_def:
            self.call_top_interface_args_with_func_def(node)
            self.add_globals_to_call_interfaces(node)
            func_node = node.func.id
            func_def_node = self.pipeline_state.func_def_node_from_id(
                func_node
            )
            node.has_ret_val = func_def_node.has_ret_val
        # if we do not have the FunctionDef, we will not add any globals to the interfaces
        else:
            self.call_top_interface_args_with_no_func_def(node)

        # add return value to bot interface out
        if node.has_ret_val:
            self.populate_call_bot_interface_with_ret_val(node)

    def visit_call_grfn_2_2(self, node: AnnCastCall, assign_lhs: bool):
        assert isinstance(node.func, AnnCastName)
        self.visit_node_list(node.arguments, assign_lhs)
        # populate call nodes&#39;s top interface with arguments
        # The pattern for the top interface is as follows:
        # For each argument, we create a GrFN variable using the arguments index
        # E.g. Arg0, Arg1, ...
        # top interface inputs: Arg0, Arg1,...
        # top interface outputs: NamedParam0, NamedParam1, ...
        self.grfn_2_2_call_top_interface_args(node)

        node.has_ret_val = node.func_def_copy.has_ret_val
        # add return value to bot interface out if function_copy has a ret_val
        if node.func_def_copy.has_ret_val:
            self.grfn_2_2_call_ret_val_creation(node)

        # we visit the function def copy to version globals appearing in its body
        call_assign_lhs = False
        self.visit_function_def_copy(node.func_def_copy, call_assign_lhs)

        # add globals to call interface
        self.add_globals_to_grfn_2_2_call_interfaces(node)

    @_visit.register
    def visit_record_def(self, node: AnnCastRecordDef, assign_lhs: bool):
        # Visit the function defs within this class to make sure
        # Everything is versioned correctly
        self.visit_node_list(node.funcs, assign_lhs)

    def visit_function_def_copy(
        self, node: AnnCastFunctionDef, assign_lhs: bool
    ):
        &#34;&#34;&#34;
        Used for GrFN 2.2 Generation
        &#34;&#34;&#34;
        # Initialize scope_to_highest_var_vers
        con_scopestr = con_scope_to_str(node.con_scope)
        # create VAR_INIT_VERSION of any modified or accessed variables
        self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())

        # visit children
        self.visit_node_list(node.func_args, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)

        # store highest var version
        node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
            con_scopestr
        ]

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor FUNCTION COPY: {con_scopestr}&#34;)
            print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)

    @_visit.register
    def visit_function_def(self, node: AnnCastFunctionDef, assign_lhs: bool):
        # Initialize scope_to_highest_var_vers
        con_scopestr = con_scope_to_str(node.con_scope)
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())

        # visit children
        self.visit_node_list(node.func_args, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)

        # store highest var version
        node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
            con_scopestr
        ]

        # populate FunctionDef nodes&#39;s top interface with arguments
        # The pattern for the top interface is as follows:
        # For each argument, we create a GrFN variable using the arguments index
        # E.g. Arg0, Arg1, ...
        # top interface inputs: Arg0, Arg1,...
        # top interface outputs: NamedParam0, NamedParam1, ...
        self.func_def_top_interface_args(node)

        # add return value to bot interface out if functiondef has a ret_val
        if node.has_ret_val:
            self.func_def_ret_val_creation(node)

        # add globals to functiondef integfaces
        if is_func_def_main(node):
            self.add_globals_to_main_func_def_interfaces(node)
        else:
            self.add_globals_to_non_main_func_def_interfaces(node)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor FUNCTION: {con_scopestr}&#34;)
            print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)

    @_visit.register
    def visit_literal_value(self, node: AnnCastLiteralValue, assign_side):
        if node.value_type == &#34;List[Any]&#34;:
            # val has
            # operator - string
            # size - Var node or a LiteralValue node (for number)
            # initial_value - LiteralValue node
            val = node.value

            # visit size&#39;s anncast name node
            self.visit(val.size, assign_side)

            # List literal doesn&#39;t need to add any other changes
            # to the anncast at this pass

        elif node.value_type == StructureType.TUPLE: # or node.value_type == StructureType.LIST:
            self.visit_node_list(node.value, assign_side)
        elif node.value_type == ScalarType.INTEGER:
            pass
        elif node.value_type == ScalarType.ABSTRACTFLOAT:
            pass
        pass

    @_visit.register
    def visit_loop(self, node: AnnCastLoop, assign_lhs: bool):
        # Initialize scope_to_highest_var_version
        if len(node.pre) &gt; 0:
            pre_scopestr = con_scope_to_str(node.con_scope + [LOOPPRE])
        expr_scopestr = con_scope_to_str(node.con_scope + [LOOPEXPR])
        body_scopestr = con_scope_to_str(node.con_scope + [LOOPBODY])
        if len(node.post) &gt; 0:
            post_scopestr = con_scope_to_str(node.con_scope + [LOOPPOST])

        # Initialize LoopInit
        # create versions 0 of any modified or accessed variables
        if len(node.pre) &gt; 0:
            self.init_highest_var_vers_dict(
                pre_scopestr, node.used_vars.keys()
            )

        # Initialize LoopExpr
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(expr_scopestr, node.used_vars.keys())

        # Initialize LoopBody
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(body_scopestr, node.used_vars.keys())

        # Initialize LoopPost
        if len(node.post) &gt; 0:
            self.init_highest_var_vers_dict(
                post_scopestr, node.used_vars.keys()
            )

        ######## visit children ########
        if len(node.pre) &gt; 0:
            self.visit_node_list(node.pre, assign_lhs)

        self.visit(node.expr, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)

        if len(node.post) &gt; 0:
            self.visit_node_list(node.post, assign_lhs)

        # print(node.used_vars)

        # store highest var version
        if len(node.pre) &gt; 0:
            node.pre_highest_var_vers = self.con_scope_to_highest_var_vers[
                pre_scopestr
            ]

        node.expr_highest_var_vers = self.con_scope_to_highest_var_vers[
            expr_scopestr
        ]
        node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
            body_scopestr
        ]

        if len(node.post) &gt; 0:
            node.post_highest_var_vers = self.con_scope_to_highest_var_vers[
                post_scopestr
            ]

        # populate all of this loops interfaces
        self.populate_loop_interfaces(node)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor LOOP: {con_scope_to_str(node.con_scope)}&#34;)
            if len(node.pre) &gt; 0:
                print(f&#34;  PreHighestVers: {node.pre_highest_var_vers}&#34;)
            print(f&#34;  ExprHighestVers: {node.expr_highest_var_vers}&#34;)
            print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)
            if len(node.Post) &gt; 0:
                print(f&#34;  PostHighestVers: {node.post_highest_var_vers}&#34;)

    @_visit.register
    def visit_model_break(self, node: AnnCastModelBreak, assign_lhs: bool):
        pass

    @_visit.register
    def visit_model_continue(
        self, node: AnnCastModelContinue, assign_lhs: bool
    ):
        pass

    @_visit.register
    def visit_model_import(self, node: AnnCastModelImport, assign_lhs: bool):
        pass

    @_visit.register
    def visit_model_if(self, node: AnnCastModelIf, assign_lhs: bool):
        # Initialize scope_to_highest_var_version
        expr_scopestr = con_scope_to_str(node.con_scope + [IFEXPR])
        ifbody_scopestr = con_scope_to_str(node.con_scope + [IFBODY])
        elsebody_scopestr = con_scope_to_str(node.con_scope + [ELSEBODY])
        # initialize IfExpr
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(expr_scopestr, node.used_vars.keys())

        # initialize IfBody
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(ifbody_scopestr, node.used_vars.keys())

        # initialize ElseBody
        # create versions 0 of any modified or accessed variables
        self.init_highest_var_vers_dict(
            elsebody_scopestr, node.used_vars.keys()
        )

        # visit children
        self.visit(node.expr, assign_lhs)
        self.visit_node_list(node.body, assign_lhs)
        self.visit_node_list(node.orelse, assign_lhs)

        # store highest var versions
        node.expr_highest_var_vers = self.con_scope_to_highest_var_vers[
            expr_scopestr
        ]
        node.ifbody_highest_var_vers = self.con_scope_to_highest_var_vers[
            ifbody_scopestr
        ]
        node.elsebody_highest_var_vers = self.con_scope_to_highest_var_vers[
            elsebody_scopestr
        ]

        # populate interfaces
        self.populate_model_if_interfaces(node)

        # DEBUG printing
        if self.pipeline_state.PRINT_DEBUGGING_INFO:
            print(f&#34;\nFor IF: {con_scope_to_str(node.con_scope)}&#34;)
            print(f&#34;  ExprHighestVers: {node.expr_highest_var_vers}&#34;)
            print(f&#34;  IfBodyHighestVers: {node.ifbody_highest_var_vers}&#34;)
            print(f&#34;  ElseBodyHighestVers: {node.elsebody_highest_var_vers}&#34;)

    @_visit.register
    def visit_return(self, node: AnnCastModelReturn, assign_lhs: bool):
        self.visit(node.value, assign_lhs)

    @_visit.register
    def visit_module(self, node: AnnCastModule, assign_lhs: bool):
        con_scopestr = con_scope_to_str(node.con_scope)
        # create VAR_INIT_VERSION of any modified or accessed variables
        self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())
        self.visit_node_list(node.body, assign_lhs)

    @_visit.register
    def visit_name(self, node: AnnCastName, assign_lhs: bool):
        con_scopestr = con_scope_to_str(node.con_scope)
        if assign_lhs:
            self.incr_version_in_con_scope(con_scopestr, node.id, node.name)

        node.version = self.get_highest_ver_in_con_scope(con_scopestr, node.id)

    @_visit.register
    def visit_operator(self, node: AnnCastOperator, assign_lhs: bool):
        # visit operands
        self.visit_node_list(node.operands, assign_lhs)

    @_visit.register
    def visit_set(self, node: AnnCastSet, assign_lhs: bool):
        pass

    @_visit.register
    def visit_tuple(self, node: AnnCastTuple, assign_lhs: bool):
        self.visit_node_list(node.values, assign_lhs)

    @_visit.register
    def visit_var(self, node: AnnCastVar, assign_lhs: bool):
        self.visit(node.val, assign_lhs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_default_bot_interface_metadata"><code class="name flex">
<span>def <span class="ident">add_default_bot_interface_metadata</span></span>(<span>self, interface_vars)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a bot interface metadata to interface_vars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_default_bot_interface_metadata(self, interface_vars):
    &#34;&#34;&#34;
    Adds a bot interface metadata to interface_vars
    &#34;&#34;&#34;
    for fullid in interface_vars.values():
        grfn_var = self.pipeline_state.get_grfn_var(fullid)
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.BOT_IFACE_INTRO
        )
        add_metadata_to_grfn_var(
            grfn_var, from_source_mdata=from_source_mdata
        )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_call_interfaces"><code class="name flex">
<span>def <span class="ident">add_globals_to_call_interfaces</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Populates top and bot interface with global variables
- Adds incoming global variable version to top_interface_in
- Increments modified globals versions in enclosing scope
- Adds incremented version to bot_interface_out
- Creates VAR_INIT_VERSION global variables and adds to top_interface_out
- Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_globals_to_call_interfaces(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Populates top and bot interface with global variables
      - Adds incoming global variable version to top_interface_in
      - Increments modified globals versions in enclosing scope
      - Adds incremented version to bot_interface_out
      - Creates VAR_INIT_VERSION global variables and adds to top_interface_out
      - Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in
    &#34;&#34;&#34;
    # in the current scope, increment all versions of global variables
    # that are modified by this call
    # the calling container scope is stored in the Call&#39;s AnnCastName node
    calling_scopestr = con_scope_to_str(node.func.con_scope)
    func_def = self.pipeline_state.func_def_node_from_id(node.func.id)

    # add globals to exterior interfaces
    # top interface globals are globals which are accessed before modification
    node.top_interface_vars = func_def.used_globals

    # add global variables to top_interface_in
    self.populate_interface(
        calling_scopestr, node.top_interface_vars, node.top_interface_in
    )
    # the bot interface globals are all modified globals
    node.bot_interface_vars = func_def.modified_globals
    # increment versions of all modified global variables
    self.incr_vars_in_con_scope(calling_scopestr, node.bot_interface_vars)
    # add modified globals to bot interface out
    self.populate_interface(
        calling_scopestr, node.bot_interface_vars, node.bot_interface_out
    )

    # add globals to interior interfaces
    # interior container scope
    call_con_scopestr = con_scope_to_str(
        node.func.con_scope + [call_container_name(node)]
    )
    # create globals for top_interface_out and bot interface in
    # by convention the top interface produces version VAR_INIT_VERSION variables
    # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
    for id, var_name in node.top_interface_vars.items():
        version = VAR_INIT_VERSION
        init_fullid = build_fullid(
            var_name, id, version, call_con_scopestr
        )
        init_global = create_grfn_var(
            var_name, id, version, call_con_scopestr
        )
        self.pipeline_state.store_grfn_var(init_fullid, init_global)
        node.top_interface_out[id] = init_fullid
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.TOP_IFACE_INTRO
        )
        add_metadata_to_grfn_var(init_global, from_source_mdata)

    for id, var_name in node.bot_interface_vars.items():
        version = VAR_EXIT_VERSION
        exit_fullid = build_fullid(
            var_name, id, version, call_con_scopestr
        )
        exit_global = create_grfn_var(
            var_name, id, version, call_con_scopestr
        )
        self.pipeline_state.store_grfn_var(exit_fullid, exit_global)
        node.bot_interface_in[id] = exit_fullid
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.BOT_IFACE_INTRO
        )
        add_metadata_to_grfn_var(exit_global, from_source_mdata)

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(&#34;After adding globals for GrFN 2.3 call ():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_grfn_2_2_call_interfaces"><code class="name flex">
<span>def <span class="ident">add_globals_to_grfn_2_2_call_interfaces</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Populates top and bot interface with global variables
- Adds incoming global variable version to top_interface_in
- Increments modified globals versions in enclosing scope
- Adds incremented version to bot_interface_out
- Creates VAR_INIT_VERSION global variables in Call contianer scope and
adds them to top_interface_out
- Creates VAR_INIT_VERSION global variables in copied FunctionDef scope and
aliases them to their corresponding Call container scope globals
- Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_globals_to_grfn_2_2_call_interfaces(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Populates top and bot interface with global variables
      - Adds incoming global variable version to top_interface_in
      - Increments modified globals versions in enclosing scope
      - Adds incremented version to bot_interface_out
      - Creates VAR_INIT_VERSION global variables in Call contianer scope and
        adds them to top_interface_out
      - Creates VAR_INIT_VERSION global variables in copied FunctionDef scope and
        aliases them to their corresponding Call container scope globals
      - Creates VAR_EXIT_VERSION global variables and adds to bot_interface_in
    &#34;&#34;&#34;
    # in the current scope, increment all versions of global variables
    # that are modified by this call
    # the calling container scope is stored in the Call&#39;s AnnCastName node
    calling_scopestr = con_scope_to_str(node.func.con_scope)

    # add globals to exterior interfaces
    # add global variables to top_interface_in
    # these are all used globals
    node.top_interface_vars = node.func_def_copy.used_globals
    self.populate_interface(
        calling_scopestr, node.top_interface_vars, node.top_interface_in
    )
    # the bot interface globals are all modified globals
    node.bot_interface_vars = node.func_def_copy.modified_globals
    # increment versions of all modified global variables
    self.incr_vars_in_con_scope(calling_scopestr, node.bot_interface_vars)
    # add modified globals to bot interface out
    self.populate_interface(
        calling_scopestr, node.bot_interface_vars, node.bot_interface_out
    )

    # add globals to interior interfaces
    # interior container scope
    call_con_scopestr = con_scope_to_str(
        node.func.con_scope + [call_container_name(node)]
    )
    copied_func_scopestr = con_scope_to_str(node.func_def_copy.con_scope)
    # create globals for top_interface_out and bot interface in
    # by convention the top interface produces version VAR_INIT_VERSION variables
    # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
    for id, var_name in node.top_interface_vars.items():
        version = VAR_INIT_VERSION
        call_init_fullid = build_fullid(
            var_name, id, version, call_con_scopestr
        )
        call_init_global = create_grfn_var(
            var_name, id, version, call_con_scopestr
        )
        self.pipeline_state.store_grfn_var(
            call_init_fullid, call_init_global
        )
        node.top_interface_out[id] = call_init_fullid
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.TOP_IFACE_INTRO
        )
        add_metadata_to_grfn_var(call_init_global, from_source_mdata)

        # alias the func copies init version
        func_copy_init_fullid = build_fullid(
            var_name, id, version, copied_func_scopestr
        )
        self.pipeline_state.alias_grfn_vars(
            func_copy_init_fullid, call_init_fullid
        )

    for id, var_name in node.bot_interface_vars.items():
        version = VAR_EXIT_VERSION
        exit_fullid = build_fullid(
            var_name, id, version, call_con_scopestr
        )
        exit_global = create_grfn_var(
            var_name, id, version, call_con_scopestr
        )
        self.pipeline_state.store_grfn_var(exit_fullid, exit_global)
        node.bot_interface_in[id] = exit_fullid
        # we intentionally do not add metadata to the GrFN variable here, since
        # the highest version from the copied FunctionDef will be aliased to this
        # variable, and the metadata for this GrFN variable will be populated from
        # that highest version

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(&#34;After adding globals for GrFN 2.2 call ():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_main_func_def_interfaces"><code class="name flex">
<span>def <span class="ident">add_globals_to_main_func_def_interfaces</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef">AnnCastFunctionDef</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Populates top and bot interface of main FunctionDef with global variables
- Adds incoming global variable version to top_interface_in
- Increments modified globals versions in enclosing scope
- Adds incremented version to bot_interface_out
- Creates VAR_INIT_VERSION global variables and adds to top_interface_out
- Add <code>body_highest_var_vers</code> global variables to bot_interface_in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_globals_to_main_func_def_interfaces(
    self, node: AnnCastFunctionDef
):
    &#34;&#34;&#34;
    Populates top and bot interface of main FunctionDef with global variables
      - Adds incoming global variable version to top_interface_in
      - Increments modified globals versions in enclosing scope
      - Adds incremented version to bot_interface_out
      - Creates VAR_INIT_VERSION global variables and adds to top_interface_out
      - Add `body_highest_var_vers` global variables to bot_interface_in
    &#34;&#34;&#34;
    # in the enclosing scope, increment all versions of global variables
    # that are modified by main
    enclosing_con_scope = node.con_scope[:-1]
    enclosing_scopestr = con_scope_to_str(enclosing_con_scope)

    # add globals to exterior interfaces
    # add global variables to top_interface_in these are all used globals
    node.top_interface_vars = node.used_globals
    self.populate_interface(
        enclosing_scopestr, node.top_interface_vars, node.top_interface_in
    )
    # the bot interface globals are all modified globals
    node.bot_interface_vars = node.modified_globals
    # increment versions of all modified global variables
    self.incr_vars_in_con_scope(
        enclosing_scopestr, node.bot_interface_vars
    )
    # add modified globals to bot interface out
    self.populate_interface(
        enclosing_scopestr, node.bot_interface_vars, node.bot_interface_out
    )

    # add globals to interior interfaces
    # interior container scope
    func_scopestr = con_scope_to_str(node.con_scope)
    # create globals for top_interface_out and bot interface in
    # by convention the top interface produces version VAR_INIT_VERSION variables
    # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
    for id, var_name in node.top_interface_vars.items():
        version = VAR_INIT_VERSION
        init_fullid = build_fullid(var_name, id, version, func_scopestr)
        init_global = create_grfn_var(var_name, id, version, func_scopestr)
        self.pipeline_state.store_grfn_var(init_fullid, init_global)
        node.top_interface_out[id] = init_fullid
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.TOP_IFACE_INTRO
        )
        add_metadata_to_grfn_var(init_global, from_source_mdata)

    # we do not create the GrFN VariableNode for the highest version global
    # here, since it is done while visitng Assignment node during GrfnVarCreation pass
    for id, var_name in node.bot_interface_vars.items():
        version = node.body_highest_var_vers[id]
        exit_fullid = build_fullid(var_name, id, version, func_scopestr)
        node.bot_interface_in[id] = exit_fullid

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;For FunctionDef {node.name.name}&#34;)
        print(&#34;\tAfter add_globals_to_main_func_def_interfaces():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_non_main_func_def_interfaces"><code class="name flex">
<span>def <span class="ident">add_globals_to_non_main_func_def_interfaces</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef">AnnCastFunctionDef</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Populates top and bot interface of FunctionDef with global variables
For each global, we make an addtional global whose name is specialized to
this function.
This is to separate the globals that "main" uses
from the globals that are used in other FunctionDef's because of main's
special role.
- Creates VAR_INIT_VERSION version for each specialized global and
Links these specialized globals through the <code>top_interface_in</code> and <code>top_interface_out</code>
- Creates VAR_EXIT_VERSION version for each specialized global and
Links these specialized globals through the <code>bot_interface_in</code> and <code>bot_interface_out</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_globals_to_non_main_func_def_interfaces(
    self, node: AnnCastFunctionDef
):
    &#34;&#34;&#34;
    Populates top and bot interface of FunctionDef with global variables
    For each global, we make an addtional global whose name is specialized to
    this function.  This is to separate the globals that &#34;main&#34; uses
    from the globals that are used in other FunctionDef&#39;s because of main&#39;s
    special role.
      - Creates VAR_INIT_VERSION version for each specialized global and
        Links these specialized globals through the `top_interface_in` and `top_interface_out`
      - Creates VAR_EXIT_VERSION version for each specialized global and
        Links these specialized globals through the `bot_interface_in` and `bot_interface_out`
    &#34;&#34;&#34;
    enclosing_con_scope = node.con_scope[:-1]
    enclosing_scopestr = con_scope_to_str(enclosing_con_scope)
    # interior container scope
    func_scopestr = con_scope_to_str(node.con_scope)

    # add global variables to top_interface_in
    # these are all used globals
    node.top_interface_vars = node.used_globals
    # the bot interface globals are all modified globals
    node.bot_interface_vars = node.modified_globals

    # we create specialized globals for this function def, in the enclosing scope.
    # this is to accomodate interfaces, since they expect the same id
    # on either side
    # this is similar to how we handle arguments from enclosing scope linking to
    # parameters in the interior of a container

    # create specialized globals for top interface
    # by convention the top interface produces version VAR_INIT_VERSION variables
    version = VAR_INIT_VERSION
    for id, var_name in node.top_interface_vars.items():
        # exterior specialized top global
        specialized_name = specialized_global_name(node, var_name)
        in_fullid = build_fullid(
            specialized_name, id, version, enclosing_scopestr
        )
        in_global = create_grfn_var(
            specialized_name, id, version, enclosing_scopestr
        )
        self.pipeline_state.store_grfn_var(in_fullid, in_global)
        node.top_interface_in[id] = in_fullid
        # create From Source metadata for the GrFN var
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.DUP_GLOBAL
        )
        add_metadata_to_grfn_var(in_global, from_source_mdata)
        # interior top global
        out_fullid = build_fullid(var_name, id, version, func_scopestr)
        out_global = create_grfn_var(var_name, id, version, func_scopestr)
        self.pipeline_state.store_grfn_var(out_fullid, out_global)
        node.top_interface_out[id] = out_fullid
        # create From Source metadata for the GrFN var
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.TOP_IFACE_INTRO
        )
        add_metadata_to_grfn_var(in_global, from_source_mdata)

    # create specialized globals for bot interface
    # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
    for id, var_name in node.bot_interface_vars.items():
        # interior bot global
        # we do not create the GrFN VariableNode for the highest version global
        # here, since it is done while visitng Assignment node during GrfnVarCreation pass
        version = node.body_highest_var_vers[id]
        in_fullid = build_fullid(var_name, id, version, func_scopestr)
        node.bot_interface_in[id] = in_fullid
        # exterior specialized bot global
        version = VAR_EXIT_VERSION
        specialized_name = specialized_global_name(node, var_name)
        out_fullid = build_fullid(
            specialized_name, id, version, enclosing_scopestr
        )
        out_global = create_grfn_var(
            specialized_name, id, version, enclosing_scopestr
        )
        self.pipeline_state.store_grfn_var(out_fullid, out_global)
        node.bot_interface_out[id] = out_fullid
        # create From Source metadata for the GrFN var
        # See comment above declaration for `FROM_SOURCE_FOR_GE` in annotated_cast.py
        from_source = (
            True if self.pipeline_state.FROM_SOURCE_FOR_GE else False
        )
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.DUP_GLOBAL
        )
        add_metadata_to_grfn_var(out_global, from_source_mdata)

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;For FunctionDef {node.name.name}&#34;)
        print(&#34;\tAfter add_globals_to_non_main_func_def_interfaces():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)
        print(f&#34;\ttop_interface_vars = {node.top_interface_vars}&#34;)
        print(f&#34;\tbot_interface_in = {node.bot_interface_in}&#34;)
        print(f&#34;\tbot_interface_out = {node.bot_interface_out}&#34;)
        print(f&#34;\tbot_interface_vars = {node.bot_interface_vars}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.call_top_interface_args_with_func_def"><code class="name flex">
<span>def <span class="ident">call_top_interface_args_with_func_def</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates initial version for each argument and each formal parameter
Links these argument and parameters through the <code>top_interface_in</code> and <code>top_interface_out</code></p>
<p>During GrfnAssignmentPass,
for each argument, creates a <code>GrfnAssignment</code> which stores the assignment <code>LambdaNode</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_top_interface_args_with_func_def(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Creates initial version for each argument and each formal parameter
    Links these argument and parameters through the `top_interface_in` and `top_interface_out`

    During GrfnAssignmentPass,
    for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
    &#34;&#34;&#34;
    # call container is used to scope parameters
    call_con_name = call_container_name(node)

    # create argument and parameter variables
    # argument variables are inputs to the top interface
    # paramter variables are outputs of the top interface
    for i, n in enumerate(node.arguments):
        # parameter name and scopestr
        func_def = self.pipeline_state.func_def_node_from_id(node.func.id)
        if i &lt; len(func_def.func_args):  # NOTE: M7 Placeholder
            # argument name and scope str
            arg_name = call_argument_name(node, i)
            arg_con_scopestr = con_scope_to_str(node.func.con_scope)

            param = func_def.func_args[i]
            assert isinstance(param, AnnCastVar)
            param_name = param.val.name
            param_con_scopestr = con_scope_to_str(
                node.func.con_scope + [call_con_name]
            )

            # argument and parameter share id, and start with initial version
            id = self.pipeline_state.next_collapsed_id()
            version = VAR_INIT_VERSION

            # build and store GrFN variables for argument and parameter
            arg_grfn_var = create_grfn_var(
                arg_name, id, version, arg_con_scopestr
            )
            arg_fullid = build_fullid(
                arg_name, id, version, arg_con_scopestr
            )
            self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
            # store arg_fullid
            node.arg_index_to_fullid[i] = arg_fullid
            # create From Source metadata for the GrFN var
            from_source = False
            from_source_mdata = generate_from_source_metadata(
                from_source, VariableCreationReason.FUNC_ARG
            )
            add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

            param_grfn_var = create_grfn_var(
                param_name, id, version, param_con_scopestr
            )
            param_fullid = build_fullid(
                param_name, id, version, param_con_scopestr
            )
            self.pipeline_state.store_grfn_var(
                param_fullid, param_grfn_var
            )
            # store param_fullid
            node.param_index_to_fullid[i] = param_fullid
            # create From Source metadata for the GrFN var
            add_metadata_from_name_node(param_grfn_var, param.val)

            # link argument and parameter through top interface
            node.top_interface_in[id] = arg_fullid
            node.top_interface_out[id] = param_fullid

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(&#34;After create_call_args_and_params():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.call_top_interface_args_with_no_func_def"><code class="name flex">
<span>def <span class="ident">call_top_interface_args_with_no_func_def</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates initial version for each argument and each formal parameter
Links these argument and parameters through the <code>top_interface_in</code> and <code>top_interface_out</code></p>
<p>During GrfnAssignmentPass,
for each argument, creates a <code>GrfnAssignment</code> which stores the assignment <code>LambdaNode</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_top_interface_args_with_no_func_def(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Creates initial version for each argument and each formal parameter
    Links these argument and parameters through the `top_interface_in` and `top_interface_out`

    During GrfnAssignmentPass,
    for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
    &#34;&#34;&#34;
    # call container is used to scope parameters
    call_con_name = call_container_name(node)

    # create argument and parameter variables
    # argument variables are inputs to the top interface
    # paramter variables are outputs of the top interface
    for i, n in enumerate(node.arguments):
        # argument name and scope str
        arg_name = call_argument_name(node, i)
        arg_con_scopestr = con_scope_to_str(node.func.con_scope)

        # parameter name and scopestr
        param_name = call_param_name(node, i)
        param_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_con_name]
        )

        # argument and parameter share id, and start with initial version
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # build and store GrFN variables for argument and parameter
        arg_grfn_var = create_grfn_var(
            arg_name, id, version, arg_con_scopestr
        )
        arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
        self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
        # store arg_fullid
        node.arg_index_to_fullid[i] = arg_fullid
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_ARG
        )
        add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

        param_grfn_var = create_grfn_var(
            param_name, id, version, param_con_scopestr
        )
        param_fullid = build_fullid(
            param_name, id, version, param_con_scopestr
        )
        self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
        # store param_fullid
        node.param_index_to_fullid[i] = param_fullid
        # create From Source metadata for the GrFN var
        # when we don&#39;t have the function def, we create a paramter with a default name
        add_metadata_to_grfn_var(param_grfn_var, from_source_mdata)

        # link argument and parameter through top interface
        node.top_interface_in[id] = arg_fullid
        node.top_interface_out[id] = param_fullid

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(&#34;After create_call_args_and_params():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.fix_for_python_gcc_declaration_distinction"><code class="name flex">
<span>def <span class="ident">fix_for_python_gcc_declaration_distinction</span></span>(<span>self, con_scopestr, id, var_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function adds a dummy GrfnAssignment to <code>None</code> for variable with id <code>id</code>
in the container for con_scopestr</p>
<p>The motivation for this is the difference between how the gcc and Python handle
variable declaration.</p>
<p>For gcc, all variable declaration are placed at the top
of the enclosing FunctionDef.
Currently, we rely on this for If and Loop container
top interfaces.</p>
<p>The Python AST follows Python semantics, and variables are introduced inline dynamically.
This leads to many challenges creating interfaces e.g.</p>
<pre><code class="language-python">def func():
    x = 5
    if x == 5:
        z = 3
</code></pre>
<p>In this code example, what happens to z along the else branch?
GrFN If containers always make a
selection between two values, but this does not align with dynamic/conditional variable creation in Python,
as in the above code example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_for_python_gcc_declaration_distinction(
    self, con_scopestr, id, var_name
):
    &#34;&#34;&#34;
    This function adds a dummy GrfnAssignment to `None` for variable with id `id`
    in the container for con_scopestr

    The motivation for this is the difference between how the gcc and Python handle
    variable declaration.

    For gcc, all variable declaration are placed at the top
    of the enclosing FunctionDef.  Currently, we rely on this for If and Loop container
    top interfaces.

    The Python AST follows Python semantics, and variables are introduced inline dynamically.
    This leads to many challenges creating interfaces e.g.

    ```python
    def func():
        x = 5
        if x == 5:
            z = 3
    ```
    In this code example, what happens to z along the else branch?  GrFN If containers always make a
    selection between two values, but this does not align with dynamic/conditional variable creation in Python,
    as in the above code example.
    &#34;&#34;&#34;
    version = self.con_scope_to_highest_var_vers[con_scopestr][id]
    # this function should only be called in cases where we need to implement a dummy assignment
    # which creates a version 1 variable
    assert version == VAR_INIT_VERSION
    # increment the version, and create an GrFN variable for the incremented version
    self.incr_version_in_con_scope(con_scopestr, id, var_name)
    new_version = self.con_scope_to_highest_var_vers[con_scopestr][id]
    new_fullid = build_fullid(var_name, id, new_version, con_scopestr)
    grfn_var = self.pipeline_state.get_grfn_var(new_fullid)
    from_source_mdata = generate_from_source_metadata(
        False, VariableCreationReason.DUMMY_ASSIGN
    )
    add_metadata_to_grfn_var(grfn_var, from_source_mdata)

    # create a literal GrFN assignment for this dummy assignment
    assign_metadata = create_lambda_node_metadata(source_refs=[])
    literal_node = create_grfn_literal_node(assign_metadata)
    lambda_expr = &#34;lambda: None&#34;
    literal_node.func_str = lambda_expr
    literal_node.function = load_lambda_function(literal_node.func_str)
    dummy_assignment = GrfnAssignment(
        literal_node, LambdaType.LITERAL, lambda_expr=lambda_expr
    )
    dummy_assignment.outputs[new_fullid] = grfn_var.uid

    # add dummy assignment to function def node
    assert self.pipeline_state.is_con_scopestr_func_def(con_scopestr)
    func_def_node = self.pipeline_state.func_def_node_from_scopestr(
        con_scopestr
    )

    func_def_node.dummy_grfn_assignments.append(dummy_assignment)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.func_def_ret_val_creation"><code class="name flex">
<span>def <span class="ident">func_def_ret_val_creation</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef">AnnCastFunctionDef</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates two GrFN variables for the FunctionDef's return value.
One is in the interior of the container and links
to the bot interface in.
The other is outside the container and
links to the bot interface out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def func_def_ret_val_creation(self, node: AnnCastFunctionDef):
    &#34;&#34;&#34;
    Creates two GrFN variables for the FunctionDef&#39;s return value.
    One is in the interior of the container and links
    to the bot interface in.  The other is outside the container and
    links to the bot interface out.
    &#34;&#34;&#34;
    # Create new GrFN for return value for bot interface in and bot interface out
    var_name = func_def_ret_val_name(node)
    id = self.pipeline_state.next_collapsed_id()
    version = VAR_INIT_VERSION

    # interior container scope
    func_scopestr = con_scope_to_str(node.con_scope)

    in_ret_val = create_grfn_var(var_name, id, version, func_scopestr)
    in_fullid = build_fullid(var_name, id, version, func_scopestr)
    self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
    # create From Source metadata for the GrFN var
    from_source = False
    from_source_mdata = generate_from_source_metadata(
        from_source, VariableCreationReason.FUNC_RET_VAL
    )
    add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

    # exterior container scope
    enclosing_con = node.con_scope[:-1]
    enclosing_scopestr = con_scope_to_str(enclosing_con)
    out_ret_val = create_grfn_var(
        var_name, id, version, enclosing_scopestr
    )
    out_fullid = build_fullid(var_name, id, version, enclosing_scopestr)
    self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
    # create From Source metadata for the GrFN var
    add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

    # store created fullid and grfn_id in node&#39;s ret_val
    node.out_ret_val[id] = out_fullid
    node.in_ret_val[id] = in_fullid
    # link ret values on bot interface
    node.bot_interface_in[id] = in_fullid
    node.bot_interface_out[id] = out_fullid

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;For FunctionDef {node.name.name}&#34;)
        print(&#34;\tAfter func_def_ret_val_creation():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.func_def_top_interface_args"><code class="name flex">
<span>def <span class="ident">func_def_top_interface_args</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef">AnnCastFunctionDef</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates initial version for each argument and each formal parameter
Links these argument and parameters through the <code>top_interface_in</code> and <code>top_interface_out</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def func_def_top_interface_args(self, node: AnnCastFunctionDef):
    &#34;&#34;&#34;
    Creates initial version for each argument and each formal parameter
    Links these argument and parameters through the `top_interface_in` and `top_interface_out`
    &#34;&#34;&#34;
    # function container is used to scope parameters
    param_con_scopestr = con_scope_to_str(node.con_scope)
    # enclosing container is used to scope arguments
    enclosing_con_scope = node.con_scope[:-1]
    arg_con_scopestr = con_scope_to_str(enclosing_con_scope)

    # create argument and parameter variables
    # argument variables are inputs to the top interface
    # paramter variables are outputs of the top interface
    for i, param in enumerate(node.func_args):
        # argument name and scope str
        arg_name = func_def_argument_name(node, i)

        # parameter name and scopestr
        assert isinstance(param, AnnCastVar)
        param_name = param.val.name

        # argument and parameter share id, and start with initial version
        id = param.val.id
        version = VAR_INIT_VERSION

        # build and store GrFN variables for argument and parameter
        arg_grfn_var = create_grfn_var(
            arg_name, id, version, arg_con_scopestr
        )
        arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
        self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
        # store arg_fullid
        node.arg_index_to_fullid[i] = arg_fullid
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_ARG
        )
        add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

        param_grfn_var = create_grfn_var(
            param_name, id, version, param_con_scopestr
        )
        param_fullid = build_fullid(
            param_name, id, version, param_con_scopestr
        )
        self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
        # store param_fullid
        node.param_index_to_fullid[i] = param_fullid
        # store metadata in paramter GrFN Var
        add_metadata_from_name_node(param_grfn_var, param.val)

        # link argument and parameter through top interface
        node.top_interface_in[id] = arg_fullid
        node.top_interface_out[id] = param_fullid

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;For FunctionDef {node.name.name}&#34;)
        print(&#34;After func_def_top_iface_args():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.get_highest_ver_in_con_scope"><code class="name flex">
<span>def <span class="ident">get_highest_ver_in_con_scope</span></span>(<span>self, con_scopestr, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Grab the current version of <code>id</code> in scope for <code>con_scopestr</code>
Should only be called after <code>con_scopestr</code> is in the <code>self.con_scope_to_highest_var_vers</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_highest_ver_in_con_scope(self, con_scopestr, id):
    &#34;&#34;&#34;
    Grab the current version of `id` in scope for `con_scopestr`
    Should only be called after `con_scopestr` is in the `self.con_scope_to_highest_var_vers`
    &#34;&#34;&#34;
    return self.con_scope_to_highest_var_vers[con_scopestr][id]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.grfn_2_2_call_ret_val_creation"><code class="name flex">
<span>def <span class="ident">grfn_2_2_call_ret_val_creation</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates two GrFN variables for the Call's return value.
One is in the interior of the container and links
to the bot interface in.
The other is outside the container and
links to the bot interface out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grfn_2_2_call_ret_val_creation(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Creates two GrFN variables for the Call&#39;s return value.
    One is in the interior of the container and links
    to the bot interface in.  The other is outside the container and
    links to the bot interface out.
    &#34;&#34;&#34;
    # Create new GrFN for return value for bot interface in and bot interface out
    var_name = call_ret_val_name(node)
    id = self.pipeline_state.next_collapsed_id()
    version = VAR_INIT_VERSION

    # interior container scope
    call_con_scopestr = con_scope_to_str(
        node.func.con_scope + [call_container_name(node)]
    )

    in_ret_val = create_grfn_var(var_name, id, version, call_con_scopestr)
    in_fullid = build_fullid(var_name, id, version, call_con_scopestr)
    self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
    # create From Source metadata for the GrFN var
    from_source = False
    from_source_mdata = generate_from_source_metadata(
        from_source, VariableCreationReason.FUNC_RET_VAL
    )
    add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

    # exterior container scope
    con_scopestr = con_scope_to_str(node.func.con_scope)
    out_ret_val = create_grfn_var(var_name, id, version, con_scopestr)
    out_fullid = build_fullid(var_name, id, version, con_scopestr)
    self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
    # create From Source metadata for the GrFN var
    add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

    # store created fullid and grfn_id in node&#39;s ret_val
    node.out_ret_val[id] = out_fullid
    node.in_ret_val[id] = in_fullid
    # link ret values on bot interface
    node.bot_interface_in[id] = in_fullid
    node.bot_interface_out[id] = out_fullid

    # also, store the created ret_val in the copied function def
    # this is done so that we can assign to the ret val when
    # parsing return statements
    node.func_def_copy.in_ret_val[id] = in_fullid</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.grfn_2_2_call_top_interface_args"><code class="name flex">
<span>def <span class="ident">grfn_2_2_call_top_interface_args</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates initial version for each argument and each formal parameter
Links these argument and parameters through the <code>top_interface_in</code> and <code>top_interface_out</code></p>
<p>During GrfnAssignmentPass,
for each argument, creates a <code>GrfnAssignment</code> which stores the assignment <code>LambdaNode</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grfn_2_2_call_top_interface_args(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Creates initial version for each argument and each formal parameter
    Links these argument and parameters through the `top_interface_in` and `top_interface_out`

    During GrfnAssignmentPass,
    for each argument, creates a `GrfnAssignment` which stores the assignment `LambdaNode`
    &#34;&#34;&#34;
    # call container is used to scope parameters
    call_con_name = call_container_name(node)

    # create argument and parameter variables
    # argument variables are inputs to the top interface
    # paramter variables are outputs of the top interface
    # if we are generating GrFN 2.2, we would like the parameter to lie in the
    # copied function def container, we do this by aliasing versions during GrfnVarCreation pass
    for i, n in enumerate(node.arguments):
        # argument name and scope str
        arg_name = call_argument_name(node, i)
        arg_con_scopestr = con_scope_to_str(node.func.con_scope)

        # parameter name and scopestr
        param = node.func_def_copy.func_args[i]
        assert isinstance(param, AnnCastVar)
        param_name = param.val.name
        param_con_scopestr = con_scope_to_str(
            node.func.con_scope + [call_con_name]
        )

        # argument and parameter share id, and start with initial version
        id = self.pipeline_state.next_collapsed_id()
        version = VAR_INIT_VERSION

        # build and store GrFN variables for argument and parameter
        arg_grfn_var = create_grfn_var(
            arg_name, id, version, arg_con_scopestr
        )
        arg_fullid = build_fullid(arg_name, id, version, arg_con_scopestr)
        self.pipeline_state.store_grfn_var(arg_fullid, arg_grfn_var)
        # store arg_fullid
        node.arg_index_to_fullid[i] = arg_fullid
        # create From Source metadata for the GrFN var
        from_source = False
        from_source_mdata = generate_from_source_metadata(
            from_source, VariableCreationReason.FUNC_ARG
        )
        add_metadata_to_grfn_var(arg_grfn_var, from_source_mdata)

        param_grfn_var = create_grfn_var(
            param_name, id, version, param_con_scopestr
        )
        param_fullid = build_fullid(
            param_name, id, version, param_con_scopestr
        )
        self.pipeline_state.store_grfn_var(param_fullid, param_grfn_var)
        # store param_fullid
        node.param_index_to_fullid[i] = param_fullid
        add_metadata_from_name_node(param_grfn_var, param.val)

        # link argument and parameter through top interface
        node.top_interface_in[id] = arg_fullid
        node.top_interface_out[id] = param_fullid

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(&#34;After create_call_args_and_params():&#34;)
        print(f&#34;\ttop_interface_in = {node.top_interface_in}&#34;)
        print(f&#34;\ttop_interface_out = {node.top_interface_out}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.incr_vars_in_con_scope"><code class="name flex">
<span>def <span class="ident">incr_vars_in_con_scope</span></span>(<span>self, scopestr, vars)</span>
</code></dt>
<dd>
<div class="desc"><p>This will increment all versions of variables in <code>scopestr</code> that are
in the dict <code>vars</code> which contains variable ids mapped to AnnCastName nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incr_vars_in_con_scope(self, scopestr, vars):
    &#34;&#34;&#34;
    This will increment all versions of variables in `scopestr` that are
    in the dict `vars` which contains variable ids mapped to AnnCastName nodes
    &#34;&#34;&#34;
    for var_id, var_name in vars.items():
        self.incr_version_in_con_scope(scopestr, var_id, var_name)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.incr_version_in_con_scope"><code class="name flex">
<span>def <span class="ident">incr_version_in_con_scope</span></span>(<span>self, con_scopestr:str, id:int, var_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Grab the next version of <code>id</code> in scope for <code>con_scopestr</code>
Should only be called after <code>con_scopestr</code> is in the <code>self.con_scope_to_highest_var_vers</code></p>
<p>Also creates a GrFN variable for the newly added version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incr_version_in_con_scope(
    self, con_scopestr: str, id: int, var_name: str
):
    &#34;&#34;&#34;
    Grab the next version of `id` in scope for `con_scopestr`
    Should only be called after `con_scopestr` is in the `self.con_scope_to_highest_var_vers`

    Also creates a GrFN variable for the newly added version
    &#34;&#34;&#34;
    # NOTE: we should have added id to con_scope_to_highest_var_vers when we call
    # init_highest_var_vers_dict
    # if this does not happen, some logic has failed
    assert id in self.con_scope_to_highest_var_vers[con_scopestr]
    self.con_scope_to_highest_var_vers[con_scopestr][id] += 1
    version = self.con_scope_to_highest_var_vers[con_scopestr][id]
    grfn_var = create_grfn_var(var_name, id, version, con_scopestr)
    fullid = build_fullid(var_name, id, version, con_scopestr)
    self.pipeline_state.store_grfn_var(fullid, grfn_var)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.init_highest_var_vers_dict"><code class="name flex">
<span>def <span class="ident">init_highest_var_vers_dict</span></span>(<span>self, con_scopestr, var_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize highest var version dict for scope <code>con_scopestr</code>
If the scope is the module, then use a defaultdict starting at zero
otherwise, create a dictionary mapping each of the ids to zero</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_highest_var_vers_dict(self, con_scopestr, var_ids):
    &#34;&#34;&#34;
    Initialize highest var version dict for scope `con_scopestr`
    If the scope is the module, then use a defaultdict starting at zero
    otherwise, create a dictionary mapping each of the ids to zero
    &#34;&#34;&#34;
    self.con_scope_to_highest_var_vers[con_scopestr] = {}
    for id in var_ids:
        self.con_scope_to_highest_var_vers[con_scopestr][id] = 0
    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(
            f&#34;initialized highest_vars_vers_dict {self.con_scope_to_highest_var_vers[con_scopestr]}&#34;
        )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.is_var_in_con_scope"><code class="name flex">
<span>def <span class="ident">is_var_in_con_scope</span></span>(<span>self, con_scopestr:str, id:int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_var_in_con_scope(self, con_scopestr: str, id: int):
    return id in self.con_scope_to_highest_var_vers[con_scopestr]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_call_bot_interface_with_ret_val"><code class="name flex">
<span>def <span class="ident">populate_call_bot_interface_with_ret_val</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates two GrFN variables for the Call's return value.
One is in the interior of the container and links
to the bot interface in.
The other is outside the container and
links to the bot interface out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_call_bot_interface_with_ret_val(self, node: AnnCastCall):
    &#34;&#34;&#34;
    Creates two GrFN variables for the Call&#39;s return value.
    One is in the interior of the container and links
    to the bot interface in.  The other is outside the container and
    links to the bot interface out.
    &#34;&#34;&#34;
    # Create new GrFN for return value for bot interface in and bot interface out
    var_name = call_ret_val_name(node)
    id = self.pipeline_state.next_collapsed_id()
    version = VAR_INIT_VERSION

    # interior container scope
    call_con_scopestr = con_scope_to_str(
        node.func.con_scope + [call_container_name(node)]
    )

    in_ret_val = create_grfn_var(var_name, id, version, call_con_scopestr)
    in_fullid = build_fullid(var_name, id, version, call_con_scopestr)
    self.pipeline_state.store_grfn_var(in_fullid, in_ret_val)
    # create From Source metadata for the GrFN var
    from_source = False
    from_source_mdata = generate_from_source_metadata(
        from_source, VariableCreationReason.FUNC_RET_VAL
    )
    add_metadata_to_grfn_var(in_ret_val, from_source_mdata)

    # exterior container scope
    con_scopestr = con_scope_to_str(node.func.con_scope)
    out_ret_val = create_grfn_var(var_name, id, version, con_scopestr)
    out_fullid = build_fullid(var_name, id, version, con_scopestr)
    self.pipeline_state.store_grfn_var(out_fullid, out_ret_val)
    add_metadata_to_grfn_var(out_ret_val, from_source_mdata)

    # store created fullid and grfn_id in node&#39;s ret_val
    node.out_ret_val[id] = out_fullid
    node.in_ret_val[id] = in_fullid
    # link ret values on bot interface
    node.bot_interface_in[id] = in_fullid
    node.bot_interface_out[id] = out_fullid</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_interface"><code class="name flex">
<span>def <span class="ident">populate_interface</span></span>(<span>self, con_scopestr, vars, interface)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ul>
<li><code>con_scopestr</code>: a cached container scope</li>
<li><code>vars</code>: a dict mapping numerical ids to variable names</li>
<li><code>interface</code>: a dict mapping numerical variable ids to fullids
(e.g. the top or bottom interface of a container node)</li>
</ul>
<p>For each variable from <code>vars</code>, put the highest version of that variable
from container <code>con_scopestr</code> into <code>interface</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_interface(self, con_scopestr, vars, interface):
    &#34;&#34;&#34;
    Parameters:
      - `con_scopestr`: a cached container scope
      - `vars`: a dict mapping numerical ids to variable names
      - `interface`: a dict mapping numerical variable ids to fullids
                     (e.g. the top or bottom interface of a container node)

    For each variable from `vars`, put the highest version of that variable
    from container `con_scopestr` into `interface`
    &#34;&#34;&#34;
    # add vars to interface
    for id, var_name in vars.items():
        highest_ver = self.get_highest_ver_in_con_scope(con_scopestr, id)
        # if con_scopestr is a FunctionDef container, and highest_ver is VAR_INIT_VERSION
        # we call fix_for_python_gcc_declaration_distinction
        # this creates a dummy assignment to the variable in the FunctionDef container
        # most likely, this is not the ideal long term solution
        scopestr_is_func = self.pipeline_state.is_con_scopestr_func_def(
            con_scopestr
        )
        local_var = (
            scopestr_is_func
            and self.pipeline_state.is_var_local_to_func(con_scopestr, id)
        )
        if local_var and highest_ver == VAR_INIT_VERSION:
            self.fix_for_python_gcc_declaration_distinction(
                con_scopestr, id, var_name
            )
            # update highest ver after the dummy assignment
            highest_ver = self.get_highest_ver_in_con_scope(
                con_scopestr, id
            )
        fullid = build_fullid(var_name, id, highest_ver, con_scopestr)
        interface[id] = fullid</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_loop_interfaces"><code class="name flex">
<span>def <span class="ident">populate_loop_interfaces</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastLoop" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastLoop">AnnCastLoop</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_loop_interfaces(self, node: AnnCastLoop):
    # populate interfaces and increment versions in previous scope of modified variables
    prev_scopestr = con_scope_to_str(node.con_scope[:-1])
    # populate top interface initial
    # these are all used variables
    node.top_interface_vars = node.used_vars
    self.populate_interface(
        prev_scopestr, node.top_interface_vars, node.top_interface_initial
    )
    # increment versions of modified vars
    self.incr_vars_in_con_scope(prev_scopestr, node.modified_vars)
    # populate bot interface out
    node.bot_interface_vars = node.modified_vars
    self.populate_interface(
        prev_scopestr, node.bot_interface_vars, node.bot_interface_out
    )
    self.add_default_bot_interface_metadata(node.bot_interface_out)

    # populate &#34;inside&#34; of interfaces
    con_scopestr = con_scope_to_str(node.con_scope)
    # populate top interface updated
    # these are all modified variables
    node.top_interface_updated_vars = node.modified_vars
    for id, var_name in node.top_interface_updated_vars.items():
        version = LOOP_VAR_UPDATED_VERSION
        fullid = build_fullid(var_name, id, version, con_scopestr)
        node.top_interface_updated[id] = fullid
    # populate top interface out
    # the top interface chooses between initial and updated versions;
    # by convention the produced version is `VAR_INIT_VERSION`
    # which is consistent with other containers
    for id, var_name in node.top_interface_vars.items():
        version = VAR_INIT_VERSION
        fullid = build_fullid(var_name, id, version, con_scopestr)
        node.top_interface_out[id] = fullid
    # populate bot interface in
    # the bot interface takes `VAR_EXIT_VERSION` modified variables
    # During GrFN Variable Creation, these versions will be aliased to
    # the highest version occuring in the loop expr
    for id, var_name in node.bot_interface_vars.items():
        version = VAR_EXIT_VERSION
        fullid = build_fullid(var_name, id, version, con_scopestr)
        node.bot_interface_in[id] = fullid</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_model_if_interfaces"><code class="name flex">
<span>def <span class="ident">populate_model_if_interfaces</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelIf" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelIf">AnnCastModelIf</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_model_if_interfaces(self, node: AnnCastModelIf):
    # populate interfaces and increment versions in previous scope of modified variables
    prev_scopestr = con_scope_to_str(node.con_scope[:-1])
    # populate top interface in
    node.top_interface_vars = node.used_vars
    self.populate_interface(
        prev_scopestr, node.top_interface_vars, node.top_interface_in
    )
    # increment versions
    self.incr_vars_in_con_scope(prev_scopestr, node.modified_vars)
    # populate bot interface out
    node.bot_interface_vars = node.modified_vars
    self.populate_interface(
        prev_scopestr, node.bot_interface_vars, node.bot_interface_out
    )
    self.add_default_bot_interface_metadata(node.bot_interface_out)

    # populate &#34;inside&#34; of interfaces
    con_scopestr = con_scope_to_str(node.con_scope)
    # populate top interface out
    # by convention the top interface produces version VAR_INIT_VERSION variables
    # and these are propagated to if expr, if body, and else body
    for id, var_name in node.top_interface_vars.items():
        version = VAR_INIT_VERSION
        fullid = build_fullid(var_name, id, version, con_scopestr)
        node.top_interface_out[id] = fullid
    # populate bot interface in
    # by convention, the bot interface in takes version VAR_EXIT_VERSION variables
    # these versions are produced by the Decision node
    # and they are created during GrfnVariableCreationPass
    for id, var_name in node.bot_interface_vars.items():
        version = VAR_EXIT_VERSION
        fullid = build_fullid(var_name, id, version, con_scopestr)
        node.bot_interface_in[id] = fullid</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastNode" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastNode">AnnCastNode</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node: AnnCastNode, assign_lhs: bool):
    # print current node being visited.
    # this can be useful for debugging
    # class_name = node.__class__.__name__
    # print(f&#34;\nProcessing node type {class_name}&#34;)
    return self._visit(node, assign_lhs)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_assignment"><code class="name flex">
<span>def <span class="ident">visit_assignment</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastAssignment" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastAssignment">AnnCastAssignment</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_assignment(self, node: AnnCastAssignment, assign_lhs: bool):
    self.visit(node.right, assign_lhs)
    # The AnnCastTuple is added to handle scenarios where an assignment
    # is made by assigning to a tuple of values, as opposed to one singular value
    assert (
        isinstance(node.left, AnnCastVar)
        or (isinstance(node.left, AnnCastLiteralValue) and (node.left.value_type == StructureType.TUPLE))
        or isinstance(node.left, AnnCastAssignment)
        or isinstance(node.left, AnnCastAttribute) or isinstance(node.left, AnnCastCall)
    ), f&#34;container_scope: visit_assigment: node.left is {type(node.left)}&#34;
    self.visit(node.left, True)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_attribute"><code class="name flex">
<span>def <span class="ident">visit_attribute</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastAttribute" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastAttribute">AnnCastAttribute</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_attribute(self, node: AnnCastAttribute, assign_lhs: bool):
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_call"><code class="name flex">
<span>def <span class="ident">visit_call</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_call(self, node: AnnCastCall, assign_lhs: bool):
    assert isinstance(node.func, AnnCastName) or isinstance(
        node.func, AnnCastAttribute
    )

    if node.is_grfn_2_2:
        self.visit_call_grfn_2_2(node, assign_lhs)
        return

    self.visit_node_list(node.arguments, assign_lhs)
    # populate call nodes&#39;s top interface with arguments
    # The pattern for the top interface is as follows:
    # For each argument, we create a GrFN variable using the arguments index
    # E.g. Arg0, Arg1, ...
    # top interface inputs: Arg0, Arg1,...
    # top interface outputs: Param0, Param1, ...
    # if this Call has a FunctionDef, then we can fill in correct paramter names
    # if it doesn&#39;t we need to provide default parameter names
    # if we have the FunctionDef for the call, we can also add globals to the interfaces
    if node.has_func_def:
        self.call_top_interface_args_with_func_def(node)
        self.add_globals_to_call_interfaces(node)
        func_node = node.func.id
        func_def_node = self.pipeline_state.func_def_node_from_id(
            func_node
        )
        node.has_ret_val = func_def_node.has_ret_val
    # if we do not have the FunctionDef, we will not add any globals to the interfaces
    else:
        self.call_top_interface_args_with_no_func_def(node)

    # add return value to bot interface out
    if node.has_ret_val:
        self.populate_call_bot_interface_with_ret_val(node)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_call_grfn_2_2"><code class="name flex">
<span>def <span class="ident">visit_call_grfn_2_2</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastCall">AnnCastCall</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_call_grfn_2_2(self, node: AnnCastCall, assign_lhs: bool):
    assert isinstance(node.func, AnnCastName)
    self.visit_node_list(node.arguments, assign_lhs)
    # populate call nodes&#39;s top interface with arguments
    # The pattern for the top interface is as follows:
    # For each argument, we create a GrFN variable using the arguments index
    # E.g. Arg0, Arg1, ...
    # top interface inputs: Arg0, Arg1,...
    # top interface outputs: NamedParam0, NamedParam1, ...
    self.grfn_2_2_call_top_interface_args(node)

    node.has_ret_val = node.func_def_copy.has_ret_val
    # add return value to bot interface out if function_copy has a ret_val
    if node.func_def_copy.has_ret_val:
        self.grfn_2_2_call_ret_val_creation(node)

    # we visit the function def copy to version globals appearing in its body
    call_assign_lhs = False
    self.visit_function_def_copy(node.func_def_copy, call_assign_lhs)

    # add globals to call interface
    self.add_globals_to_grfn_2_2_call_interfaces(node)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_function_def"><code class="name flex">
<span>def <span class="ident">visit_function_def</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef">AnnCastFunctionDef</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_function_def(self, node: AnnCastFunctionDef, assign_lhs: bool):
    # Initialize scope_to_highest_var_vers
    con_scopestr = con_scope_to_str(node.con_scope)
    # create versions 0 of any modified or accessed variables
    self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())

    # visit children
    self.visit_node_list(node.func_args, assign_lhs)
    self.visit_node_list(node.body, assign_lhs)

    # store highest var version
    node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
        con_scopestr
    ]

    # populate FunctionDef nodes&#39;s top interface with arguments
    # The pattern for the top interface is as follows:
    # For each argument, we create a GrFN variable using the arguments index
    # E.g. Arg0, Arg1, ...
    # top interface inputs: Arg0, Arg1,...
    # top interface outputs: NamedParam0, NamedParam1, ...
    self.func_def_top_interface_args(node)

    # add return value to bot interface out if functiondef has a ret_val
    if node.has_ret_val:
        self.func_def_ret_val_creation(node)

    # add globals to functiondef integfaces
    if is_func_def_main(node):
        self.add_globals_to_main_func_def_interfaces(node)
    else:
        self.add_globals_to_non_main_func_def_interfaces(node)

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;\nFor FUNCTION: {con_scopestr}&#34;)
        print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_function_def_copy"><code class="name flex">
<span>def <span class="ident">visit_function_def_copy</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastFunctionDef">AnnCastFunctionDef</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Used for GrFN 2.2 Generation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_def_copy(
    self, node: AnnCastFunctionDef, assign_lhs: bool
):
    &#34;&#34;&#34;
    Used for GrFN 2.2 Generation
    &#34;&#34;&#34;
    # Initialize scope_to_highest_var_vers
    con_scopestr = con_scope_to_str(node.con_scope)
    # create VAR_INIT_VERSION of any modified or accessed variables
    self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())

    # visit children
    self.visit_node_list(node.func_args, assign_lhs)
    self.visit_node_list(node.body, assign_lhs)

    # store highest var version
    node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
        con_scopestr
    ]

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;\nFor FUNCTION COPY: {con_scopestr}&#34;)
        print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_literal_value"><code class="name flex">
<span>def <span class="ident">visit_literal_value</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastLiteralValue" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastLiteralValue">AnnCastLiteralValue</a>, assign_side)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_literal_value(self, node: AnnCastLiteralValue, assign_side):
    if node.value_type == &#34;List[Any]&#34;:
        # val has
        # operator - string
        # size - Var node or a LiteralValue node (for number)
        # initial_value - LiteralValue node
        val = node.value

        # visit size&#39;s anncast name node
        self.visit(val.size, assign_side)

        # List literal doesn&#39;t need to add any other changes
        # to the anncast at this pass

    elif node.value_type == StructureType.TUPLE: # or node.value_type == StructureType.LIST:
        self.visit_node_list(node.value, assign_side)
    elif node.value_type == ScalarType.INTEGER:
        pass
    elif node.value_type == ScalarType.ABSTRACTFLOAT:
        pass
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_loop"><code class="name flex">
<span>def <span class="ident">visit_loop</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastLoop" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastLoop">AnnCastLoop</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_loop(self, node: AnnCastLoop, assign_lhs: bool):
    # Initialize scope_to_highest_var_version
    if len(node.pre) &gt; 0:
        pre_scopestr = con_scope_to_str(node.con_scope + [LOOPPRE])
    expr_scopestr = con_scope_to_str(node.con_scope + [LOOPEXPR])
    body_scopestr = con_scope_to_str(node.con_scope + [LOOPBODY])
    if len(node.post) &gt; 0:
        post_scopestr = con_scope_to_str(node.con_scope + [LOOPPOST])

    # Initialize LoopInit
    # create versions 0 of any modified or accessed variables
    if len(node.pre) &gt; 0:
        self.init_highest_var_vers_dict(
            pre_scopestr, node.used_vars.keys()
        )

    # Initialize LoopExpr
    # create versions 0 of any modified or accessed variables
    self.init_highest_var_vers_dict(expr_scopestr, node.used_vars.keys())

    # Initialize LoopBody
    # create versions 0 of any modified or accessed variables
    self.init_highest_var_vers_dict(body_scopestr, node.used_vars.keys())

    # Initialize LoopPost
    if len(node.post) &gt; 0:
        self.init_highest_var_vers_dict(
            post_scopestr, node.used_vars.keys()
        )

    ######## visit children ########
    if len(node.pre) &gt; 0:
        self.visit_node_list(node.pre, assign_lhs)

    self.visit(node.expr, assign_lhs)
    self.visit_node_list(node.body, assign_lhs)

    if len(node.post) &gt; 0:
        self.visit_node_list(node.post, assign_lhs)

    # print(node.used_vars)

    # store highest var version
    if len(node.pre) &gt; 0:
        node.pre_highest_var_vers = self.con_scope_to_highest_var_vers[
            pre_scopestr
        ]

    node.expr_highest_var_vers = self.con_scope_to_highest_var_vers[
        expr_scopestr
    ]
    node.body_highest_var_vers = self.con_scope_to_highest_var_vers[
        body_scopestr
    ]

    if len(node.post) &gt; 0:
        node.post_highest_var_vers = self.con_scope_to_highest_var_vers[
            post_scopestr
        ]

    # populate all of this loops interfaces
    self.populate_loop_interfaces(node)

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;\nFor LOOP: {con_scope_to_str(node.con_scope)}&#34;)
        if len(node.pre) &gt; 0:
            print(f&#34;  PreHighestVers: {node.pre_highest_var_vers}&#34;)
        print(f&#34;  ExprHighestVers: {node.expr_highest_var_vers}&#34;)
        print(f&#34;  BodyHighestVers: {node.body_highest_var_vers}&#34;)
        if len(node.Post) &gt; 0:
            print(f&#34;  PostHighestVers: {node.post_highest_var_vers}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_break"><code class="name flex">
<span>def <span class="ident">visit_model_break</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelBreak" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelBreak">AnnCastModelBreak</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_model_break(self, node: AnnCastModelBreak, assign_lhs: bool):
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_continue"><code class="name flex">
<span>def <span class="ident">visit_model_continue</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelContinue" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelContinue">AnnCastModelContinue</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_model_continue(
    self, node: AnnCastModelContinue, assign_lhs: bool
):
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_if"><code class="name flex">
<span>def <span class="ident">visit_model_if</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelIf" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelIf">AnnCastModelIf</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_model_if(self, node: AnnCastModelIf, assign_lhs: bool):
    # Initialize scope_to_highest_var_version
    expr_scopestr = con_scope_to_str(node.con_scope + [IFEXPR])
    ifbody_scopestr = con_scope_to_str(node.con_scope + [IFBODY])
    elsebody_scopestr = con_scope_to_str(node.con_scope + [ELSEBODY])
    # initialize IfExpr
    # create versions 0 of any modified or accessed variables
    self.init_highest_var_vers_dict(expr_scopestr, node.used_vars.keys())

    # initialize IfBody
    # create versions 0 of any modified or accessed variables
    self.init_highest_var_vers_dict(ifbody_scopestr, node.used_vars.keys())

    # initialize ElseBody
    # create versions 0 of any modified or accessed variables
    self.init_highest_var_vers_dict(
        elsebody_scopestr, node.used_vars.keys()
    )

    # visit children
    self.visit(node.expr, assign_lhs)
    self.visit_node_list(node.body, assign_lhs)
    self.visit_node_list(node.orelse, assign_lhs)

    # store highest var versions
    node.expr_highest_var_vers = self.con_scope_to_highest_var_vers[
        expr_scopestr
    ]
    node.ifbody_highest_var_vers = self.con_scope_to_highest_var_vers[
        ifbody_scopestr
    ]
    node.elsebody_highest_var_vers = self.con_scope_to_highest_var_vers[
        elsebody_scopestr
    ]

    # populate interfaces
    self.populate_model_if_interfaces(node)

    # DEBUG printing
    if self.pipeline_state.PRINT_DEBUGGING_INFO:
        print(f&#34;\nFor IF: {con_scope_to_str(node.con_scope)}&#34;)
        print(f&#34;  ExprHighestVers: {node.expr_highest_var_vers}&#34;)
        print(f&#34;  IfBodyHighestVers: {node.ifbody_highest_var_vers}&#34;)
        print(f&#34;  ElseBodyHighestVers: {node.elsebody_highest_var_vers}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_import"><code class="name flex">
<span>def <span class="ident">visit_model_import</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelImport" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelImport">AnnCastModelImport</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_model_import(self, node: AnnCastModelImport, assign_lhs: bool):
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_module"><code class="name flex">
<span>def <span class="ident">visit_module</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModule" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModule">AnnCastModule</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_module(self, node: AnnCastModule, assign_lhs: bool):
    con_scopestr = con_scope_to_str(node.con_scope)
    # create VAR_INIT_VERSION of any modified or accessed variables
    self.init_highest_var_vers_dict(con_scopestr, node.used_vars.keys())
    self.visit_node_list(node.body, assign_lhs)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_name"><code class="name flex">
<span>def <span class="ident">visit_name</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastName" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastName">AnnCastName</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_name(self, node: AnnCastName, assign_lhs: bool):
    con_scopestr = con_scope_to_str(node.con_scope)
    if assign_lhs:
        self.incr_version_in_con_scope(con_scopestr, node.id, node.name)

    node.version = self.get_highest_ver_in_con_scope(con_scopestr, node.id)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_node_list"><code class="name flex">
<span>def <span class="ident">visit_node_list</span></span>(<span>self, node_list:List[<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastNode" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastNode">AnnCastNode</a>], assign_lhs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_node_list(self, node_list: typing.List[AnnCastNode], assign_lhs):
    return [self.visit(node, assign_lhs) for node in node_list]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_operator"><code class="name flex">
<span>def <span class="ident">visit_operator</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastOperator" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastOperator">AnnCastOperator</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_operator(self, node: AnnCastOperator, assign_lhs: bool):
    # visit operands
    self.visit_node_list(node.operands, assign_lhs)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_record_def"><code class="name flex">
<span>def <span class="ident">visit_record_def</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastRecordDef" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastRecordDef">AnnCastRecordDef</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_record_def(self, node: AnnCastRecordDef, assign_lhs: bool):
    # Visit the function defs within this class to make sure
    # Everything is versioned correctly
    self.visit_node_list(node.funcs, assign_lhs)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_return"><code class="name flex">
<span>def <span class="ident">visit_return</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelReturn" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastModelReturn">AnnCastModelReturn</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_return(self, node: AnnCastModelReturn, assign_lhs: bool):
    self.visit(node.value, assign_lhs)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_set"><code class="name flex">
<span>def <span class="ident">visit_set</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastSet" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastSet">AnnCastSet</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_set(self, node: AnnCastSet, assign_lhs: bool):
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_tuple"><code class="name flex">
<span>def <span class="ident">visit_tuple</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastTuple" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastTuple">AnnCastTuple</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_tuple(self, node: AnnCastTuple, assign_lhs: bool):
    self.visit_node_list(node.values, assign_lhs)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_var"><code class="name flex">
<span>def <span class="ident">visit_var</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastVar" href="annotated_cast.html#skema.program_analysis.CAST2FN.ann_cast.annotated_cast.AnnCastVar">AnnCastVar</a>, assign_lhs:bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@_visit.register
def visit_var(self, node: AnnCastVar, assign_lhs: bool):
    self.visit(node.val, assign_lhs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast" href="index.html">skema.program_analysis.CAST2FN.ann_cast</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass">VariableVersionPass</a></code></h4>
<ul class="">
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_default_bot_interface_metadata" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_default_bot_interface_metadata">add_default_bot_interface_metadata</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_call_interfaces" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_call_interfaces">add_globals_to_call_interfaces</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_grfn_2_2_call_interfaces" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_grfn_2_2_call_interfaces">add_globals_to_grfn_2_2_call_interfaces</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_main_func_def_interfaces" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_main_func_def_interfaces">add_globals_to_main_func_def_interfaces</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_non_main_func_def_interfaces" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.add_globals_to_non_main_func_def_interfaces">add_globals_to_non_main_func_def_interfaces</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.call_top_interface_args_with_func_def" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.call_top_interface_args_with_func_def">call_top_interface_args_with_func_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.call_top_interface_args_with_no_func_def" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.call_top_interface_args_with_no_func_def">call_top_interface_args_with_no_func_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.fix_for_python_gcc_declaration_distinction" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.fix_for_python_gcc_declaration_distinction">fix_for_python_gcc_declaration_distinction</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.func_def_ret_val_creation" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.func_def_ret_val_creation">func_def_ret_val_creation</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.func_def_top_interface_args" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.func_def_top_interface_args">func_def_top_interface_args</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.get_highest_ver_in_con_scope" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.get_highest_ver_in_con_scope">get_highest_ver_in_con_scope</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.grfn_2_2_call_ret_val_creation" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.grfn_2_2_call_ret_val_creation">grfn_2_2_call_ret_val_creation</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.grfn_2_2_call_top_interface_args" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.grfn_2_2_call_top_interface_args">grfn_2_2_call_top_interface_args</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.incr_vars_in_con_scope" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.incr_vars_in_con_scope">incr_vars_in_con_scope</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.incr_version_in_con_scope" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.incr_version_in_con_scope">incr_version_in_con_scope</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.init_highest_var_vers_dict" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.init_highest_var_vers_dict">init_highest_var_vers_dict</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.is_var_in_con_scope" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.is_var_in_con_scope">is_var_in_con_scope</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_call_bot_interface_with_ret_val" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_call_bot_interface_with_ret_val">populate_call_bot_interface_with_ret_val</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_interface" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_interface">populate_interface</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_loop_interfaces" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_loop_interfaces">populate_loop_interfaces</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_model_if_interfaces" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.populate_model_if_interfaces">populate_model_if_interfaces</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit">visit</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_assignment" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_assignment">visit_assignment</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_attribute" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_attribute">visit_attribute</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_call" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_call">visit_call</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_call_grfn_2_2" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_call_grfn_2_2">visit_call_grfn_2_2</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_function_def" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_function_def">visit_function_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_function_def_copy" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_function_def_copy">visit_function_def_copy</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_literal_value" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_literal_value">visit_literal_value</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_loop" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_loop">visit_loop</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_break" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_break">visit_model_break</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_continue" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_continue">visit_model_continue</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_if" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_if">visit_model_if</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_import" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_model_import">visit_model_import</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_module" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_module">visit_module</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_name" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_name">visit_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_node_list" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_node_list">visit_node_list</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_operator" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_operator">visit_operator</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_record_def" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_record_def">visit_record_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_return" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_return">visit_return</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_set" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_set">visit_set</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_tuple" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_tuple">visit_tuple</a></code></li>
<li><code><a title="skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_var" href="#skema.program_analysis.CAST2FN.ann_cast.variable_version_pass.VariableVersionPass.visit_var">visit_var</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>