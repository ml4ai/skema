<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.CAST.pythonAST.py_ast_to_cast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.CAST.pythonAST.py_ast_to_cast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import ast
from enum import unique
import os
import copy
import sys
from functools import singledispatchmethod

from skema.utils.misc import uuid
from skema.program_analysis.astpp import parseprint
from skema.program_analysis.CAST2FN.model.cast import (
    AstNode,
    Assignment,
    Attribute,
    Call,
    FunctionDef,
    LiteralValue,
    Loop,
    ModelBreak,
    ModelContinue,
    ModelIf,
    ModelReturn,
    ModelImport,
    Module,
    Name,
    Operator,
    RecordDef,
    ScalarType,
    StructureType,
    SourceRef,
    SourceCodeDataType,
    VarType,
    Var,
    ValueConstructor,
)
from skema.program_analysis.CAST.pythonAST.modules_list import (
    BUILTINS,
    find_std_lib_module,
)

def get_python_version():
    &#34;&#34;&#34;
    get_python_version gets the current version of Python that 
    is running when this script is executed
    The expect version is 3.8.2 as that is what my (Tito) version
    of Python is when running this pipeline
    The plan is to eventually move onto the latest version (3.11?)    
    But 3.8.2 is the current stable version for generation
    The latest version of Python makes some changes that this
    pipeline still needs to adjust for
    &#34;&#34;&#34;
    major = sys.version_info.major
    minor = sys.version_info.minor
    micro = sys.version_info.micro

    string_version = f&#34;{major}.{minor}.{micro}&#34;

    return string_version


def merge_dicts(source, destination):
    &#34;&#34;&#34;merge_dicts
    Helper function to isolate the work of merging two dictionaries by merging
    key : value pairs from source into curr_scope
    The merging is done &#39;in_place&#39;. That is, after the function is done, destination
    is updated with any new key : value pairs that weren&#39;t in there before.

    Args:
        source (dict): Dictionary of name : ID pairs
        destination (dict): Dictionary of name : ID pairs
    &#34;&#34;&#34;
    for k in source.keys():
        if k not in destination.keys():
            destination[k] = source[k]


def construct_unique_name(attr_name, var_name):
    &#34;&#34;&#34;Constructs strings in the form of
    &#34;attribute.var&#34;
    where &#39;attribute&#39; is either
        - the name of a module
        - an object

    Returns:
        string: A string representing a unique name

    &#34;&#34;&#34;
    return f&#34;{attr_name}.{var_name}&#34;


def get_node_name(ast_node):
    if isinstance(ast_node, ast.Assign):
        return get_node_name(ast_node.targets[0])
        # return [ast_node[0].id]
    elif isinstance(ast_node, ast.Name):
        return [ast_node.id]
    elif isinstance(ast_node, ast.Attribute):
        return get_node_name(ast_node.value)
    elif isinstance(ast_node, ast.Tuple):
        elements = []
        for elem in ast_node.elts:
            elements.extend(get_node_name(elem))
        return elements
    elif isinstance(ast_node, Attribute):
        return [ast_node.attr.name]
    elif isinstance(ast_node, Var):
        return [ast_node.val.name]
    elif isinstance(ast_node, Assignment):
        return get_node_name(ast_node.left)
    elif isinstance(ast_node, ast.Subscript):
        return get_node_name(ast_node.value)
    elif (
        isinstance(ast_node, LiteralValue)
        and (ast_node.value_type == StructureType.LIST or ast_node.value_type == StructureType.TUPLE)
    ):
        names = []
        for e in ast_node.value:
            names.extend(get_node_name(e))
        return names
    else:
        raise TypeError(f&#34;Type {type(ast_node)} not supported&#34;)


def get_op(operator):
    ops = {
        ast.Add: &#39;ast.Add&#39;,
        ast.Sub: &#39;ast.Sub&#39;,
        ast.Mult: &#39;ast.Mult&#39;,
        ast.Div: &#39;ast.Div&#39;,
        ast.FloorDiv: &#39;ast.FloorDiv&#39;,
        ast.Mod: &#39;ast.Mod&#39;,
        ast.Pow: &#39;ast.Pow&#39;,
        ast.LShift: &#39;ast.LShift&#39;,
        ast.RShift: &#39;ast.RShift&#39;,
        ast.BitOr: &#39;ast.BitOr&#39;,
        ast.BitAnd: &#39;ast.BitAnd&#39;,
        ast.BitXor: &#39;ast.BitXor&#39;,
        ast.And: &#39;ast.And&#39;,
        ast.Or: &#39;ast.Or&#39;,
        ast.Eq: &#39;ast.Eq&#39;,
        ast.NotEq: &#39;ast.NotEq&#39;,
        ast.Lt: &#39;ast.Lt&#39;,
        ast.LtE: &#39;ast.LtE&#39;,
        ast.Gt: &#39;ast.Gt&#39;,
        ast.GtE: &#39;ast.GtE&#39;,
        ast.In: &#39;ast.In&#39;,
        ast.NotIn: &#39;ast.NotIn&#39;,
        ast.UAdd: &#39;ast.UAdd&#39;,
        ast.USub: &#39;ast.USub&#39;,
        ast.Not: &#39;ast.Not&#39;,
        ast.Invert: &#39;ast.Invert&#39;,
    }

    if type(operator) in ops.keys():
        return ops[type(operator)]
    return str(operator)


class PyASTToCAST:
    &#34;&#34;&#34;Class PyASTToCast
    This class is used to convert a Python program into a CAST object.
    In particular, given a PyAST object that represents the Python program&#39;s
    Abstract Syntax Tree, we create a Common Abstract Syntax Tree
    representation of it.
    Most of the functions involve visiting the children
    to generate their CAST, and then connecting them to their parent to form
    the parent node&#39;s CAST representation.
    The functions, in most cases, return lists containing their generated CAST.
    This is because in many scenarios (like in slicing) we need to return multiple
    values at once, since multiple CAST nodes gt generated. Returning lists allows us to
    do this, and as long as the visitors handle the data correctly, the CAST will be
    properly generated.
    All the visitors retrieve line number information from the PyAST nodes, and
    include the information in their respective CAST nodes, with the exception
    of the Module CAST visitor.

    This class inherits from ast.NodeVisitor, to allow us to use the Visitor
    design pattern to visit all the different kinds of PyAST nodes in a
    similar fashion.

    Current Fields:
        - Aliases
        - Visited
        - Filenames
        - Classes
        - Var_Count
        - global_identifier_dict
    &#34;&#34;&#34;

    def __init__(self, file_name: str, legacy: bool = False):
        &#34;&#34;&#34;Initializes any auxiliary data structures that are used
        for generating CAST.
        The current data structures are:
        - aliases: A dictionary used to keep track of aliases that imports use
                  (like import x as y, or from x import y as z)
        - visited: A list used to keep track of which files have been imported
                  this is used to prevent an import cycle that could have no end
        - filenames: A list of strings used as a stack to maintain the current file being
                     visited
        - module_stack: A list of Module PyAST nodes used as a stack to maintain the current module
                     being visited.
        - classes: A dictionary of class names and their associated functions.
        - var_count: An int used when CAST variables need to be generated (i.e. loop variables, etc)
        - global_identifier_dict: A dictionary used to map global variables to unique identifiers
        - legacy: A flag used to determine whether we generate old style CAST (uses strings for function def names)
                  or new style CAST (uses Name CAST nodes for function def names)
        - generated_fns: A list that holds any generated CAST Function Defs. Currently used for list/dict comprehensions
                  and lambda functions
        - &#34;*_count&#34;: Identifier numbers used for list/dict comprehensions, and lambda functions
        &#34;&#34;&#34;

        self.aliases = {}
        self.visited = set()
        self.filenames = [file_name.split(&#34;.&#34;)[0]]
        self.module_stack = []
        self.classes = {}
        self.var_count = 0
        self.global_identifier_dict = {}
        self.id_count = 0
        self.legacy = legacy
        self.generated_fns = []
        self.list_comp_count = 0
        self.dict_comp_count = 0
        self.lambda_count = 0

    def insert_next_id(self, scope_dict: dict, dict_key: str):
        &#34;&#34;&#34;Given a scope_dictionary and a variable name as a key,
        we insert a new key_value pair for the scope dictionary
        The ID that we inserted gets returned because some visitors
        need the ID for some additional work. In the cases where the returned
        ID isn&#39;t needed it gets ignored.

        Args:
            scope_dict (Dict): _description_
            dict_key (str): _description_
        &#34;&#34;&#34;
        new_id_to_insert = self.id_count
        scope_dict[dict_key] = new_id_to_insert
        self.id_count += 1
        return new_id_to_insert

    def insert_alias(self, originString, alias):
        &#34;&#34;&#34;Inserts an alias into a dictionary that keeps track of aliases for
            names that are aliased. For example, the following import
            import numpy as np
            np is an alias for the original name numpy

        Args:
            original (String): The original name that is being aliased
            alias    (String): The alias of the original name
        &#34;&#34;&#34;
        # TODO
        pass

    def check_alias(self, name):
        &#34;&#34;&#34;Given a python string that represents a name,
        this function checks to see if that name is an alias
        for a different name, and returns it if it is indeed an alias.
        Otherwise, the original name is returned.
        &#34;&#34;&#34;
        if name in self.aliases:
            return self.aliases[name]
        else:
            return name

    def identify_piece(
        self,
        piece: AstNode,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;This function is used to &#39;centralize&#39; the handling of different node types
        in list/dictionary/set comprehensions.
        Take the following list comprehensions as examples
        L = [ele**2 for small_l in d         for ele in small_l]   -- comp1
        L = [ele**2 for small_l in foo.bar() for ele in small_l]   -- comp2
        L = [ele**2 for small_l in foo.baz   for ele in small_l]   -- comp3
               F1         F2        F3            F4      F5

        In these comprehensions F3 has a different type for its node
            - In comp1 it&#39;s a list
            - In comp2 it&#39;s an attribute of an object with a function call
            - In comp3 it&#39;s an attribute of an object without a function call

        The code that handles comprehensions generates slightly different AST depending
        on what type these fields (F1 through F5) are, but this handling becomes very repetitive
        and difficult to maintain if it&#39;s written in the comprehension visitors. Thus, this method
        is to contain that handling in one place. This method acts on one field at a time, and thus will
        be called multiple times per comprehension as necessary.

        Args:
            piece (AstNode): The current Python AST node we&#39;re looking at, generally an individual field
                             of the list comprehension
            prev_scope_id_dict (Dict): Scope dictionaries in case something needs to be accessed or changed
            curr_scope_id_dict (Dict): see above

        [ELT for TARGET in ITER]
          F1       F2      F3
        F1 - doesn&#39;t need to be handled here because that&#39;s just code that is done somewhere else
        F2/F4 - commonly it&#39;s a Name or a Tuple node
        F3/F5 - generally a list, or something that gives back a list like:
                * a subscript
                * an attribute of an object with or w/out a function call
        &#34;&#34;&#34;
        if isinstance(piece, ast.Tuple):  # for targets (generator.target)
            return piece
        elif isinstance(piece, ast.Name):
            ref = [
                self.filenames[-1],
                piece.col_offset,
                piece.end_col_offset,
                piece.lineno,
                piece.end_lineno,
            ]
            # return ast.Name(id=piece.id, ctx=ast.Store(), col_offset=None, end_col_offset=None, lineno=None, end_lineno=None)
            return ast.Name(
                id=piece.id,
                ctx=ast.Store(),
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        elif isinstance(piece, ast.Subscript):  # for iters (generator.iter)
            return piece.value
        elif isinstance(piece, ast.Call):
            return piece.func
        else:
            return piece

    def find_function(module_node: ast.Module, f_name: str):
        &#34;&#34;&#34;Given a PyAST Module node, we search for a particular FunctionDef node
        which is given to us by its function name f_name.

        This function searches at the top level, that is it only searches FunctionDefs that
        exist at the module level, and will not search deeper for functions within functions.
        &#34;&#34;&#34;
        for stmt in module_node.body:
            if isinstance(stmt, ast.FunctionDef) and stmt.name == f_name:
                return stmt

        return None

    def create_cond(self, node, prev_scope_id_dict, curr_scope_id_dict):
        &#34;&#34;&#34;Used in while and if statement creation.
        This function determines what kind of conditional we have for an if statement or a while loop
        Either the conditional explicitly checks a value using a comparison operator or it doesnt
        In the case that it doesn&#39;t explicitly then we have to add in an explicit check
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        test_cond = self.visit(
            node.test, prev_scope_id_dict, curr_scope_id_dict
        )[0]
        bool_func = &#34;bool&#34;
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(True))]
        true_val = LiteralValue(
            ScalarType.BOOLEAN,
            &#34;True&#34;,
            source_code_data_type=source_code_data_type,
            source_refs=ref,
        )
        if isinstance(node.test, (ast.Name, ast.Constant)):
            if bool_func not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if bool_func not in self.global_identifier_dict.keys():
                    self.insert_next_id(self.global_identifier_dict, bool_func)

                prev_scope_id_dict[bool_func] = self.global_identifier_dict[
                    bool_func
                ]
            bool_call = Call(
                func=Name(
                    &#34;bool&#34;, id=prev_scope_id_dict[bool_func], source_refs=ref
                ),
                arguments=[test_cond],
                source_refs=ref,
            )
            test = [Operator(source_language=&#34;Python&#34;, 
                        interpreter=&#34;Python&#34;, 
                        version=get_python_version(), 
                        op=&#34;ast.Eq&#34;, 
                        operands=[bool_call,true_val], 
                        source_refs=ref)]

        elif isinstance(node.test, ast.UnaryOp) and isinstance(
            node.test.operand, (ast.Name, ast.Constant, ast.Call)
        ):
            if bool_func not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if bool_func not in self.global_identifier_dict.keys():
                    self.insert_next_id(self.global_identifier_dict, bool_func)

                prev_scope_id_dict[bool_func] = self.global_identifier_dict[
                    bool_func
                ]
            bool_call = Call(
                func=Name(
                    &#34;bool&#34;, id=prev_scope_id_dict[bool_func], source_refs=ref
                ),
                arguments=[test_cond],
                source_refs=ref,
            )
            test = [Operator(source_language=&#34;Python&#34;, 
                        interpreter=&#34;Python&#34;, 
                        version=get_python_version(), 
                        op=&#34;ast.Eq&#34;, 
                        operands=[bool_call,true_val], 
                        source_refs=ref)]

        else:
            test = test_cond

        return test

    @singledispatchmethod
    def visit(
        self, node: AstNode, prev_scope_id_dict, curr_scope_id_dict
    ):
        # print(f&#34;Trying to visit a node of type {type(node)} but a visitor doesn&#39;t exist&#34;)
        # if(node != None):
        #    print(f&#34;This is at line {node.lineno}&#34;)
        pass

    @visit.register
    def visit_JoinedStr(
        self,
        node: ast.JoinedStr,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;JoinedStr not generating CAST yet&#34;)
        str_pieces = []
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        for s in node.values:
            source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(&#34;str&#34;))]
            if isinstance(s, ast.Str):
                str_pieces.append(
                    LiteralValue(
                        StructureType.LIST, s.s, source_code_data_type, ref
                    )
                )
            else:
                f_string_val = self.visit(
                    s.value, prev_scope_id_dict, curr_scope_id_dict
                )
                str_pieces.append(
                    LiteralValue(
                        StructureType.LIST,
                        f_string_val,
                        source_code_data_type,
                        ref,
                    )
                )

        unique_name = construct_unique_name(self.filenames[-1], &#34;Concatenate&#34;)
        if unique_name not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if unique_name not in self.global_identifier_dict.keys():
                self.insert_next_id(self.global_identifier_dict, unique_name)

            prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]
        return [
            Call(
                func=Name(
                    &#34;Concatenate&#34;,
                    id=prev_scope_id_dict[unique_name],
                    source_refs=ref,
                ),
                arguments=str_pieces,
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_GeneratorExp(
        self,
        node: ast.GeneratorExp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        ref = [
            node.col_offset,
            node.end_col_offset,
            node.lineno,
            node.end_lineno,
        ]
        to_visit = ast.ListComp(
            elt=node.elt,
            generators=node.generators,
            lineno=ref[2],
            col_offset=ref[0],
            end_lineno=ref[3],
            end_col_offset=ref[1],
        )

        return self.visit(to_visit, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Delete(
        self,
        node: ast.Delete,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;Delete not generating CAST yet&#34;)
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Ellipsis(
        self,
        node: ast.Ellipsis,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;Ellipsis&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                ScalarType.ELLIPSIS, &#34;...&#34;, source_code_data_type, ref
            )
        ]

    @visit.register
    def visit_Slice(
        self,
        node: ast.Slice,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;Slice not generating CAST yet&#34;)
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=-1,
                col_end=-1,
                row_start=-1,
                row_end=-1,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_ExtSlice(
        self,
        node: ast.ExtSlice,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;ExtSlice not generating CAST yet&#34;)
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=-1,
                col_end=-1,
                row_start=-1,
                row_end=-1,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Assign(
        self,
        node: ast.Assign,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Assign node, and returns its CAST representation.
        Either the assignment is simple, like x = {expression},
        or the assignment is complex, like x = y = z = ... {expression}
        Which determines how we generate the CAST for this node.

        Args:
            node (ast.Assign): A PyAST Assignment node.

        Returns:
            Assignment: An assignment CAST node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        left = []
        right = []

        if len(node.targets) == 1:  
            # x = 1, or maybe x = y, in general x = {expression}
            if isinstance(node.targets[0], ast.Subscript):  
                # List subscript nodes get replaced out by
                # A function call to a &#34;list_set&#34;
                sub_node = node.targets[0]
                if isinstance(node.value, ast.Subscript):
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;_get&#34;
                    )
                    if unique_name not in prev_scope_id_dict.keys():
                        # If a built-in is called, then it gets added to the global dictionary if
                        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                        # function
                        if (
                            unique_name
                            not in self.global_identifier_dict.keys()
                        ):
                            self.insert_next_id(
                                self.global_identifier_dict, unique_name
                            )

                        prev_scope_id_dict[
                            unique_name
                        ] = self.global_identifier_dict[unique_name]
                    idx = self.visit(
                        node.value.slice,
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                    val = self.visit(
                        node.value.value,
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                    args = [val, idx]

                    val = Call(
                        func=Name(
                            &#34;_get&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    )
                else:
                    val = self.visit(
                        node.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]

                idx = self.visit(
                    sub_node.slice, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                list_name = self.visit(
                    sub_node.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                # print(&#34;-------------&#34;)
                # print(type(node.value))
                # print(type(sub_node.slice))
                # print(type(sub_node.value))
                # print(&#34;-------------&#34;)

                # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
                # This should only be the case for built-in python functions (i.e print, len, etc...)
                # Otherwise it would be an error to call a function before it is defined
                # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
                unique_name = construct_unique_name(self.filenames[-1], &#34;_set&#34;)
                if unique_name not in prev_scope_id_dict.keys():

                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if unique_name not in self.global_identifier_dict.keys():
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]

                args = [list_name, idx, val]
                return [
                    Assignment(
                        Var(val=list_name, type=&#34;Any&#34;, source_refs=ref),
                        Call(
                            func=Name(
                                &#34;_set&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        ),
                        source_refs=ref,
                    )
                ]

            if isinstance(node.value, ast.Subscript):

                # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
                # This should only be the case for built-in python functions (i.e print, len, etc...)
                # Otherwise it would be an error to call a function before it is defined
                # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
                unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
                if unique_name not in prev_scope_id_dict.keys():

                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if unique_name not in self.global_identifier_dict.keys():
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]

                var_name = self.visit(
                    node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                )[0]
                idx = self.visit(
                    node.value.slice, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                val = self.visit(
                    node.value.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                args = [val, idx]
                return [
                    Assignment(
                        var_name,
                        Call(
                            func=Name(
                                &#34;_get&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        ),
                        source_refs=ref,
                    )
                ]

            if isinstance(node.value, ast.BinOp):  # Checking if we have an assignment of the form
                # x = LIST * NUM or x = NUM * LIST
                binop = node.value
                list_node = None
                operand = None
                if isinstance(binop.left, ast.List):
                    list_node = binop.left
                    operand = binop.right
                elif isinstance(binop.right, ast.List):
                    list_node = binop.right
                    operand = binop.left

                if list_node is not None:
                    cons = ValueConstructor()
                    lit_type = (
                        ScalarType.ABSTRACTFLOAT
                        if type(list_node.elts[0].value) == float
                        else ScalarType.INTEGER
                    )
                    cons.dim = None
                    t = get_op(binop.op)
                    cons.operator = (
                        &#34;*&#34;
                        if get_op(binop.op) == &#34;Mult&#34;
                        else &#34;+&#34;
                        if get_op(binop.op) == &#34;Add&#34;
                        else None
                    )
                    cons.size = self.visit(
                        operand, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    cons.initial_value = LiteralValue(
                        value_type=lit_type,
                        value=list_node.elts[0].value,
                        source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                        source_refs=ref,
                    )

                    # TODO: Source code data type metadata
                    to_ret = LiteralValue(
                        value_type=&#34;List[Any]&#34;,
                        value=cons,
                        source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                        source_refs=ref,
                    )
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;_get&#34;
                    )
                    if unique_name not in prev_scope_id_dict.keys():

                        # If a built-in is called, then it gets added to the global dictionary if
                        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                        # function
                        if (
                            unique_name
                            not in self.global_identifier_dict.keys()
                        ):
                            self.insert_next_id(
                                self.global_identifier_dict, unique_name
                            )

                        prev_scope_id_dict[
                            unique_name
                        ] = self.global_identifier_dict[unique_name]

                    # TODO: Augment this _List_num constructor with the following
                    # First argument should be a list with the initial amount of elements
                    # Then second arg is how many times to repeat that
                    # When we say List for the first argument: It should be a literal value List that holds the elements
                    to_ret = Call(
                        func=Name(
                            &#34;_List_num&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=[cons.initial_value, cons.size],
                        source_refs=ref,
                    )

                    # print(to_ret)
                    l_visit = self.visit(
                        node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                    )
                    left.extend(l_visit)
                    return [Assignment(left[0], to_ret, source_refs=ref)]

            l_visit = self.visit(
                node.targets[0], prev_scope_id_dict, curr_scope_id_dict
            )
            r_visit = self.visit(
                node.value, prev_scope_id_dict, curr_scope_id_dict
            )
            left.extend(l_visit)
            right.extend(r_visit)
        elif len(node.targets) &gt; 1:
            # x = y = z = ... {Expression} (multiple assignments in one line)
            left.extend(
                self.visit(
                    node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                )
            )
            node.targets = node.targets[1:]
            right.extend(
                self.visit(node, prev_scope_id_dict, curr_scope_id_dict)
            )
        else:
            raise ValueError(
                f&#34;Unexpected number of targets for node: {len(node.targets)}&#34;
            )

        # ref = [SourceRef(source_file_name=self.filenames[-1], col_start=node.col_offset, col_end=node.end_col_offset, row_start=node.lineno, row_end=node.end_lineno)]

        return [Assignment(left[0], right[0], source_refs=ref)]

    @visit.register
    def visit_Attribute(
        self,
        node: ast.Attribute,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Attribute node, which is used when accessing
        the attribute of a class. Whether it&#39;s a field or method of a class.

        Args:
            node (ast.Attribute): A PyAST Attribute node

        Returns:
            Attribute: A CAST Attribute node representing an Attribute access
        &#34;&#34;&#34;
        # node.value and node.attr
        # node.value is some kind of AST node
        # node.attr is a string (or perhaps name)

        # node.value.id gets us module name (string)
        # node.attr gets us attribute we&#39;re accessing (string)
        # helper(node.attr) -&gt; &#34;module_name&#34;.node.attr

        # x.T -&gt; node.value: the node x (Name) -&gt; node.attr is just &#34;T&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        value_cast = self.visit(
            node.value, prev_scope_id_dict, curr_scope_id_dict
        )
        unique_name = (
            node.attr
        )  # TODO: This unique name might change to better reflect what it belongs to (i.e. x.T instead of just T)

        if isinstance(node.ctx, ast.Load):
            if unique_name not in curr_scope_id_dict:
                if unique_name in prev_scope_id_dict:
                    curr_scope_id_dict[unique_name] = prev_scope_id_dict[
                        unique_name
                    ]
                else:
                    if (
                        unique_name not in self.global_identifier_dict
                    ):  # added for random.seed not exising, and other modules like that. in other words for functions in modules that we don&#39;t have visibility for.
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )
                    curr_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]
        if isinstance(node.ctx, ast.Store):
            if unique_name not in curr_scope_id_dict:
                if unique_name in prev_scope_id_dict:
                    curr_scope_id_dict[unique_name] = prev_scope_id_dict[
                        unique_name
                    ]
                else:
                    self.insert_next_id(curr_scope_id_dict, unique_name)

        attr_cast = Name(
            name=node.attr, id=curr_scope_id_dict[unique_name], source_refs=ref
        )

        return [Attribute(value_cast[0], attr_cast, source_refs=ref)]

    @visit.register
    def visit_AugAssign(
        self,
        node: ast.AugAssign,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST AugAssign node, which is used for an
        augmented assignment, like x += 1. AugAssign node is converted
        to a regular PyAST Assign node and passed to that visitor to
        generate CAST.

        Args:
            node (ast.AugAssign): A PyAST AugAssign node

        Returns:
            Assign: A CAST Assign node, generated by the Assign visitor.
        &#34;&#34;&#34;

        # Convert AugAssign to regular Assign, and visit
        target = node.target
        value = node.value

        if isinstance(target, ast.Attribute):
            convert = ast.Assign(
                targets=[target],
                value=ast.BinOp(
                    left=target,
                    op=node.op,
                    right=value,
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )
        elif isinstance(target, ast.Subscript):
            convert = ast.Assign(
                targets=[target],
                value=ast.BinOp(
                    left=target,
                    ctx=ast.Load(),
                    op=node.op,
                    right=value,
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )
        else:
            convert = ast.Assign(
                targets=[target],
                value=ast.BinOp(
                    left=ast.Name(
                        target.id,
                        ctx=ast.Load(),
                        col_offset=node.col_offset,
                        end_col_offset=node.end_col_offset,
                        lineno=node.lineno,
                        end_lineno=node.end_lineno,
                    ),
                    op=node.op,
                    right=value,
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )

        return self.visit(convert, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_BinOp(
        self,
        node: ast.BinOp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST BinOp node, which consists of all the arithmetic
        and bitwise operators.

        Args:
            node (ast.BinOp): A PyAST Binary operator node

        Returns:
            Operator: A CAST operator node representing a math
                      operation (arithmetic or bitwise)
        &#34;&#34;&#34;

        left = self.visit(node.left, prev_scope_id_dict, curr_scope_id_dict)
        op = get_op(node.op)
        right = self.visit(node.right, prev_scope_id_dict, curr_scope_id_dict)

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        leftb = []
        rightb = []

        if len(left) &gt; 1:
            leftb = left[0:-1]
        if len(right) &gt; 1:
            rightb = right[0:-1]

        return (
            leftb 
            + rightb
            + [Operator(source_language=&#34;Python&#34;, 
                        interpreter=&#34;Python&#34;, 
                        version=get_python_version(), 
                        op=op, 
                        operands=[left[-1], right[-1]], 
                        source_refs=ref)]
        )

    @visit.register
    def visit_Break(
        self,
        node: ast.Break,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Break node, which is just a break statement
           nothing to be done for a Break node, just return a ModelBreak()
           object

        Args:
            node (ast.Break): An AST Break node

        Returns:
            ModelBreak: A CAST Break node

        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [ModelBreak(source_refs=ref)]

    def create_binary_compare_tree(self, node):
        if isinstance(node, (ast.Compare, ast.UnaryOp, ast.Call, ast.Name, ast.Attribute, ast.Constant, ast.Subscript)):
            return node
        # elif isinstance(node, ast.UnaryOp):
        #    return node
        #elif isinstance(node, ast.Call):
         #   return node
        elif isinstance(node, ast.BoolOp):
            # &gt; 2 values implies nested &#39;and&#39; or &#39;or&#39;
            if len(node.values) &gt; 2:
                op = [node.op]
                # left_most = self.create_binary_compare_tree(node.values[0])
                # Build binary trees of ast.Compare nodes their children being 
                # the original leaves
                # In other words decompress the tree so it&#39;s binary instead of n-ary

                idx = len(node.values) - 1
                tree_root = None
                while idx &gt;= 0:
                    if tree_root == None:        
                        left_child = self.create_binary_compare_tree(node.values[idx - 1]) 
                        right_child = self.create_binary_compare_tree(node.values[idx]) 

                        compare_op = ast.Compare(
                            left=left_child,
                            ops=op,
                            comparators=[right_child],
                            col_offset=node.col_offset,
                            end_col_offset=node.end_col_offset,
                            lineno=node.lineno,
                            end_lineno=node.end_lineno,
                        )

                        tree_root = compare_op
                        idx = idx - 2
                    else:
                        left_child = self.create_binary_compare_tree(node.values[idx])

                        compare_op = ast.Compare(
                            left=left_child,
                            ops=op,
                            comparators=[tree_root],
                            col_offset=node.col_offset,
                            end_col_offset=node.end_col_offset,
                            lineno=node.lineno,
                            end_lineno=node.end_lineno,
                        )

                        tree_root = compare_op
                        idx = idx - 1

                return tree_root
            else:
                op = [node.op]

                left_child = self.create_binary_compare_tree(node.values[0])
                right_child = self.create_binary_compare_tree(node.values[1])
                compare_op = ast.Compare(
                    left=left_child,
                    ops=op,
                    comparators=[right_child],
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                )
                
                return compare_op
        print(f&#34;catch type {type(node)}&#34;)

    @visit.register
    def visit_BoolOp(
        self,
        node: ast.BoolOp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a BoolOp node, which is a boolean operation connected with &#39;and&#39;/&#39;or&#39;s
           The BoolOp node gets converted into an AST Compare node, and then the work is
           passed off to it.

        Args:
            node (ast.BoolOp): An AST BoolOp node

        Returns:
            BinaryOp: A BinaryOp node that is composed of operations connected with &#39;and&#39;/&#39;or&#39;s

        &#34;&#34;&#34;
        
        x = self.create_binary_compare_tree(node)
        &#34;&#34;&#34;
        print(&#34;Root&#34;)
        print(x.ops)
        print(x.left)
        print(x.comparators)

        print(&#34;Left&#34;)
        print(x.left.ops)
        print(x.left.left)
        print(x.left.comparators)

        print(&#34;Right&#34;)
        print(x.comparators[0].ops)
        print(x.comparators[0].left)
        print(x.comparators[0].comparators)
        &#34;&#34;&#34;

        return self.visit(x, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Call(
        self,
        node: ast.Call,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Call node, which represents a function call.
        Special care must be taken to see if it&#39;s a function call or a class&#39;s
        method call. The CAST is generated a little different depending on
        what kind of call it is.

        Args:
            node (ast.Call): a PyAST Call node

        Returns:
            Call: A CAST function call node
        &#34;&#34;&#34;

        args = []
        func_args = []
        kw_args = []
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        if len(node.args) &gt; 0:
            for arg in node.args:
                if isinstance(arg, ast.Subscript):
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;_get&#34;
                    )
                    if unique_name not in prev_scope_id_dict.keys():
                        # If a built-in is called, then it gets added to the global dictionary if
                        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                        # function
                        if (
                            unique_name
                            not in self.global_identifier_dict.keys()
                        ):
                            self.insert_next_id(
                                self.global_identifier_dict, unique_name
                            )

                        prev_scope_id_dict[
                            unique_name
                        ] = self.global_identifier_dict[unique_name]
                    idx = self.visit(
                        arg.slice, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    val = self.visit(
                        arg.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    args = [val, idx]

                    func_args.extend(
                        [
                            Call(
                                func=Name(
                                    &#34;_get&#34;,
                                    id=prev_scope_id_dict[unique_name],
                                    source_refs=ref,
                                ),
                                arguments=args,
                                source_refs=ref,
                            )
                        ]
                    )
                elif isinstance(arg, ast.Starred):
                    if isinstance(arg.value, ast.Subscript):
                        func_args.append(
                            Name(
                                name=arg.value.value.id, id=-1, source_refs=ref
                            )
                        )
                    else:
                        func_args.append(
                            Name(name=arg.value.id, id=-1, source_refs=ref)
                        )
                else:
                    res = self.visit(
                        arg, prev_scope_id_dict, curr_scope_id_dict
                    )
                    if res != None:
                        func_args.extend(res)

        # g(3,id=4) TODO: Think more about this
        if len(node.keywords) &gt; 0:
            for arg in node.keywords:
                # print(prev_scope_id_dict)
                # print(curr_scope_id_dict)
                if arg.arg != None:
                    val = self.visit(
                        arg.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]

                    assign_node = Assignment(
                        left=Var(
                            Name(
                                name=arg.arg, id=100, source_refs=ref
                            ),  # TODO: add a proper ID here
                            type=&#34;float&#34;,
                            source_refs=ref,
                        ),
                        right=val,
                        source_refs=ref,
                    )
                elif isinstance(arg.value, ast.Dict):
                    val = self.visit(
                        arg.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    assign_node = val
                else:
                    if isinstance(arg.value, ast.Attribute) and isinstance(
                        arg.value.value, ast.Attribute
                    ):
                        assign_node = Name(
                            name=arg.value.value.attr, id=-1, source_refs=ref
                        )
                    elif isinstance(arg.value, ast.Call):
                        assign_node = Name(
                            name=arg.value.func.id, id=-1, source_refs=ref
                        )
                    elif isinstance(arg.value, ast.Attribute):
                        assign_node = Name(
                            name=arg.value.value, id=-1, source_refs=ref
                        )
                    elif isinstance(arg.value, ast.Subscript):
                        assign_node = Name(
                            name=arg.value.value.id, id=-1, source_refs=ref
                        )
                    else:
                        assign_node = Name(
                            name=arg.value.id, id=-1, source_refs=ref
                        )
                kw_args.append(assign_node)
                # kw_args.extend(self.visit(arg.value, prev_scope_id_dict, curr_scope_id_dict))

        args = func_args + kw_args

        if isinstance(node.func, ast.Attribute):
            # print(node.func.attr)
            res = self.visit(node.func, prev_scope_id_dict, curr_scope_id_dict)
            return [Call(func=res[0], arguments=args, source_refs=ref)]
        else:
            # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
            # This should only be the case for built-in python functions (i.e print, len, etc...)
            # Otherwise it would be an error to call a function before it is defined
            # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
            if isinstance(node.func, ast.Call):
                if node.func.func.id == &#34;list&#34;:
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;cast&#34;
                    )
                else:
                    unique_name = construct_unique_name(
                        self.filenames[-1], node.func.func.id
                    )
            else:
                if node.func.id == &#34;list&#34;:
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;cast&#34;
                    )
                else:
                    unique_name = construct_unique_name(
                        self.filenames[-1], node.func.id
                    )
            if unique_name not in prev_scope_id_dict.keys(): # and unique_name not in curr_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]

            if isinstance(node.func, ast.Call):
                if node.func.func.id == &#34;list&#34;:
                    args.append(
                        LiteralValue(
                            StructureType.LIST,
                            node.func.func.id,
                            [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                            ref,
                        )
                    )
                    return [
                        Call(
                            func=Name(
                                &#34;cast&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
                else:
                    return [
                        Call(
                            func=Name(
                                node.func.func.id,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
            else:
                if node.func.id == &#34;list&#34;:
                    args.append(
                        LiteralValue(
                            StructureType.LIST,
                            node.func.id,
                            [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                            ref,
                        )
                    )
                    return [
                        Call(
                            func=Name(
                                &#34;cast&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
                else:
                    return [
                        Call(
                            func=Name(
                                node.func.id,
                                id=curr_scope_id_dict[unique_name] if unique_name in curr_scope_id_dict else prev_scope_id_dict[unique_name], # NOTE: do this everywhere?
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]

    def collect_fields(
        self, node: ast.FunctionDef, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Attempts to solve the problem of collecting any additional fields
        for a class that get created in functions outside of __init__
        &#34;&#34;&#34;
        fields = []
        for n in node.body:
            if isinstance(n, ast.Assign) and isinstance(
                n.targets[0], ast.Attribute
            ):
                attr_node = n.targets[0]
                if isinstance(attr_node.value, ast.Attribute):
                    if attr_node.value.value == &#34;self&#34;:
                        ref = [
                            SourceRef(
                                source_file_name=self.filenames[-1],
                                col_start=attr_node.col_offset,
                                col_end=attr_node.end_col_offset,
                                row_start=attr_node.lineno,
                                row_end=attr_node.end_lineno,
                            )
                        ]
                        # Need IDs for name, which one?
                        attr_id = self.insert_next_id(
                            curr_scope_id_dict, attr_node.value.attr
                        )
                        fields.append(
                            Var(
                                Name(
                                    attr_node.value.attr,
                                    id=attr_id,
                                    source_refs=ref,
                                ),
                                &#34;float&#34;,
                                source_refs=ref,
                            )
                        )
                elif attr_node.value.id == &#34;self&#34;:
                    ref = [
                        SourceRef(
                            source_file_name=self.filenames[-1],
                            col_start=attr_node.col_offset,
                            col_end=attr_node.end_col_offset,
                            row_start=attr_node.lineno,
                            row_end=attr_node.end_lineno,
                        )
                    ]
                    # Need IDs for name, which one?
                    attr_id = self.insert_next_id(
                        curr_scope_id_dict, attr_node.attr
                    )
                    fields.append(
                        Var(
                            Name(attr_node.attr, id=attr_id, source_refs=ref),
                            &#34;float&#34;,
                            source_refs=ref,
                        )
                    )

        return fields

    @visit.register
    def visit_ClassDef(
        self,
        node: ast.ClassDef,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST ClassDef node, which is used to define user classes.
        Acquiring the fields of the class involves going through the __init__
        function and seeing if the attributes are associated with the self
        parameter. In addition, we add to the &#39;classes&#39; dictionary the name of
        the class and a list of all its functions.

        Args:
            node (ast.ClassDef): A PyAST class definition node

        Returns:
            ClassDef: A CAST class definition node
        &#34;&#34;&#34;
        name = node.name
        self.classes[name] = []

        bases = []
        for base in node.bases:
            bases.extend(
                self.visit(base, prev_scope_id_dict, curr_scope_id_dict)
            )

        fields = []
        funcs = []
        for func in node.body:
            if isinstance(func, ast.FunctionDef):
                if func.name != &#34;__init__&#34;:
                    fields.extend(
                        self.collect_fields(
                            func, prev_scope_id_dict, curr_scope_id_dict
                        )
                    )
                funcs.extend(
                    self.visit(func, prev_scope_id_dict, curr_scope_id_dict)
                )
                # curr_scope_id_dict = {}
                # if isinstance(func,ast.FunctionDef):
                self.classes[name].append(func.name)
                # self.insert_next_id(prev_scope_id_dict, name)
                self.insert_next_id(prev_scope_id_dict, f&#34;{name}.{func.name}&#34;)

        # print(prev_scope_id_dict)
        # print(curr_scope_id_dict)
        # Get the fields in the class from init
        init_func = None
        for f in node.body:
            if isinstance(f, ast.FunctionDef) and f.name == &#34;__init__&#34;:
                init_func = f.body
                break

        if init_func != None:
            for func_node in init_func:
                if isinstance(func_node, ast.Assign) and isinstance(
                    func_node.targets[0], ast.Attribute
                ):
                    attr_node = func_node.targets[0]
                    if attr_node.value.id == &#34;self&#34;:
                        ref = [
                            SourceRef(
                                source_file_name=self.filenames[-1],
                                col_start=attr_node.col_offset,
                                col_end=attr_node.end_col_offset,
                                row_start=attr_node.lineno,
                                row_end=attr_node.end_lineno,
                            )
                        ]
                        # Need IDs for name, which one?
                        attr_id = self.insert_next_id(
                            curr_scope_id_dict, attr_node.attr
                        )
                        fields.append(
                            Var(
                                Name(
                                    attr_node.attr, id=attr_id, source_refs=ref
                                ),
                                &#34;float&#34;,
                                source_refs=ref,
                            )
                        )

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [RecordDef(name, bases, funcs, fields, source_refs=ref)]

    @visit.register
    def visit_Compare(
        self,
        node: ast.Compare,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Compare node, which consists of boolean operations

        Args:
            node (ast.Compare): A PyAST Compare node

        Returns:
            Operator: An Operator node, which in this case will hold a boolean
            operation
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]


        # Fetch the first element (which is in node.left)
        #left = node.left
        #ops = [op for op in node.ops]
        # Grab the first comparison operation
        # print(left)
        # print(node.ops)
        # op = get_op(node.ops.pop(0))
        # op = get_op(ops.pop())

        
        # maintain a stack of if statements that we build up
        if_stack = []
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(True))]
        true_val = LiteralValue(
            ScalarType.BOOLEAN,
            &#34;True&#34;,
            source_code_data_type=source_code_data_type,
            source_refs=ref,
        )
        false_val = LiteralValue(
            ScalarType.BOOLEAN,
            &#34;False&#34;,
            source_code_data_type=source_code_data_type,
            source_refs=ref,
        )


        idx = len(node.comparators) - 1
        op_idx = len(node.ops) - 1
        tree_root = None
        while idx &gt; 0:
            op = get_op(node.ops[op_idx])
            l = self.visit(node.comparators[idx - 1], prev_scope_id_dict, curr_scope_id_dict)[0]
            r = self.visit(node.comparators[idx], prev_scope_id_dict, curr_scope_id_dict)[0] 

            if op == &#34;ast.And&#34;:
                test = ModelIf(expr=l, body=[r], orelse=[false_val], source_refs=ref)
            elif op == &#34;ast.Or&#34;:
                test = ModelIf(expr=l, body=[true_val], orelse=[r], source_refs=ref)
            else:
                test = Operator(source_language=&#34;Python&#34;, interpreter=&#34;Python&#34;,
                                version=get_python_version(),
                                op=op,
                                operands=[l,r],
                                source_refs=ref)
            if tree_root == None:        
                tree_root = test
            else:
                tree_root = ModelIf(expr=test,body=[tree_root],orelse=[false_val], source_refs=ref)

            op_idx = op_idx - 1
            idx = idx - 1

        op = get_op(node.ops[op_idx])
        l = self.visit(node.left, prev_scope_id_dict, curr_scope_id_dict)[0]
        r = self.visit(node.comparators[idx], prev_scope_id_dict, curr_scope_id_dict)[0] 
        if op == &#34;ast.And&#34;:
            test = ModelIf(expr=l, body=[r], orelse=[false_val], source_refs=ref)
        elif op == &#34;ast.Or&#34;:
            test = ModelIf(expr=l, body=[true_val], orelse=[r], source_refs=ref)
        else:
            test = Operator(source_language=&#34;Python&#34;, interpreter=&#34;Python&#34;,
                            version=get_python_version(),
                            op=op,
                            operands=[l,r],
                            source_refs=ref)

        if tree_root == None:
            tree_root = test
        else:
            tree_root = ModelIf(expr=test,body=[tree_root],orelse=[false_val], source_refs=ref)

        return [tree_root]


    @visit.register
    def visit_Constant(
        self,
        node: ast.Constant,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Constant node, which can hold either numeric or
        string values. A dictionary is used to index into which operation
        we&#39;re doing.

        Args:
            node (ast.Constant): A PyAST Constant node

        Returns:
            Number: A CAST numeric node, if the node&#39;s value is an int or float
            String: A CAST string node, if the node&#39;s value is a string
            Boolean: A CAST boolean node, if the node&#39;s value is a boolean

        Raises:
            TypeError: If the node&#39;s value is something else that isn&#39;t
                       recognized by the other two cases
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(node.value))]
        # NOTE: We have to check the types such that no ancestor is checked before a descendant
        # boolean values are also seen as integers with isinstance()
        # TODO: Consider using type() with a map instead of isinstance to check types
        if isinstance(node.value, bool):
            return [
                LiteralValue(
                    ScalarType.BOOLEAN,
                    str(node.value),
                    source_code_data_type,
                    ref,
                )
            ]
        elif isinstance(node.value, int):
            return [
                LiteralValue(
                    ScalarType.INTEGER, node.value, source_code_data_type, ref
                )
            ]
        elif isinstance(node.value, float):
            return [
                LiteralValue(
                    ScalarType.ABSTRACTFLOAT,
                    node.value,
                    source_code_data_type,
                    ref,
                )
            ]
        elif isinstance(node.value, str):
            return [
                LiteralValue(
                    StructureType.LIST, node.value, source_code_data_type, ref
                )
            ]
        elif node.value is None:
            return [LiteralValue(None, None, source_code_data_type, ref)]
        elif isinstance(node.value, type(...)):
            return []
        else:
            raise TypeError(f&#34;Type {str(type(node.value))} not supported&#34;)

    @visit.register
    def visit_Continue(
        self,
        node: ast.Continue,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Continue node, which is just a continue statement
           nothing to be done for a Continue node, just return a ModelContinue node

        Args:
            node (ast.Continue): An AST Continue node

        Returns:
            ModelContinue: A CAST Continue node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [ModelContinue(source_refs=ref)]

    @visit.register
    def visit_Dict(
        self,
        node: ast.Dict,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Dict node, which represents a dictionary.

        Args:
            node (ast.Dict): A PyAST dictionary node

        Returns:
            Dict: A CAST Dictionary node.
        &#34;&#34;&#34;
        # TODO: when a ** shows up in a dictionary

        keys = []
        values = []
        if len(node.keys) &gt; 0:
            for piece in node.keys:
                if piece != None:
                    keys.extend(
                        self.visit(
                            piece, prev_scope_id_dict, curr_scope_id_dict
                        )
                    )

        if len(node.values) &gt; 0:
            for piece in node.values:
                if piece != None:
                    values.extend(
                        self.visit(
                            piece, prev_scope_id_dict, curr_scope_id_dict
                        )
                    )

        k = [e.value if hasattr(e, &#34;value&#34;) else e for e in keys]
        v = [e.value if hasattr(e, &#34;value&#34;) else e for e in values]

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        for key in k:
            if isinstance(key, LiteralValue) and key.value_type == StructureType.TUPLE:
                return [
                    LiteralValue(
                        StructureType.MAP,
                        &#34;&#34;,
                        source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, str(dict)],
                        source_refs=ref,
                    )
                ]

        # return [LiteralValue(StructureType.MAP, str(dict(list(zip(k,v)))), source_code_data_type=[&#34;Python&#34;,&#34;3.8&#34;,str(dict)], source_refs=ref)]
        return [
            LiteralValue(
                StructureType.MAP,
                str(list(zip(k, v))),
                source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, str(dict)],
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_Expr(
        self,
        node: ast.Expr,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Expr node, which represents some kind of standalone
        expression.

        Args:
            node (ast.Expr): A PyAST Expression node

        Returns:
            Expr:      A CAST Expression node
            [AstNode]: A list of AstNodes if the expression consists
                       of more than one node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_For(
        self, node: ast.For, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST For node, which represents Python for loops.
        A For loop needs different handling than a while loop.
        In particular, a For loop acts on an iterator as opposed to acting on
        some kind of condition. In order to make this translation a little easier to handle
        we leverage the iterator constructs to convert the For loop into a while loop using
        the iterators.

        Args:
            node (ast.For): A PyAST For loop node.

        Returns:
            Loop: A CAST loop node, which generically represents both For
                  loops and While loops.
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        target = self.visit(
            node.target, prev_scope_id_dict, curr_scope_id_dict
        )[0]
        iterable = self.visit(
            node.iter, prev_scope_id_dict, curr_scope_id_dict
        )[0]

        # The body of a loop contains its own scope (it can create variables only it can see and can use
        # variables from its enclosing scope) so we copy the current scope and merge scopes
        # to create the enclosing scope for the loop body
        curr_scope_copy = copy.deepcopy(curr_scope_id_dict)
        merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
        loop_scope_id_dict = {}

        # When we pass in scopes, we pass what&#39;s currently in the previous scope along with
        # the curr scope which would consist of the loop variables (node.target) and the item
        # we loop over (iter) though the second one shouldn&#39;t ever be accessed
        body = []
        for piece in node.body + node.orelse:
            body.extend(
                self.visit(piece, curr_scope_id_dict, loop_scope_id_dict)
            )

        # Once we&#39;re out of the loop body we can copy the current scope back
        curr_scope_id_dict = copy.deepcopy(curr_scope_copy)

        # TODO: Mark these as variables that were generated by this script at some point
        # (^ This was a really old request, not sure if it&#39;s still needed at this point)
        iterator_name = f&#34;generated_iter_{self.var_count}&#34;
        self.var_count += 1

        iterator_id = self.insert_next_id(curr_scope_id_dict, iterator_name)

        # &#39;iter&#39; and &#39;next&#39; are python built-ins
        iter_id = -1
        if &#34;iter&#34; not in self.global_identifier_dict.keys():
            iter_id = self.insert_next_id(self.global_identifier_dict, &#34;iter&#34;)
        else:
            iter_id = self.global_identifier_dict[&#34;iter&#34;]

        if &#34;next&#34; not in self.global_identifier_dict.keys():
            next_id = self.insert_next_id(self.global_identifier_dict, &#34;next&#34;)
        else:
            next_id = self.global_identifier_dict[&#34;next&#34;]

        stop_cond_name = f&#34;sc_{self.var_count}&#34;
        self.var_count += 1

        stop_cond_id = self.insert_next_id(curr_scope_id_dict, stop_cond_name)

        iter_var_cast = Var(
            Name(name=iterator_name, id=iterator_id, source_refs=ref),
            &#34;iterator&#34;,
            source_refs=ref,
        )

        stop_cond_var_cast = Var(
            Name(name=stop_cond_name, id=stop_cond_id, source_refs=ref),
            &#34;boolean&#34;,
            source_refs=ref,
        )

        iter_var = Assignment(
            iter_var_cast,
            Call(
                func=Name(name=&#34;iter&#34;, id=iter_id, source_refs=ref),
                arguments=[iterable],
                source_refs=ref,
            ),
            source_refs=ref,
        )

        source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
        first_next = Assignment(
            LiteralValue(StructureType.TUPLE, [target, iter_var_cast, stop_cond_var_cast], source_code_data_type, source_refs=ref),
            Call(
                func=Name(name=&#34;next&#34;, id=next_id, source_refs=ref),
                arguments=[
                    Var(
                        Name(
                            name=iterator_name, id=iterator_id, source_refs=ref
                        ),
                        &#34;iterator&#34;,
                        source_refs=ref,
                    )
                ],
                source_refs=ref,
            ),
            source_refs=ref,
        )
        loop_cond = Operator(source_language=&#34;Python&#34;, 
                    interpreter=&#34;Python&#34;, 
                    version=get_python_version(), 
                    op=&#34;ast.Eq&#34;, 
                    operands=[stop_cond_var_cast,
                    LiteralValue(
                        ScalarType.BOOLEAN,
                        False,
                        [&#34;Python&#34;, &#34;3.8&#34;, &#34;boolean&#34;],
                        source_refs=ref,
                    )], 
                    source_refs=ref)

        source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
        loop_assign = Assignment(
            LiteralValue(StructureType.TUPLE, [target, iter_var_cast, stop_cond_var_cast], source_code_data_type, source_refs=ref),
            Call(
                func=Name(name=&#34;next&#34;, id=next_id, source_refs=ref),
                arguments=[
                    Var(
                        Name(
                            name=iterator_name, id=iterator_id, source_refs=ref
                        ),
                        &#34;iterator&#34;,
                        source_refs=ref,
                    )
                ],
                source_refs=ref,
            ),
            source_refs=ref,
        )

        return [
            Loop(
                pre=[iter_var, first_next],
                expr=loop_cond,
                body=body + [loop_assign],
                post=[],
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_FunctionDef(
        self,
        node: ast.FunctionDef,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST FunctionDef node. Which is used for a Python
        function definition.

        Args:
            node (ast.FunctionDef): A PyAST function definition node

        Returns:
            FunctionDef: A CAST Function Definition node
        &#34;&#34;&#34;

        # Copy the enclosing scope dictionary as it is before we visit the current function
        # The idea for this is to prevent any weird overwritting issues that may arise from modifying
        # dictionaries in place
        prev_scope_id_dict_copy = copy.deepcopy(prev_scope_id_dict)

        body = []
        args = []
        curr_scope_id_dict = {}
        arg_count = len(node.args.args)
        kwonlyargs_count = len(node.args.kwonlyargs)
        default_val_count = len(node.args.defaults)
        if arg_count &gt; 0:
            # No argument has a default value
            if default_val_count == 0:
                for arg in node.args.args:
                    # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                    # self.insert_next_id(curr_scope_id_dict, arg.arg)
                    # self.insert_next_id(curr_scope_id_dict, f&#34;{node.name}.{arg.arg}&#34;)
                    self.insert_next_id(curr_scope_id_dict, f&#34;{arg.arg}&#34;)
                    # self.insert_next_id(curr_scope_id_dict, unique_name)
                    arg_ref = SourceRef(self.filenames[-1], arg.col_offset, arg.end_col_offset, arg.lineno, arg.end_lineno)
                    args.append(
                        Var(
                            Name(
                                arg.arg,
                                id=curr_scope_id_dict[arg.arg],
                                # id=curr_scope_id_dict[f&#34;{node.name}.{arg.arg}&#34;],
                                source_refs=[arg_ref]
                            ),
                            &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                            None,
                            source_refs=[arg_ref]
                        )
                    )
            else:
                # Implies that all arguments have default values
                if arg_count == default_val_count:
                    for i, arg in enumerate(node.args.args, 0):
                        self.insert_next_id(curr_scope_id_dict, arg.arg)
                        val = self.visit(
                            node.args.defaults[i],
                            prev_scope_id_dict,
                            curr_scope_id_dict,
                        )[0]
                        args.append(
                            Var(
                                Name(
                                    arg.arg,
                                    id=curr_scope_id_dict[arg.arg],
                                    source_refs=[
                                        SourceRef(
                                            self.filenames[-1],
                                            arg.col_offset,
                                            arg.end_col_offset,
                                            arg.lineno,
                                            arg.end_lineno,
                                        )
                                    ],
                                ),
                                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                                val,
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            )
                        )

                # There&#39;s less default values than actual args, the positional-only arguments come first
                else:
                    pos_idx = 0
                    for arg in node.args.args:
                        if arg_count == default_val_count:
                            break
                        self.insert_next_id(curr_scope_id_dict, arg.arg)
                        args.append(
                            Var(
                                Name(
                                    arg.arg,
                                    id=curr_scope_id_dict[arg.arg],
                                    source_refs=[
                                        SourceRef(
                                            self.filenames[-1],
                                            arg.col_offset,
                                            arg.end_col_offset,
                                            arg.lineno,
                                            arg.end_lineno,
                                        )
                                    ],
                                ),
                                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                                None,
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            )
                        )

                        pos_idx += 1
                        arg_count -= 1

                    default_index = 0
                    while arg_count &gt; 0:
                        # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                        arg = node.args.args[pos_idx]
                        self.insert_next_id(curr_scope_id_dict, arg.arg)
                        val = self.visit(
                            node.args.defaults[default_index],
                            prev_scope_id_dict,
                            curr_scope_id_dict,
                        )[0]
                        # self.insert_next_id(curr_scope_id_dict, unique_name)
                        args.append(
                            Var(
                                Name(
                                    arg.arg,
                                    id=curr_scope_id_dict[arg.arg],
                                    source_refs=[
                                        SourceRef(
                                            self.filenames[-1],
                                            arg.col_offset,
                                            arg.end_col_offset,
                                            arg.lineno,
                                            arg.end_lineno,
                                        )
                                    ],
                                ),
                                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                                val,
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            )
                        )

                        pos_idx += 1
                        arg_count -= 1
                        default_index += 1

        if kwonlyargs_count &gt; 0:
            for arg in node.args.kwonlyargs:
                # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                self.insert_next_id(curr_scope_id_dict, arg.arg)
                # self.insert_next_id(curr_scope_id_dict, unique_name)
                args.append(
                    Var(
                        Name(
                            arg.arg,
                            id=curr_scope_id_dict[arg.arg],
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        ),
                        &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                        None,
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    )
                )

        # Store &#39;*args&#39; as a name
        arg = node.args.vararg
        if arg != None:
            self.insert_next_id(curr_scope_id_dict, arg.arg)
            args.append(
                Var(
                    Name(
                        arg.arg,
                        id=curr_scope_id_dict[arg.arg],
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    ),
                    &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                    None,
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                )
            )

        # Store &#39;**kwargs&#39; as a name
        arg = node.args.kwarg
        if arg != None:
            self.insert_next_id(curr_scope_id_dict, arg.arg)
            args.append(
                Var(
                    Name(
                        arg.arg,
                        id=curr_scope_id_dict[arg.arg],
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    ),
                    &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                    None,
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                )
            )

        functions_to_visit = []

        if len(node.body) &gt; 0:
            # To account for nested loops we check to see if the CAST node is in a list and
            # extend accordingly

            for piece in node.body:
                if isinstance(piece, ast.Assign):
                    names = get_node_name(piece)

                    for var_name in names:
                        # unique_name = construct_unique_name(
                        #    self.filenames[-1], var_name
                        # )
                        self.insert_next_id(curr_scope_id_dict, var_name)
                            
                    merge_dicts(curr_scope_id_dict, prev_scope_id_dict)
            # merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
            for piece in node.body:

                if isinstance(piece, ast.FunctionDef):
                    unique_name = construct_unique_name(self.filenames[-1], piece.name)
                    self.insert_next_id(curr_scope_id_dict, unique_name)
                    prev_scope_id_dict[unique_name] = curr_scope_id_dict[unique_name]
                    # functions_to_visit.append(piece)
                    #continue

                    # print(curr_scope_id_dict)
                    # print(prev_scope_id_dict)

                # Have to figure out name IDs for imports (i.e. other modules)
                # These asserts will keep us from visiting them from now
                # assert not isinstance(piece, ast.Import)
                # assert not isinstance(piece, ast.ImportFrom)
                to_add = self.visit(
                    piece, prev_scope_id_dict, curr_scope_id_dict
                )

                # TODO: Find the case where &#34;__getitem__&#34; is used
                if hasattr(to_add, &#34;__iter__&#34;) or hasattr(
                    to_add, &#34;__getitem__&#34;
                ):
                    body.extend(to_add)
                elif to_add == None:
                    body.extend([])
                else:
                    raise TypeError(
                        f&#34;Unexpected type in visit_FuncDef: {type(to_add)}&#34;
                    )

            # Merge keys from prev_scope not in cur_scope into cur_scope
            # merge_dicts(prev_scope_id_dict, curr_scope_id_dict)

            # Visit the deferred functions
            #for piece in functions_to_visit:
             #   to_add = self.visit(piece, curr_scope_id_dict, {})
              #  body.extend(to_add)

        # TODO: Decorators? Returns? Type_comment?
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # &#34;Revert&#34; the enclosing scope dictionary to what it was before we went into this function
        # since none of the variables within here should exist outside of here..?
        # TODO: this might need to be different, since Python variables can exist outside of a scope??
        prev_scope_id_dict = copy.deepcopy(prev_scope_id_dict_copy)

        # Global level (i.e. module level) functions have their module names appended to them, we make sure
        # we have the correct name depending on whether or not we&#39;re visiting a global
        # level function or a function enclosed within another function
        if node.name in prev_scope_id_dict.keys():
            if self.legacy:
                return [FunctionDef(node.name, args, body, source_refs=ref)]
            else:
                return [
                    FunctionDef(
                        Name(
                            node.name,
                            prev_scope_id_dict[node.name],
                            source_refs=ref,
                        ),
                        args,
                        body,
                        source_refs=ref,
                    )
                ]
        else:
            unique_name = construct_unique_name(self.filenames[-1], node.name)
            if unique_name in prev_scope_id_dict.keys():
                if self.legacy:
                    return [
                        FunctionDef(node.name, args, body, source_refs=ref)
                    ]
                else:
                    return [
                        FunctionDef(
                            Name(
                                node.name,
                                prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            args,
                            body,
                            source_refs=ref,
                        )
                    ]
            else:
                self.insert_next_id(prev_scope_id_dict, unique_name)
                return [
                    FunctionDef(
                        Name(
                            node.name,
                            prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        args,
                        body,
                        source_refs=ref,
                    )
                ]

    @visit.register
    def visit_Lambda(
        self,
        node: ast.Lambda,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Lambda node. Which is used for a Python Lambda
        function definition. It works pretty analogously to the FunctionDef
        node visitor. It also returns a FunctionDef node like the PyAST
        FunctionDef node visitor.

        Args:
            node (ast.Lambda): A PyAST lambda function definition node

        Returns:
            FunctionDef: A CAST Function Definition node

        &#34;&#34;&#34;

        curr_scope_id_dict = {}

        args = []
        # TODO: Correct typing instead of just &#39;float&#39;
        if len(node.args.args) &gt; 0:
            for arg in node.args.args:
                self.insert_next_id(curr_scope_id_dict, arg.arg)

                args.append(
                    Var(
                        Name(
                            arg.arg,
                            id=curr_scope_id_dict[arg.arg],
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        ),
                        &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    )
                )

        body = self.visit(node.body, prev_scope_id_dict, curr_scope_id_dict)

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        # TODO: add an ID for lambda name
        if self.legacy:
            return [FunctionDef(&#34;LAMBDA&#34;, args, body, source_refs=ref)]
        else:
            lambda_name = f&#34;%lambda{self.lambda_count}&#34;
            self.lambda_count += 1
            lambda_id = -1 # TODO

            name_node = Name(lambda_name, lambda_id, source_refs=ref)
            self.generated_fns.append(FunctionDef(name_node, args, body, source_refs=ref))
        
            # NOTE: What should the arguments be?
            to_ret = [Call(func=Name(lambda_name, lambda_id, source_refs=ref),arguments=args,source_refs=ref)]

            return to_ret

    @visit.register
    def visit_ListComp(
        self,
        node: ast.ListComp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST ListComp node, which are used for Python list comprehensions.
        List comprehensions generate a list from some generator expression.

        Args:
            node (ast.ListComp): A PyAST list comprehension node

        Returns:
            Loop:
        &#34;&#34;&#34;

        ref = [
            self.filenames[-1],
            node.col_offset,
            node.end_col_offset,
            node.lineno,
            node.end_lineno,
        ]

        temp_list_name = f&#34;list__temp_&#34;
        temp_assign = ast.Assign(
            targets=[
                ast.Name(
                    id=temp_list_name,
                    ctx=ast.Store(),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ],
            value=ast.List(
                elts=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            ),
            type_comment=None,
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )

        generators = node.generators
        first_gen = generators[-1]
        i = len(generators) - 2

        # Constructs the Python AST for the innermost loop in the list comprehension
        if len(first_gen.ifs) &gt; 0:
            innermost_loop_body = [
                ast.If(
                    test=first_gen.ifs[0],
                    body=[
                        ast.Expr(
                            value=ast.Call(
                                func=ast.Attribute(
                                    value=ast.Name(
                                        id=temp_list_name,
                                        ctx=ast.Load(),
                                        col_offset=ref[1],
                                        end_col_offset=ref[2],
                                        lineno=ref[3],
                                        end_lineno=ref[4],
                                    ),
                                    attr=&#34;append&#34;,
                                    ctx=ast.Load(),
                                    col_offset=ref[1],
                                    end_col_offset=ref[2],
                                    lineno=ref[3],
                                    end_lineno=ref[4],
                                ),
                                args=[node.elt],
                                keywords=[],
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            ),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ]
        else:
            innermost_loop_body = [
                ast.Expr(
                    value=ast.Call(
                        func=ast.Attribute(
                            value=ast.Name(
                                id=temp_list_name,
                                ctx=ast.Load(),
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            ),
                            attr=&#34;append&#34;,
                            ctx=ast.Load(),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        ),
                        args=[node.elt],
                        keywords=[],
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    ),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ]

        loop_collection = [
            ast.For(
                target=self.identify_piece(
                    first_gen.target, prev_scope_id_dict, curr_scope_id_dict
                ),
                iter=first_gen.iter,
                # iter=self.identify_piece(first_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                body=innermost_loop_body,
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ]

        # Every other loop in the list comprehension wraps itself around the previous loop that we
        # added
        while i &gt;= 0:
            curr_gen = generators[i]
            if len(curr_gen.ifs) &gt; 0:
                # TODO: if multiple ifs exist per a single generator then we have to expand this
                curr_if = curr_gen.ifs[0]
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    iter=self.identify_piece(
                        curr_gen.iter, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    body=[
                        ast.If(
                            test=curr_if,
                            body=[loop_collection[0]],
                            orelse=[],
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )

            else:
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    iter=self.identify_piece(
                        curr_gen.iter, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    body=[loop_collection[0]],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )

            loop_collection.insert(0, next_loop)
            i = i - 1

        temp_cast = self.visit(
            temp_assign, prev_scope_id_dict, curr_scope_id_dict
        )
        loop_cast = self.visit(
            loop_collection[0], prev_scope_id_dict, curr_scope_id_dict
        )

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # TODO: arguments for a comprehension, IDs
        return_cast = [ModelReturn(value=Var(val=Name(name=temp_list_name, source_refs=ref), source_refs=ref), source_refs=ref)]

        comp_func_name = f&#34;%comprehension_list_{self.list_comp_count}&#34;
        self.list_comp_count += 1
        comp_func_id = -1 #TODO

        name_node = Name(comp_func_name, comp_func_id, source_refs=ref)
        func_def_cast = FunctionDef(name=name_node, func_args=[], body=temp_cast+loop_cast+return_cast, source_refs=ref)
        
        self.generated_fns.append(func_def_cast)

        to_ret = [Call(func=Name(comp_func_name, comp_func_id, source_refs=ref),arguments=[],source_refs=ref)]

        return to_ret

    @visit.register
    def visit_DictComp(
        self,
        node: ast.DictComp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        ref = [
            self.filenames[-1],
            node.col_offset,
            node.end_col_offset,
            node.lineno,
            node.end_lineno,
        ]

        # node (ast.DictComp)
        #  key       - what makes the keys
        #  value     - what makes the valuedds
        #  generators - list of &#39;comprehension&#39; nodes

        temp_dict_name = f&#34;dict__temp_&#34;

        generators = node.generators
        first_gen = generators[-1]
        i = len(generators) - 2
        temp_assign = ast.Assign(
            targets=[
                ast.Name(
                    id=temp_dict_name,
                    ctx=ast.Store(),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ],
            value=ast.Dict(
                keys=[],
                values=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            ),
            type_comment=None,
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )

        # Constructs the Python AST for the innermost loop in the dict comprehension
        if len(first_gen.ifs) &gt; 0:
            innermost_loop_body = ast.If(
                test=first_gen.ifs[0],
                body=[
                    ast.Assign(
                        targets=[
                            ast.Subscript(
                                value=ast.Name(
                                    id=temp_dict_name,
                                    ctx=ast.Load(),
                                    col_offset=ref[1],
                                    end_col_offset=ref[2],
                                    lineno=ref[3],
                                    end_lineno=ref[4],
                                ),
                                slice=node.key,
                                ctx=ast.Store(),
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            )
                        ],
                        value=node.value,
                        type_comment=None,
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        else:
            innermost_loop_body = ast.Assign(
                targets=[
                    ast.Subscript(
                        value=ast.Name(
                            id=temp_dict_name,
                            ctx=ast.Load(),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        ),
                        slice=node.key,
                        ctx=ast.Store(),
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                value=node.value,
                type_comment=None,
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )

        loop_collection = [
            ast.For(
                target=self.identify_piece(
                    first_gen.target, prev_scope_id_dict, curr_scope_id_dict
                ),
                iter=first_gen.iter,
                # iter=self.identify_piece(first_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                body=[innermost_loop_body],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ]

        # Every other loop in the list comprehension wraps itself around the previous loop that we
        # added
        while i &gt;= 0:
            curr_gen = generators[i]
            if len(curr_gen.ifs) &gt; 0:
                # TODO: if multiple ifs exist per a single generator then we have to expand this
                curr_if = curr_gen.ifs[0]
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, prev_scope_id_dict, curr_scope_id_dict
                    ),
                    iter=curr_gen.iter,
                    # iter=self.identify_piece(curr_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                    body=[
                        ast.If(
                            test=curr_if,
                            body=[loop_collection[0]],
                            orelse=[],
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            else:
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, prev_scope_id_dict, curr_scope_id_dict
                    ),
                    iter=curr_gen.iter,
                    # iter=self.identify_piece(curr_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                    body=[loop_collection[0]],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            loop_collection.insert(0, next_loop)
            i = i - 1

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        temp_cast = self.visit(
            temp_assign, prev_scope_id_dict, curr_scope_id_dict
        )
        loop_cast = self.visit(
            loop_collection[0], prev_scope_id_dict, curr_scope_id_dict
        )

        # TODO: Arguments for comprehension, IDs
        return_cast = [ModelReturn(value=Var(val=Name(name=temp_dict_name, id=-1, source_refs=ref), source_refs=ref), source_refs=ref)]

        comp_func_name = f&#34;%comprehension_dict_{self.dict_comp_count}&#34;
        self.dict_comp_count += 1
        comp_func_id = -1 # TODO

        name_node = Name(comp_func_name, comp_func_id, source_refs=ref)
        func_def_cast = FunctionDef(name=name_node, func_args=[], body=temp_cast+loop_cast+return_cast, source_refs=ref)
        
        self.generated_fns.append(func_def_cast)

        to_ret = [Call(func=Name(comp_func_name, comp_func_id, source_refs=ref),arguments=[],source_refs=ref)]

        return to_ret

    @visit.register
    def visit_If(
        self, node: ast.If, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST If node. Which is used to represent If statements.
        We visit each of the pieces accordingly and construct the CAST
        representation. else/elif statements are stored in the &#39;orelse&#39; field,
        if there are any.

        Args:
            node (ast.If): A PyAST If node.

        Returns:
            ModelIf: A CAST If statement node.
        &#34;&#34;&#34;

        # node_test = self.visit(
        #     node.test, prev_scope_id_dict, curr_scope_id_dict
        # )
        node_test = self.create_cond(
            node, prev_scope_id_dict, curr_scope_id_dict
        )

        node_body = []
        if len(node.body) &gt; 0:
            for piece in node.body:
                node_body.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )

        node_orelse = []
        if len(node.orelse) &gt; 0:
            for piece in node.orelse:
                node_orelse.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]


        if isinstance(node_test, list):
            return [ModelIf(node_test[0], node_body, node_orelse, source_refs=ref)]
        else:
            return [ModelIf(node_test, node_body, node_orelse, source_refs=ref)]

    @visit.register
    def visit_Global(
        self,
        node: ast.Global,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Global node.
        What this does is write in the IDs for variables that are
        explicitly declared as global within a scope using the global keyword
        as follows
        global x [, y, z, etc..]

        Args:
            node (ast.Global): A PyAST Global node
            prev_scope_id_dict (Dict): Dictionary containing the scope&#39;s current variable : ID maps

        Returns:
            List: empty list
        &#34;&#34;&#34;

        for v in node.names:
            unique_name = construct_unique_name(self.filenames[-1], v)
            curr_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]
        return []

    @visit.register
    def visit_IfExp(
        self,
        node: ast.IfExp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST IfExp node, which is Python&#39;s ternary operator.
        The node gets translated into a CAST ModelIf node by visiting all its parts,
        since IfExp behaves like an If statement.

        # TODO: Rethink how this is done to better reflect
         - ternary for assignments
         - ternary in function call arguments

        # NOTE: Do we want to treat this as a conditional block in GroMEt? But it shouldn&#39;t show up in the expression tree

        Args:
            node (ast.IfExp): [description]
        &#34;&#34;&#34;

        node_test = self.visit(
            node.test, prev_scope_id_dict, curr_scope_id_dict
        )
        node_body = self.visit(
            node.body, prev_scope_id_dict, curr_scope_id_dict
        )
        node_orelse = self.visit(
            node.orelse, prev_scope_id_dict, curr_scope_id_dict
        )
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        return [ModelIf(node_test[0], node_body, node_orelse, source_refs=ref)]

    @visit.register
    def visit_Import(
        self,
        node: ast.Import,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Import node, which is used for importing libraries
        that are used in programs. In particular, it&#39;s imports in the form of
        &#39;import X&#39;, where X is some library.

        Args:
            node (ast.Import): A PyAST Import node

        Returns:
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        names = node.names
        to_ret = []
        for alias in names:
            as_name = alias.asname
            orig_name = alias.name

            # Construct the path of the module, relative to where we are at
            # TODO: (Still have to handle things like &#39;..&#39;)
            name = alias.name

            # module1.x, module2.x
            # {module1: {x: 1}, module2: {x: 4}}

            # For cases like &#39;import module as something_else&#39;
            # We note the alias that the import uses for this module
            # Qualify names
            if as_name is not None:
                self.aliases[as_name] = orig_name
                name = alias.asname

            # TODO: Could use a flag to mark a Module as an import (old)
            if orig_name in BUILTINS or find_std_lib_module(orig_name):
                self.insert_next_id(self.global_identifier_dict, name)
                to_ret.append(
                    ModelImport(
                        name=orig_name,
                        alias=as_name,
                        symbol=None,
                        all=False,
                        source_refs=ref,
                    )
                )
        return to_ret

    @visit.register
    def visit_ImportFrom(
        self,
        node: ast.ImportFrom,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST ImportFrom node, which is used for importing libraries
        that are used in programs. In particular, it&#39;s imports in the form of
        &#39;import X&#39;, where X is some library.

        Args:
            node (ast.Import): A PyAST Import node

        Returns:
        &#34;&#34;&#34;

        # Construct the path of the module, relative to where we are at
        # (TODO: Still have to handle things like &#39;..&#39;)
        # TODO: What about importing individual functions from a module M
        #        that call other functions from that same module M
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        name = node.module
        if name in self.aliases:
            name = self.aliases[name]

        aliases = node.names
        to_ret = []
        for (
            alias
        ) in (
            aliases
        ):  # Iterate through the symbols that are being imported and create individual imports for each
            if alias.asname is not None:
                self.aliases[alias.asname] = alias.name

            if name in BUILTINS or find_std_lib_module(name):
                if alias.name == &#34;*&#34;:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=None,
                            all=True,
                            source_refs=ref,
                        )
                    )
                else:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=alias.name,
                            all=False,
                            source_refs=ref,
                        )
                    )
            else:  # User defined module import
                if alias.name == &#34;*&#34;:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=None,
                            all=True,
                            source_refs=ref,
                        )
                    )
                else:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=alias.name,
                            all=False,
                            source_refs=ref,
                        )
                    )

        return to_ret

    @visit.register
    def visit_List(
        self,
        node: ast.List,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST List node. Which is used to represent Python lists.

        Args:
            node (ast.List): A PyAST List node.

        Returns:
            List: A CAST List node.
        &#34;&#34;&#34;

        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        # TODO: How to handle constructors with variables?
        if len(node.elts) &gt; 0:
            to_ret = []
            for piece in node.elts:
                to_ret.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )
            # TODO: How to represent computations like &#39;[0.0] * 1000&#39; in some kind of type constructing system
            # and then how could we store that in these LiteralValue nodes?
            return [
                LiteralValue(
                    StructureType.LIST, to_ret, source_code_data_type, ref
                )
            ]
            # return [List(to_ret,source_refs=ref)]
        else:
            return [
                LiteralValue(
                    StructureType.LIST, [], source_code_data_type, ref
                )
            ]
            # return [List([],source_refs=ref)]

    @visit.register
    def visit_Module(
        self,
        node: ast.Module,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Module node. This is the starting point of CAST Generation,
        as the body of the Module node (usually) contains the entire Python
        program.

        Args:
            node (ast.Module): A PyAST Module node.

        Returns:
            Module: A CAST Module node.
        &#34;&#34;&#34;

        # Visit all the nodes and make a Module object out of them
        body = []
        funcs = []
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=-1,
                col_end=-1,
                row_start=-1,
                row_end=-1,
            )
        ]
        self.module_stack.append(node)
        
        # Attempt to capture all global variable names
        # before we do any function definitions
        # (functions can use global variables so they need them all available)
        for line in node.body:
            if isinstance(line, ast.Assign):
                names = get_node_name(line)

                for var_name in names:
                    unique_name = construct_unique_name(
                        self.filenames[-1], var_name
                    )
                    self.insert_next_id(self.global_identifier_dict, unique_name)
        
        merge_dicts(self.global_identifier_dict, curr_scope_id_dict)
        merge_dicts(curr_scope_id_dict, prev_scope_id_dict)
        for piece in node.body:
            # Defer visiting function defs until all global vars are processed
            if isinstance(piece, ast.FunctionDef):
                unique_name = construct_unique_name(
                    self.filenames[-1], piece.name
                )
                self.insert_next_id(curr_scope_id_dict, unique_name)
                prev_scope_id_dict[unique_name] = curr_scope_id_dict[
                    unique_name
                ]
                #funcs.append(piece)
                #continue

            to_add = self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)

            # Global variables (which come about from assignments at the module level)
            # need to have their identifier names set correctly so they can be
            # accessed appropriately later on
            # We check if we just visited an assign and fix its key/value pair in the dictionary
            # So instead of
            #   &#34;var_name&#34; -&gt; ID
            # It becomes
            #   &#34;module_name.var_name&#34; -&gt; ID
            # in the dictionary
            # If an assign happens at the global level, then we must also make sure to
            # Update the global dictionary at this time so that the IDs are defined
            # and are correct
            if isinstance(piece, ast.Assign):
                names = get_node_name(to_add[0])

                for var_name in names:
                    #temp_id = curr_scope_id_dict[var_name]
                    del curr_scope_id_dict[var_name]
                    #unique_name = construct_unique_name(
                    #    self.filenames[-1], var_name
                    #)
                    #curr_scope_id_dict[unique_name] = temp_id
                    #merge_dicts(
                    #    curr_scope_id_dict, self.global_identifier_dict
                    #)

            if isinstance(to_add, Module):
                body.extend([to_add])
            else:
                body.extend(to_add)

        #merge_dicts(curr_scope_id_dict, self.global_identifier_dict)
        #merge_dicts(prev_scope_id_dict, curr_scope_id_dict)

        # Visit all the functions
        #for piece in funcs:
         #   to_add = self.visit(piece, curr_scope_id_dict, {})
          #  body.extend(to_add)

        self.module_stack.pop()
        return Module(
            name=self.filenames[-1].split(&#34;.&#34;)[0], body=self.generated_fns+body, source_refs=ref
        )

    @visit.register
    def visit_Name(
        self,
        node: ast.Name,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;This visits PyAST Name nodes, which consist of
           id: The name of a variable as a string
           ctx: The context in which the variable is being used

        Args:
            node (ast.Name): A PyAST Name node

        Returns:
            Expr: A CAST Expression node

        &#34;&#34;&#34;
        # TODO: Typing so it&#39;s not hardcoded to floats
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        if isinstance(node.ctx, ast.Load):
            if node.id in self.aliases:
                return [Name(self.aliases[node.id], id=-1, source_refs=ref)]

            if node.id not in curr_scope_id_dict:
                if node.id in prev_scope_id_dict:
                    curr_scope_id_dict[node.id] = prev_scope_id_dict[node.id]
                else:
                    unique_name = construct_unique_name(
                        self.filenames[-1], node.id
                    )

                    # We can have the very odd case where a variable is used in a function before
                    # it even exists. To my knowledge this happens in one scenario:
                    # - A global variable, call it z, is used in a function
                    # - Before that function is called in Python code, that global variable
                    #   z is set by another module/another piece of code as a global
                    #   (i.e. by doing module_name.z = a value)
                    # It&#39;s not something that is very common (or good) to do, but regardless
                    # we&#39;ll catch it here just in case.
                    if unique_name not in self.global_identifier_dict.keys():
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    curr_scope_id_dict[node.id] = self.global_identifier_dict[
                        unique_name
                    ]

            return [
                Name(node.id, id=curr_scope_id_dict[node.id], source_refs=ref)
            ]

        if isinstance(node.ctx, ast.Store):
            if node.id in self.aliases:
                return [
                    Var(
                        Name(self.aliases[node.id], id=-1, source_refs=ref),
                        &#34;float&#34;,
                        source_refs=ref,
                    )
                ]

            if node.id not in curr_scope_id_dict:
                # We construct the unique name for the case that
                # An assignment to a global happens in the global scope
                # (i.e. a loop at the global level)
                # Check if it&#39;s in the previous scope not as a global (general case when in a function)
                # then check if it&#39;s in the previous scope as a global (when we&#39;re at the global scope)
                unique_name = construct_unique_name(
                    self.filenames[-1], node.id
                )
                if node.id in prev_scope_id_dict:
                    curr_scope_id_dict[node.id] = prev_scope_id_dict[node.id]
                elif unique_name in prev_scope_id_dict:
                    curr_scope_id_dict[node.id] = prev_scope_id_dict[
                        unique_name
                    ]
                else:
                    self.insert_next_id(curr_scope_id_dict, node.id)

            return [
                Var(
                    Name(
                        node.id,
                        id=curr_scope_id_dict[node.id],
                        source_refs=ref,
                    ),
                    &#34;float&#34;,
                    source_refs=ref,
                )
            ]

        if isinstance(node.ctx, ast.Del):
            # TODO: At some point..
            raise NotImplementedError()

    @visit.register
    def visit_Pass(
        self,
        node: ast.Pass,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;A PyAST Pass visitor, for essentially NOPs.&#34;&#34;&#34;
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Raise(
        self,
        node: ast.Raise,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;A PyAST Raise visitor, for Raising exceptions

        TODO: To be implemented.
        &#34;&#34;&#34;
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        exc_name = &#34;&#34;
        if isinstance(node.exc, ast.Name):
            exc_name = node.exc.id
        elif isinstance(node.exc, ast.Call):
            if isinstance(node.exc.func, ast.Name):
                exc_name = node.exc.func.id

        raise_id = -1
        if &#34;raise&#34; not in self.global_identifier_dict.keys():
            raise_id = self.insert_next_id(
                self.global_identifier_dict, &#34;raise&#34;
            )
        else:
            raise_id = self.global_identifier_dict[&#34;raise&#34;]

        return [
            Call(
                func=Name(&#34;raise&#34;, raise_id, source_refs=ref),
                arguments=[
                    LiteralValue(
                        StructureType.LIST,
                        exc_name,
                        source_code_data_type,
                        ref,
                    )
                ],
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_Return(
        self,
        node: ast.Return,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Return node and creates a CAST return node
           that has one field, which is the expression computing the value
           to be returned. The PyAST&#39;s value node is visited.
           The CAST node is then returned.

        Args:
            node (ast.Return): A PyAST Return node

        Returns:
            ModelReturn: A CAST Return node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        if node.value != None:
            return [
                ModelReturn(
                    self.visit(
                        node.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0],
                    source_refs=ref,
                )
            ]
        else:
            source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(node.value))]
            val = LiteralValue(None, None, source_code_data_type, ref)
            return [ModelReturn(val, source_refs=ref)]

    @visit.register
    def visit_UnaryOp(
        self,
        node: ast.UnaryOp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST UnaryOp node. Which represents Python unary operations.
        A dictionary is used to index into which operation we&#39;re doing.

        Args:
            node (ast.UnaryOp): A PyAST UnaryOp node.

        Returns:
            UnaryOp: A CAST UnaryOp node.
        &#34;&#34;&#34;

        op = get_op(node.op)
        operand = node.operand

        opd = self.visit(operand, prev_scope_id_dict, curr_scope_id_dict)

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        return [Operator(source_language=&#34;Python&#34;, 
                interpreter=&#34;Python&#34;, 
                version=get_python_version(), 
                op=op, 
                operands=[opd[0]], 
                source_refs=ref)]

    @visit.register
    def visit_Set(
        self, node: ast.Set, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST Set node. Which is used to represent Python sets.

        Args:
            node (ast.Set): A PyAST Set node.

        Returns:
            Set: A CAST Set node.
        &#34;&#34;&#34;

        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        if len(node.elts) &gt; 0:
            to_ret = []
            for piece in node.elts:
                to_ret.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )
            return [
                LiteralValue(
                    StructureType.SET, to_ret, source_code_data_type, ref
                )
            ]
        else:
            return [
                LiteralValue(
                    StructureType.SET, to_ret, source_code_data_type, ref
                )
            ]

    @visit.register
    def visit_Subscript(
        self,
        node: ast.Subscript,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Subscript node, which represents subscripting into
        a list in Python. A Subscript is either a Slice (i.e. x[0:2]), an
        Extended slice (i.e. x[0:2, 3]), or a constant (i.e. x[3]).
        In the Slice case, a loop is generated that fetches the correct elements and puts them
        into a list.
        In the Extended slice case, nested loops are generated as needed to create a final
        result list with the selected elements.
        In the constant case, we can visit and generate a CAST Subscript in a normal way.

        Args:
            node (ast.Subscript): A PyAST Subscript node

        Returns:
            Subscript: A CAST Subscript node
        &#34;&#34;&#34;

        # value = self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)[0]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # &#39;Visit&#39; the slice
        slc = node.slice
        temp_var = f&#34;generated_index_{self.var_count}&#34;
        self.var_count += 1

        if isinstance(slc, ast.Slice):
            if slc.lower is not None:
                start = self.visit(
                    slc.lower, prev_scope_id_dict, curr_scope_id_dict
                )[0]
            else:
                start = LiteralValue(
                    value_type=ScalarType.INTEGER,
                    value=0,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                    source_refs=ref,
                )

            if slc.upper is not None:
                stop = self.visit(
                    slc.upper, prev_scope_id_dict, curr_scope_id_dict
                )[0]
            else:
                if isinstance(node.value, ast.Call):
                    if isinstance(node.value.func, ast.Attribute):
                        stop = Call(
                            func=Name(&#34;len&#34;, source_refs=ref),
                            arguments=[Name(node.value.func.attr, source_refs=ref)],
                            source_refs=ref,
                        )
                    else:
                        stop = Call(
                            func=Name(&#34;len&#34;, source_refs=ref),
                            arguments=[Name(node.value.func.id, source_refs=ref)],
                            source_refs=ref,
                        )
                elif isinstance(node.value, ast.Attribute):
                    stop = Call(
                        func=Name(&#34;len&#34;, source_refs=ref),
                        arguments=[Name(node.value.attr, source_refs=ref)],
                        source_refs=ref,
                    )
                else:
                    if isinstance(node.value, ast.Subscript):
                        id = self.visit(
                            node.value, prev_scope_id_dict, curr_scope_id_dict
                        )
                    else:
                        id = node.value.id
                    stop = Call(
                        func=Name(&#34;len&#34;, source_refs=ref),
                        arguments=[Name(id, source_refs=ref)],
                        source_refs=ref,
                    )

            if slc.step is not None:
                step = self.visit(
                    slc.step, prev_scope_id_dict, curr_scope_id_dict
                )[0]
            else:
                step = LiteralValue(
                    value_type=ScalarType.INTEGER,
                    value=1,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                    source_refs=ref,
                )

            unique_name = construct_unique_name(self.filenames[-1], &#34;slice&#34;)
            if unique_name not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]

            slice_call = Call(
                func=Name(
                    &#34;slice&#34;,
                    id=prev_scope_id_dict[unique_name],
                    source_refs=ref,
                ),
                arguments=[start, stop, step],
                source_refs=ref,
            )

            val = self.visit(
                node.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]

            unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
            if unique_name not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]
            # return[Call(Name(&#34;Concatenate&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref), str_pieces, source_refs=ref)]

            get_call = Call(
                func=Name(
                    &#34;_get&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref
                ),
                arguments=[val, slice_call],
                source_refs=ref,
            )

            return [get_call]
        elif isinstance(slc, ast.Index):

            val = self.visit(
                node.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            slice_val = self.visit(
                slc.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
            if unique_name not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]
            get_call = Call(
                func=Name(
                    &#34;_get&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref
                ),
                arguments=[val, slice_val],
                source_refs=ref,
            )
            return [get_call]
        elif isinstance(slc, ast.ExtSlice):
            dims = slc.dims
            result = []
            source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
            ref = [
                SourceRef(
                    source_file_name=self.filenames[-1],
                    col_start=node.col_offset,
                    col_end=node.end_col_offset,
                    row_start=node.lineno,
                    row_end=node.end_lineno,
                )
            ]
            return [
                LiteralValue(
                    StructureType.LIST,
                    &#34;NotImplemented&#34;,
                    source_code_data_type,
                    ref,
                )
            ]

        # else:
        #   sl = self.visit(slc, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Index(
        self,
        node: ast.Index,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Index node, which represents the value being used
        for an index. This visitor doesn&#39;t create its own CAST node, but
        returns CAST depending on the value that the Index node holds.

        Args:
            node (ast.Index): A CAST Index node.

        Returns:
            AstNode: Depending on what the value of the Index node is,
                     different CAST nodes are returned.
        &#34;&#34;&#34;

        return self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Tuple(
        self,
        node: ast.Tuple,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Tuple node. Which is used to represent Python tuple.

        Args:
            node (ast.Tuple): A PyAST Tuple node.

        Returns:
            Set: A CAST Tuple node.
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        # if len(node.elts) &gt; 0:
        to_ret = []
        for piece in node.elts:
            to_ret.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
        return [LiteralValue(StructureType.TUPLE, to_ret, source_code_data_type, source_refs=ref)]

    @visit.register
    def visit_Try(
        self, node: ast.Try, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST Try node, which represents Try/Except blocks.
        These are used for Python&#39;s exception handling

        Currently, the visitor just bypasses the Try/Except feature and just
        generates CAST for the body of the &#39;Try&#39; block, assuming the exception(s)
        are never thrown.
        &#34;&#34;&#34;

        body = []
        for piece in node.body:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        for piece in node.orelse:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        for piece in node.finalbody:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )

        return body

    @visit.register
    def visit_Yield(
        self,
        node: ast.Yield,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Assert(
        self,
        node: ast.Assert,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_While(
        self,
        node: ast.While,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST While node, which represents a while loop.

        Args:
            node (ast.While): a PyAST while node

        Returns:
            Loop: A CAST loop node, which generically represents both For
                  loops and While loops.
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # test_cond = self.visit(node.test, prev_scope_id_dict, curr_scope_id_dict)[0]
        test = self.create_cond(node, prev_scope_id_dict, curr_scope_id_dict)

        # Loops have their own enclosing scopes
        curr_scope_copy = copy.deepcopy(curr_scope_id_dict)
        merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
        loop_body_scope = {}
        body = []
        for piece in node.body + node.orelse:
            to_add = self.visit(piece, curr_scope_id_dict, loop_body_scope)
            body.extend(to_add)

        curr_scope_id_dict = copy.deepcopy(curr_scope_copy)

        # loop_body_fn_def = FunctionDef(name=&#34;while_temp&#34;, func_args=None, body=body)
        # return [Loop(init=[], expr=test, body=loop_body_fn_def, source_refs=ref)]
        if isinstance(test, list):
            return [Loop(pre=[], expr=test[0], body=body, post=[], source_refs=ref)]
        else:
            return [Loop(pre=[], expr=test, body=body, post=[], source_refs=ref)]

    @visit.register
    def visit_With(
        self,
        node: ast.With,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST With node. With nodes are used as follows:
        with a as b, c as d:
            do things with b and d
        To use aliases on variables and operate on them
        This visitor unrolls the With block and generates the appropriate cast for the
        underlying operations

        Args:
            node (ast.With): a PyAST with node

        Args:
            [AstNode]: A list of CAST nodes, representing whatever operations were happening in the With
                       block before they got unrolled

        &#34;&#34;&#34;

        ref = None
        variables = []
        for item in node.items:
            ref = [
                SourceRef(
                    source_file_name=self.filenames[-1],
                    col_start=node.col_offset,
                    col_end=node.end_col_offset,
                    row_start=node.lineno,
                    row_end=node.end_lineno,
                )
            ]
            if item.optional_vars != None:
                l = self.visit(
                    item.optional_vars, prev_scope_id_dict, curr_scope_id_dict
                )
                r = self.visit(
                    item.context_expr, prev_scope_id_dict, curr_scope_id_dict
                )
                variables.extend(
                    [Assignment(left=l[0], right=r[0], source_refs=ref)]
                )
            else:
                variables.extend(
                    [
                        self.visit(
                            item.context_expr,
                            prev_scope_id_dict,
                            curr_scope_id_dict,
                        )[0]
                    ]
                )

        body = []
        for piece in node.body:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )

        return variables + body</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.construct_unique_name"><code class="name flex">
<span>def <span class="ident">construct_unique_name</span></span>(<span>attr_name, var_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs strings in the form of
"attribute.var"
where 'attribute' is either
- the name of a module
- an object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A string representing a unique name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_unique_name(attr_name, var_name):
    &#34;&#34;&#34;Constructs strings in the form of
    &#34;attribute.var&#34;
    where &#39;attribute&#39; is either
        - the name of a module
        - an object

    Returns:
        string: A string representing a unique name

    &#34;&#34;&#34;
    return f&#34;{attr_name}.{var_name}&#34;</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_node_name"><code class="name flex">
<span>def <span class="ident">get_node_name</span></span>(<span>ast_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_name(ast_node):
    if isinstance(ast_node, ast.Assign):
        return get_node_name(ast_node.targets[0])
        # return [ast_node[0].id]
    elif isinstance(ast_node, ast.Name):
        return [ast_node.id]
    elif isinstance(ast_node, ast.Attribute):
        return get_node_name(ast_node.value)
    elif isinstance(ast_node, ast.Tuple):
        elements = []
        for elem in ast_node.elts:
            elements.extend(get_node_name(elem))
        return elements
    elif isinstance(ast_node, Attribute):
        return [ast_node.attr.name]
    elif isinstance(ast_node, Var):
        return [ast_node.val.name]
    elif isinstance(ast_node, Assignment):
        return get_node_name(ast_node.left)
    elif isinstance(ast_node, ast.Subscript):
        return get_node_name(ast_node.value)
    elif (
        isinstance(ast_node, LiteralValue)
        and (ast_node.value_type == StructureType.LIST or ast_node.value_type == StructureType.TUPLE)
    ):
        names = []
        for e in ast_node.value:
            names.extend(get_node_name(e))
        return names
    else:
        raise TypeError(f&#34;Type {type(ast_node)} not supported&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_op"><code class="name flex">
<span>def <span class="ident">get_op</span></span>(<span>operator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_op(operator):
    ops = {
        ast.Add: &#39;ast.Add&#39;,
        ast.Sub: &#39;ast.Sub&#39;,
        ast.Mult: &#39;ast.Mult&#39;,
        ast.Div: &#39;ast.Div&#39;,
        ast.FloorDiv: &#39;ast.FloorDiv&#39;,
        ast.Mod: &#39;ast.Mod&#39;,
        ast.Pow: &#39;ast.Pow&#39;,
        ast.LShift: &#39;ast.LShift&#39;,
        ast.RShift: &#39;ast.RShift&#39;,
        ast.BitOr: &#39;ast.BitOr&#39;,
        ast.BitAnd: &#39;ast.BitAnd&#39;,
        ast.BitXor: &#39;ast.BitXor&#39;,
        ast.And: &#39;ast.And&#39;,
        ast.Or: &#39;ast.Or&#39;,
        ast.Eq: &#39;ast.Eq&#39;,
        ast.NotEq: &#39;ast.NotEq&#39;,
        ast.Lt: &#39;ast.Lt&#39;,
        ast.LtE: &#39;ast.LtE&#39;,
        ast.Gt: &#39;ast.Gt&#39;,
        ast.GtE: &#39;ast.GtE&#39;,
        ast.In: &#39;ast.In&#39;,
        ast.NotIn: &#39;ast.NotIn&#39;,
        ast.UAdd: &#39;ast.UAdd&#39;,
        ast.USub: &#39;ast.USub&#39;,
        ast.Not: &#39;ast.Not&#39;,
        ast.Invert: &#39;ast.Invert&#39;,
    }

    if type(operator) in ops.keys():
        return ops[type(operator)]
    return str(operator)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_python_version"><code class="name flex">
<span>def <span class="ident">get_python_version</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>get_python_version gets the current version of Python that
is running when this script is executed
The expect version is 3.8.2 as that is what my (Tito) version
of Python is when running this pipeline
The plan is to eventually move onto the latest version (3.11?)
<br>
But 3.8.2 is the current stable version for generation
The latest version of Python makes some changes that this
pipeline still needs to adjust for</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_python_version():
    &#34;&#34;&#34;
    get_python_version gets the current version of Python that 
    is running when this script is executed
    The expect version is 3.8.2 as that is what my (Tito) version
    of Python is when running this pipeline
    The plan is to eventually move onto the latest version (3.11?)    
    But 3.8.2 is the current stable version for generation
    The latest version of Python makes some changes that this
    pipeline still needs to adjust for
    &#34;&#34;&#34;
    major = sys.version_info.major
    minor = sys.version_info.minor
    micro = sys.version_info.micro

    string_version = f&#34;{major}.{minor}.{micro}&#34;

    return string_version</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.merge_dicts"><code class="name flex">
<span>def <span class="ident">merge_dicts</span></span>(<span>source, destination)</span>
</code></dt>
<dd>
<div class="desc"><p>merge_dicts
Helper function to isolate the work of merging two dictionaries by merging
key : value pairs from source into curr_scope
The merging is done 'in_place'. That is, after the function is done, destination
is updated with any new key : value pairs that weren't in there before.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of name : ID pairs</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of name : ID pairs</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_dicts(source, destination):
    &#34;&#34;&#34;merge_dicts
    Helper function to isolate the work of merging two dictionaries by merging
    key : value pairs from source into curr_scope
    The merging is done &#39;in_place&#39;. That is, after the function is done, destination
    is updated with any new key : value pairs that weren&#39;t in there before.

    Args:
        source (dict): Dictionary of name : ID pairs
        destination (dict): Dictionary of name : ID pairs
    &#34;&#34;&#34;
    for k in source.keys():
        if k not in destination.keys():
            destination[k] = source[k]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST"><code class="flex name class">
<span>class <span class="ident">PyASTToCAST</span></span>
<span>(</span><span>file_name:str, legacy:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class PyASTToCast
This class is used to convert a Python program into a CAST object.
In particular, given a PyAST object that represents the Python program's
Abstract Syntax Tree, we create a Common Abstract Syntax Tree
representation of it.
Most of the functions involve visiting the children
to generate their CAST, and then connecting them to their parent to form
the parent node's CAST representation.
The functions, in most cases, return lists containing their generated CAST.
This is because in many scenarios (like in slicing) we need to return multiple
values at once, since multiple CAST nodes gt generated. Returning lists allows us to
do this, and as long as the visitors handle the data correctly, the CAST will be
properly generated.
All the visitors retrieve line number information from the PyAST nodes, and
include the information in their respective CAST nodes, with the exception
of the Module CAST visitor.</p>
<p>This class inherits from ast.NodeVisitor, to allow us to use the Visitor
design pattern to visit all the different kinds of PyAST nodes in a
similar fashion.</p>
<p>Current Fields:
- Aliases
- Visited
- Filenames
- Classes
- Var_Count
- global_identifier_dict</p>
<p>Initializes any auxiliary data structures that are used
for generating CAST.
The current data structures are:
- aliases: A dictionary used to keep track of aliases that imports use
(like import x as y, or from x import y as z)
- visited: A list used to keep track of which files have been imported
this is used to prevent an import cycle that could have no end
- filenames: A list of strings used as a stack to maintain the current file being
visited
- module_stack: A list of Module PyAST nodes used as a stack to maintain the current module
being visited.
- classes: A dictionary of class names and their associated functions.
- var_count: An int used when CAST variables need to be generated (i.e. loop variables, etc)
- global_identifier_dict: A dictionary used to map global variables to unique identifiers
- legacy: A flag used to determine whether we generate old style CAST (uses strings for function def names)
or new style CAST (uses Name CAST nodes for function def names)
- generated_fns: A list that holds any generated CAST Function Defs. Currently used for list/dict comprehensions
and lambda functions
- "*_count": Identifier numbers used for list/dict comprehensions, and lambda functions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyASTToCAST:
    &#34;&#34;&#34;Class PyASTToCast
    This class is used to convert a Python program into a CAST object.
    In particular, given a PyAST object that represents the Python program&#39;s
    Abstract Syntax Tree, we create a Common Abstract Syntax Tree
    representation of it.
    Most of the functions involve visiting the children
    to generate their CAST, and then connecting them to their parent to form
    the parent node&#39;s CAST representation.
    The functions, in most cases, return lists containing their generated CAST.
    This is because in many scenarios (like in slicing) we need to return multiple
    values at once, since multiple CAST nodes gt generated. Returning lists allows us to
    do this, and as long as the visitors handle the data correctly, the CAST will be
    properly generated.
    All the visitors retrieve line number information from the PyAST nodes, and
    include the information in their respective CAST nodes, with the exception
    of the Module CAST visitor.

    This class inherits from ast.NodeVisitor, to allow us to use the Visitor
    design pattern to visit all the different kinds of PyAST nodes in a
    similar fashion.

    Current Fields:
        - Aliases
        - Visited
        - Filenames
        - Classes
        - Var_Count
        - global_identifier_dict
    &#34;&#34;&#34;

    def __init__(self, file_name: str, legacy: bool = False):
        &#34;&#34;&#34;Initializes any auxiliary data structures that are used
        for generating CAST.
        The current data structures are:
        - aliases: A dictionary used to keep track of aliases that imports use
                  (like import x as y, or from x import y as z)
        - visited: A list used to keep track of which files have been imported
                  this is used to prevent an import cycle that could have no end
        - filenames: A list of strings used as a stack to maintain the current file being
                     visited
        - module_stack: A list of Module PyAST nodes used as a stack to maintain the current module
                     being visited.
        - classes: A dictionary of class names and their associated functions.
        - var_count: An int used when CAST variables need to be generated (i.e. loop variables, etc)
        - global_identifier_dict: A dictionary used to map global variables to unique identifiers
        - legacy: A flag used to determine whether we generate old style CAST (uses strings for function def names)
                  or new style CAST (uses Name CAST nodes for function def names)
        - generated_fns: A list that holds any generated CAST Function Defs. Currently used for list/dict comprehensions
                  and lambda functions
        - &#34;*_count&#34;: Identifier numbers used for list/dict comprehensions, and lambda functions
        &#34;&#34;&#34;

        self.aliases = {}
        self.visited = set()
        self.filenames = [file_name.split(&#34;.&#34;)[0]]
        self.module_stack = []
        self.classes = {}
        self.var_count = 0
        self.global_identifier_dict = {}
        self.id_count = 0
        self.legacy = legacy
        self.generated_fns = []
        self.list_comp_count = 0
        self.dict_comp_count = 0
        self.lambda_count = 0

    def insert_next_id(self, scope_dict: dict, dict_key: str):
        &#34;&#34;&#34;Given a scope_dictionary and a variable name as a key,
        we insert a new key_value pair for the scope dictionary
        The ID that we inserted gets returned because some visitors
        need the ID for some additional work. In the cases where the returned
        ID isn&#39;t needed it gets ignored.

        Args:
            scope_dict (Dict): _description_
            dict_key (str): _description_
        &#34;&#34;&#34;
        new_id_to_insert = self.id_count
        scope_dict[dict_key] = new_id_to_insert
        self.id_count += 1
        return new_id_to_insert

    def insert_alias(self, originString, alias):
        &#34;&#34;&#34;Inserts an alias into a dictionary that keeps track of aliases for
            names that are aliased. For example, the following import
            import numpy as np
            np is an alias for the original name numpy

        Args:
            original (String): The original name that is being aliased
            alias    (String): The alias of the original name
        &#34;&#34;&#34;
        # TODO
        pass

    def check_alias(self, name):
        &#34;&#34;&#34;Given a python string that represents a name,
        this function checks to see if that name is an alias
        for a different name, and returns it if it is indeed an alias.
        Otherwise, the original name is returned.
        &#34;&#34;&#34;
        if name in self.aliases:
            return self.aliases[name]
        else:
            return name

    def identify_piece(
        self,
        piece: AstNode,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;This function is used to &#39;centralize&#39; the handling of different node types
        in list/dictionary/set comprehensions.
        Take the following list comprehensions as examples
        L = [ele**2 for small_l in d         for ele in small_l]   -- comp1
        L = [ele**2 for small_l in foo.bar() for ele in small_l]   -- comp2
        L = [ele**2 for small_l in foo.baz   for ele in small_l]   -- comp3
               F1         F2        F3            F4      F5

        In these comprehensions F3 has a different type for its node
            - In comp1 it&#39;s a list
            - In comp2 it&#39;s an attribute of an object with a function call
            - In comp3 it&#39;s an attribute of an object without a function call

        The code that handles comprehensions generates slightly different AST depending
        on what type these fields (F1 through F5) are, but this handling becomes very repetitive
        and difficult to maintain if it&#39;s written in the comprehension visitors. Thus, this method
        is to contain that handling in one place. This method acts on one field at a time, and thus will
        be called multiple times per comprehension as necessary.

        Args:
            piece (AstNode): The current Python AST node we&#39;re looking at, generally an individual field
                             of the list comprehension
            prev_scope_id_dict (Dict): Scope dictionaries in case something needs to be accessed or changed
            curr_scope_id_dict (Dict): see above

        [ELT for TARGET in ITER]
          F1       F2      F3
        F1 - doesn&#39;t need to be handled here because that&#39;s just code that is done somewhere else
        F2/F4 - commonly it&#39;s a Name or a Tuple node
        F3/F5 - generally a list, or something that gives back a list like:
                * a subscript
                * an attribute of an object with or w/out a function call
        &#34;&#34;&#34;
        if isinstance(piece, ast.Tuple):  # for targets (generator.target)
            return piece
        elif isinstance(piece, ast.Name):
            ref = [
                self.filenames[-1],
                piece.col_offset,
                piece.end_col_offset,
                piece.lineno,
                piece.end_lineno,
            ]
            # return ast.Name(id=piece.id, ctx=ast.Store(), col_offset=None, end_col_offset=None, lineno=None, end_lineno=None)
            return ast.Name(
                id=piece.id,
                ctx=ast.Store(),
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        elif isinstance(piece, ast.Subscript):  # for iters (generator.iter)
            return piece.value
        elif isinstance(piece, ast.Call):
            return piece.func
        else:
            return piece

    def find_function(module_node: ast.Module, f_name: str):
        &#34;&#34;&#34;Given a PyAST Module node, we search for a particular FunctionDef node
        which is given to us by its function name f_name.

        This function searches at the top level, that is it only searches FunctionDefs that
        exist at the module level, and will not search deeper for functions within functions.
        &#34;&#34;&#34;
        for stmt in module_node.body:
            if isinstance(stmt, ast.FunctionDef) and stmt.name == f_name:
                return stmt

        return None

    def create_cond(self, node, prev_scope_id_dict, curr_scope_id_dict):
        &#34;&#34;&#34;Used in while and if statement creation.
        This function determines what kind of conditional we have for an if statement or a while loop
        Either the conditional explicitly checks a value using a comparison operator or it doesnt
        In the case that it doesn&#39;t explicitly then we have to add in an explicit check
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        test_cond = self.visit(
            node.test, prev_scope_id_dict, curr_scope_id_dict
        )[0]
        bool_func = &#34;bool&#34;
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(True))]
        true_val = LiteralValue(
            ScalarType.BOOLEAN,
            &#34;True&#34;,
            source_code_data_type=source_code_data_type,
            source_refs=ref,
        )
        if isinstance(node.test, (ast.Name, ast.Constant)):
            if bool_func not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if bool_func not in self.global_identifier_dict.keys():
                    self.insert_next_id(self.global_identifier_dict, bool_func)

                prev_scope_id_dict[bool_func] = self.global_identifier_dict[
                    bool_func
                ]
            bool_call = Call(
                func=Name(
                    &#34;bool&#34;, id=prev_scope_id_dict[bool_func], source_refs=ref
                ),
                arguments=[test_cond],
                source_refs=ref,
            )
            test = [Operator(source_language=&#34;Python&#34;, 
                        interpreter=&#34;Python&#34;, 
                        version=get_python_version(), 
                        op=&#34;ast.Eq&#34;, 
                        operands=[bool_call,true_val], 
                        source_refs=ref)]

        elif isinstance(node.test, ast.UnaryOp) and isinstance(
            node.test.operand, (ast.Name, ast.Constant, ast.Call)
        ):
            if bool_func not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if bool_func not in self.global_identifier_dict.keys():
                    self.insert_next_id(self.global_identifier_dict, bool_func)

                prev_scope_id_dict[bool_func] = self.global_identifier_dict[
                    bool_func
                ]
            bool_call = Call(
                func=Name(
                    &#34;bool&#34;, id=prev_scope_id_dict[bool_func], source_refs=ref
                ),
                arguments=[test_cond],
                source_refs=ref,
            )
            test = [Operator(source_language=&#34;Python&#34;, 
                        interpreter=&#34;Python&#34;, 
                        version=get_python_version(), 
                        op=&#34;ast.Eq&#34;, 
                        operands=[bool_call,true_val], 
                        source_refs=ref)]

        else:
            test = test_cond

        return test

    @singledispatchmethod
    def visit(
        self, node: AstNode, prev_scope_id_dict, curr_scope_id_dict
    ):
        # print(f&#34;Trying to visit a node of type {type(node)} but a visitor doesn&#39;t exist&#34;)
        # if(node != None):
        #    print(f&#34;This is at line {node.lineno}&#34;)
        pass

    @visit.register
    def visit_JoinedStr(
        self,
        node: ast.JoinedStr,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;JoinedStr not generating CAST yet&#34;)
        str_pieces = []
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        for s in node.values:
            source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(&#34;str&#34;))]
            if isinstance(s, ast.Str):
                str_pieces.append(
                    LiteralValue(
                        StructureType.LIST, s.s, source_code_data_type, ref
                    )
                )
            else:
                f_string_val = self.visit(
                    s.value, prev_scope_id_dict, curr_scope_id_dict
                )
                str_pieces.append(
                    LiteralValue(
                        StructureType.LIST,
                        f_string_val,
                        source_code_data_type,
                        ref,
                    )
                )

        unique_name = construct_unique_name(self.filenames[-1], &#34;Concatenate&#34;)
        if unique_name not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if unique_name not in self.global_identifier_dict.keys():
                self.insert_next_id(self.global_identifier_dict, unique_name)

            prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]
        return [
            Call(
                func=Name(
                    &#34;Concatenate&#34;,
                    id=prev_scope_id_dict[unique_name],
                    source_refs=ref,
                ),
                arguments=str_pieces,
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_GeneratorExp(
        self,
        node: ast.GeneratorExp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        ref = [
            node.col_offset,
            node.end_col_offset,
            node.lineno,
            node.end_lineno,
        ]
        to_visit = ast.ListComp(
            elt=node.elt,
            generators=node.generators,
            lineno=ref[2],
            col_offset=ref[0],
            end_lineno=ref[3],
            end_col_offset=ref[1],
        )

        return self.visit(to_visit, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Delete(
        self,
        node: ast.Delete,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;Delete not generating CAST yet&#34;)
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Ellipsis(
        self,
        node: ast.Ellipsis,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;Ellipsis&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                ScalarType.ELLIPSIS, &#34;...&#34;, source_code_data_type, ref
            )
        ]

    @visit.register
    def visit_Slice(
        self,
        node: ast.Slice,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;Slice not generating CAST yet&#34;)
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=-1,
                col_end=-1,
                row_start=-1,
                row_end=-1,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_ExtSlice(
        self,
        node: ast.ExtSlice,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        # print(&#34;ExtSlice not generating CAST yet&#34;)
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=-1,
                col_end=-1,
                row_start=-1,
                row_end=-1,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Assign(
        self,
        node: ast.Assign,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Assign node, and returns its CAST representation.
        Either the assignment is simple, like x = {expression},
        or the assignment is complex, like x = y = z = ... {expression}
        Which determines how we generate the CAST for this node.

        Args:
            node (ast.Assign): A PyAST Assignment node.

        Returns:
            Assignment: An assignment CAST node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        left = []
        right = []

        if len(node.targets) == 1:  
            # x = 1, or maybe x = y, in general x = {expression}
            if isinstance(node.targets[0], ast.Subscript):  
                # List subscript nodes get replaced out by
                # A function call to a &#34;list_set&#34;
                sub_node = node.targets[0]
                if isinstance(node.value, ast.Subscript):
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;_get&#34;
                    )
                    if unique_name not in prev_scope_id_dict.keys():
                        # If a built-in is called, then it gets added to the global dictionary if
                        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                        # function
                        if (
                            unique_name
                            not in self.global_identifier_dict.keys()
                        ):
                            self.insert_next_id(
                                self.global_identifier_dict, unique_name
                            )

                        prev_scope_id_dict[
                            unique_name
                        ] = self.global_identifier_dict[unique_name]
                    idx = self.visit(
                        node.value.slice,
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                    val = self.visit(
                        node.value.value,
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                    args = [val, idx]

                    val = Call(
                        func=Name(
                            &#34;_get&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    )
                else:
                    val = self.visit(
                        node.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]

                idx = self.visit(
                    sub_node.slice, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                list_name = self.visit(
                    sub_node.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                # print(&#34;-------------&#34;)
                # print(type(node.value))
                # print(type(sub_node.slice))
                # print(type(sub_node.value))
                # print(&#34;-------------&#34;)

                # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
                # This should only be the case for built-in python functions (i.e print, len, etc...)
                # Otherwise it would be an error to call a function before it is defined
                # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
                unique_name = construct_unique_name(self.filenames[-1], &#34;_set&#34;)
                if unique_name not in prev_scope_id_dict.keys():

                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if unique_name not in self.global_identifier_dict.keys():
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]

                args = [list_name, idx, val]
                return [
                    Assignment(
                        Var(val=list_name, type=&#34;Any&#34;, source_refs=ref),
                        Call(
                            func=Name(
                                &#34;_set&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        ),
                        source_refs=ref,
                    )
                ]

            if isinstance(node.value, ast.Subscript):

                # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
                # This should only be the case for built-in python functions (i.e print, len, etc...)
                # Otherwise it would be an error to call a function before it is defined
                # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
                unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
                if unique_name not in prev_scope_id_dict.keys():

                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if unique_name not in self.global_identifier_dict.keys():
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]

                var_name = self.visit(
                    node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                )[0]
                idx = self.visit(
                    node.value.slice, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                val = self.visit(
                    node.value.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                args = [val, idx]
                return [
                    Assignment(
                        var_name,
                        Call(
                            func=Name(
                                &#34;_get&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        ),
                        source_refs=ref,
                    )
                ]

            if isinstance(node.value, ast.BinOp):  # Checking if we have an assignment of the form
                # x = LIST * NUM or x = NUM * LIST
                binop = node.value
                list_node = None
                operand = None
                if isinstance(binop.left, ast.List):
                    list_node = binop.left
                    operand = binop.right
                elif isinstance(binop.right, ast.List):
                    list_node = binop.right
                    operand = binop.left

                if list_node is not None:
                    cons = ValueConstructor()
                    lit_type = (
                        ScalarType.ABSTRACTFLOAT
                        if type(list_node.elts[0].value) == float
                        else ScalarType.INTEGER
                    )
                    cons.dim = None
                    t = get_op(binop.op)
                    cons.operator = (
                        &#34;*&#34;
                        if get_op(binop.op) == &#34;Mult&#34;
                        else &#34;+&#34;
                        if get_op(binop.op) == &#34;Add&#34;
                        else None
                    )
                    cons.size = self.visit(
                        operand, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    cons.initial_value = LiteralValue(
                        value_type=lit_type,
                        value=list_node.elts[0].value,
                        source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                        source_refs=ref,
                    )

                    # TODO: Source code data type metadata
                    to_ret = LiteralValue(
                        value_type=&#34;List[Any]&#34;,
                        value=cons,
                        source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                        source_refs=ref,
                    )
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;_get&#34;
                    )
                    if unique_name not in prev_scope_id_dict.keys():

                        # If a built-in is called, then it gets added to the global dictionary if
                        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                        # function
                        if (
                            unique_name
                            not in self.global_identifier_dict.keys()
                        ):
                            self.insert_next_id(
                                self.global_identifier_dict, unique_name
                            )

                        prev_scope_id_dict[
                            unique_name
                        ] = self.global_identifier_dict[unique_name]

                    # TODO: Augment this _List_num constructor with the following
                    # First argument should be a list with the initial amount of elements
                    # Then second arg is how many times to repeat that
                    # When we say List for the first argument: It should be a literal value List that holds the elements
                    to_ret = Call(
                        func=Name(
                            &#34;_List_num&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=[cons.initial_value, cons.size],
                        source_refs=ref,
                    )

                    # print(to_ret)
                    l_visit = self.visit(
                        node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                    )
                    left.extend(l_visit)
                    return [Assignment(left[0], to_ret, source_refs=ref)]

            l_visit = self.visit(
                node.targets[0], prev_scope_id_dict, curr_scope_id_dict
            )
            r_visit = self.visit(
                node.value, prev_scope_id_dict, curr_scope_id_dict
            )
            left.extend(l_visit)
            right.extend(r_visit)
        elif len(node.targets) &gt; 1:
            # x = y = z = ... {Expression} (multiple assignments in one line)
            left.extend(
                self.visit(
                    node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                )
            )
            node.targets = node.targets[1:]
            right.extend(
                self.visit(node, prev_scope_id_dict, curr_scope_id_dict)
            )
        else:
            raise ValueError(
                f&#34;Unexpected number of targets for node: {len(node.targets)}&#34;
            )

        # ref = [SourceRef(source_file_name=self.filenames[-1], col_start=node.col_offset, col_end=node.end_col_offset, row_start=node.lineno, row_end=node.end_lineno)]

        return [Assignment(left[0], right[0], source_refs=ref)]

    @visit.register
    def visit_Attribute(
        self,
        node: ast.Attribute,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Attribute node, which is used when accessing
        the attribute of a class. Whether it&#39;s a field or method of a class.

        Args:
            node (ast.Attribute): A PyAST Attribute node

        Returns:
            Attribute: A CAST Attribute node representing an Attribute access
        &#34;&#34;&#34;
        # node.value and node.attr
        # node.value is some kind of AST node
        # node.attr is a string (or perhaps name)

        # node.value.id gets us module name (string)
        # node.attr gets us attribute we&#39;re accessing (string)
        # helper(node.attr) -&gt; &#34;module_name&#34;.node.attr

        # x.T -&gt; node.value: the node x (Name) -&gt; node.attr is just &#34;T&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        value_cast = self.visit(
            node.value, prev_scope_id_dict, curr_scope_id_dict
        )
        unique_name = (
            node.attr
        )  # TODO: This unique name might change to better reflect what it belongs to (i.e. x.T instead of just T)

        if isinstance(node.ctx, ast.Load):
            if unique_name not in curr_scope_id_dict:
                if unique_name in prev_scope_id_dict:
                    curr_scope_id_dict[unique_name] = prev_scope_id_dict[
                        unique_name
                    ]
                else:
                    if (
                        unique_name not in self.global_identifier_dict
                    ):  # added for random.seed not exising, and other modules like that. in other words for functions in modules that we don&#39;t have visibility for.
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )
                    curr_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]
        if isinstance(node.ctx, ast.Store):
            if unique_name not in curr_scope_id_dict:
                if unique_name in prev_scope_id_dict:
                    curr_scope_id_dict[unique_name] = prev_scope_id_dict[
                        unique_name
                    ]
                else:
                    self.insert_next_id(curr_scope_id_dict, unique_name)

        attr_cast = Name(
            name=node.attr, id=curr_scope_id_dict[unique_name], source_refs=ref
        )

        return [Attribute(value_cast[0], attr_cast, source_refs=ref)]

    @visit.register
    def visit_AugAssign(
        self,
        node: ast.AugAssign,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST AugAssign node, which is used for an
        augmented assignment, like x += 1. AugAssign node is converted
        to a regular PyAST Assign node and passed to that visitor to
        generate CAST.

        Args:
            node (ast.AugAssign): A PyAST AugAssign node

        Returns:
            Assign: A CAST Assign node, generated by the Assign visitor.
        &#34;&#34;&#34;

        # Convert AugAssign to regular Assign, and visit
        target = node.target
        value = node.value

        if isinstance(target, ast.Attribute):
            convert = ast.Assign(
                targets=[target],
                value=ast.BinOp(
                    left=target,
                    op=node.op,
                    right=value,
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )
        elif isinstance(target, ast.Subscript):
            convert = ast.Assign(
                targets=[target],
                value=ast.BinOp(
                    left=target,
                    ctx=ast.Load(),
                    op=node.op,
                    right=value,
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )
        else:
            convert = ast.Assign(
                targets=[target],
                value=ast.BinOp(
                    left=ast.Name(
                        target.id,
                        ctx=ast.Load(),
                        col_offset=node.col_offset,
                        end_col_offset=node.end_col_offset,
                        lineno=node.lineno,
                        end_lineno=node.end_lineno,
                    ),
                    op=node.op,
                    right=value,
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )

        return self.visit(convert, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_BinOp(
        self,
        node: ast.BinOp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST BinOp node, which consists of all the arithmetic
        and bitwise operators.

        Args:
            node (ast.BinOp): A PyAST Binary operator node

        Returns:
            Operator: A CAST operator node representing a math
                      operation (arithmetic or bitwise)
        &#34;&#34;&#34;

        left = self.visit(node.left, prev_scope_id_dict, curr_scope_id_dict)
        op = get_op(node.op)
        right = self.visit(node.right, prev_scope_id_dict, curr_scope_id_dict)

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        leftb = []
        rightb = []

        if len(left) &gt; 1:
            leftb = left[0:-1]
        if len(right) &gt; 1:
            rightb = right[0:-1]

        return (
            leftb 
            + rightb
            + [Operator(source_language=&#34;Python&#34;, 
                        interpreter=&#34;Python&#34;, 
                        version=get_python_version(), 
                        op=op, 
                        operands=[left[-1], right[-1]], 
                        source_refs=ref)]
        )

    @visit.register
    def visit_Break(
        self,
        node: ast.Break,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Break node, which is just a break statement
           nothing to be done for a Break node, just return a ModelBreak()
           object

        Args:
            node (ast.Break): An AST Break node

        Returns:
            ModelBreak: A CAST Break node

        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [ModelBreak(source_refs=ref)]

    def create_binary_compare_tree(self, node):
        if isinstance(node, (ast.Compare, ast.UnaryOp, ast.Call, ast.Name, ast.Attribute, ast.Constant, ast.Subscript)):
            return node
        # elif isinstance(node, ast.UnaryOp):
        #    return node
        #elif isinstance(node, ast.Call):
         #   return node
        elif isinstance(node, ast.BoolOp):
            # &gt; 2 values implies nested &#39;and&#39; or &#39;or&#39;
            if len(node.values) &gt; 2:
                op = [node.op]
                # left_most = self.create_binary_compare_tree(node.values[0])
                # Build binary trees of ast.Compare nodes their children being 
                # the original leaves
                # In other words decompress the tree so it&#39;s binary instead of n-ary

                idx = len(node.values) - 1
                tree_root = None
                while idx &gt;= 0:
                    if tree_root == None:        
                        left_child = self.create_binary_compare_tree(node.values[idx - 1]) 
                        right_child = self.create_binary_compare_tree(node.values[idx]) 

                        compare_op = ast.Compare(
                            left=left_child,
                            ops=op,
                            comparators=[right_child],
                            col_offset=node.col_offset,
                            end_col_offset=node.end_col_offset,
                            lineno=node.lineno,
                            end_lineno=node.end_lineno,
                        )

                        tree_root = compare_op
                        idx = idx - 2
                    else:
                        left_child = self.create_binary_compare_tree(node.values[idx])

                        compare_op = ast.Compare(
                            left=left_child,
                            ops=op,
                            comparators=[tree_root],
                            col_offset=node.col_offset,
                            end_col_offset=node.end_col_offset,
                            lineno=node.lineno,
                            end_lineno=node.end_lineno,
                        )

                        tree_root = compare_op
                        idx = idx - 1

                return tree_root
            else:
                op = [node.op]

                left_child = self.create_binary_compare_tree(node.values[0])
                right_child = self.create_binary_compare_tree(node.values[1])
                compare_op = ast.Compare(
                    left=left_child,
                    ops=op,
                    comparators=[right_child],
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                )
                
                return compare_op
        print(f&#34;catch type {type(node)}&#34;)

    @visit.register
    def visit_BoolOp(
        self,
        node: ast.BoolOp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a BoolOp node, which is a boolean operation connected with &#39;and&#39;/&#39;or&#39;s
           The BoolOp node gets converted into an AST Compare node, and then the work is
           passed off to it.

        Args:
            node (ast.BoolOp): An AST BoolOp node

        Returns:
            BinaryOp: A BinaryOp node that is composed of operations connected with &#39;and&#39;/&#39;or&#39;s

        &#34;&#34;&#34;
        
        x = self.create_binary_compare_tree(node)
        &#34;&#34;&#34;
        print(&#34;Root&#34;)
        print(x.ops)
        print(x.left)
        print(x.comparators)

        print(&#34;Left&#34;)
        print(x.left.ops)
        print(x.left.left)
        print(x.left.comparators)

        print(&#34;Right&#34;)
        print(x.comparators[0].ops)
        print(x.comparators[0].left)
        print(x.comparators[0].comparators)
        &#34;&#34;&#34;

        return self.visit(x, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Call(
        self,
        node: ast.Call,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Call node, which represents a function call.
        Special care must be taken to see if it&#39;s a function call or a class&#39;s
        method call. The CAST is generated a little different depending on
        what kind of call it is.

        Args:
            node (ast.Call): a PyAST Call node

        Returns:
            Call: A CAST function call node
        &#34;&#34;&#34;

        args = []
        func_args = []
        kw_args = []
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        if len(node.args) &gt; 0:
            for arg in node.args:
                if isinstance(arg, ast.Subscript):
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;_get&#34;
                    )
                    if unique_name not in prev_scope_id_dict.keys():
                        # If a built-in is called, then it gets added to the global dictionary if
                        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                        # function
                        if (
                            unique_name
                            not in self.global_identifier_dict.keys()
                        ):
                            self.insert_next_id(
                                self.global_identifier_dict, unique_name
                            )

                        prev_scope_id_dict[
                            unique_name
                        ] = self.global_identifier_dict[unique_name]
                    idx = self.visit(
                        arg.slice, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    val = self.visit(
                        arg.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    args = [val, idx]

                    func_args.extend(
                        [
                            Call(
                                func=Name(
                                    &#34;_get&#34;,
                                    id=prev_scope_id_dict[unique_name],
                                    source_refs=ref,
                                ),
                                arguments=args,
                                source_refs=ref,
                            )
                        ]
                    )
                elif isinstance(arg, ast.Starred):
                    if isinstance(arg.value, ast.Subscript):
                        func_args.append(
                            Name(
                                name=arg.value.value.id, id=-1, source_refs=ref
                            )
                        )
                    else:
                        func_args.append(
                            Name(name=arg.value.id, id=-1, source_refs=ref)
                        )
                else:
                    res = self.visit(
                        arg, prev_scope_id_dict, curr_scope_id_dict
                    )
                    if res != None:
                        func_args.extend(res)

        # g(3,id=4) TODO: Think more about this
        if len(node.keywords) &gt; 0:
            for arg in node.keywords:
                # print(prev_scope_id_dict)
                # print(curr_scope_id_dict)
                if arg.arg != None:
                    val = self.visit(
                        arg.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]

                    assign_node = Assignment(
                        left=Var(
                            Name(
                                name=arg.arg, id=100, source_refs=ref
                            ),  # TODO: add a proper ID here
                            type=&#34;float&#34;,
                            source_refs=ref,
                        ),
                        right=val,
                        source_refs=ref,
                    )
                elif isinstance(arg.value, ast.Dict):
                    val = self.visit(
                        arg.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0]
                    assign_node = val
                else:
                    if isinstance(arg.value, ast.Attribute) and isinstance(
                        arg.value.value, ast.Attribute
                    ):
                        assign_node = Name(
                            name=arg.value.value.attr, id=-1, source_refs=ref
                        )
                    elif isinstance(arg.value, ast.Call):
                        assign_node = Name(
                            name=arg.value.func.id, id=-1, source_refs=ref
                        )
                    elif isinstance(arg.value, ast.Attribute):
                        assign_node = Name(
                            name=arg.value.value, id=-1, source_refs=ref
                        )
                    elif isinstance(arg.value, ast.Subscript):
                        assign_node = Name(
                            name=arg.value.value.id, id=-1, source_refs=ref
                        )
                    else:
                        assign_node = Name(
                            name=arg.value.id, id=-1, source_refs=ref
                        )
                kw_args.append(assign_node)
                # kw_args.extend(self.visit(arg.value, prev_scope_id_dict, curr_scope_id_dict))

        args = func_args + kw_args

        if isinstance(node.func, ast.Attribute):
            # print(node.func.attr)
            res = self.visit(node.func, prev_scope_id_dict, curr_scope_id_dict)
            return [Call(func=res[0], arguments=args, source_refs=ref)]
        else:
            # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
            # This should only be the case for built-in python functions (i.e print, len, etc...)
            # Otherwise it would be an error to call a function before it is defined
            # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
            if isinstance(node.func, ast.Call):
                if node.func.func.id == &#34;list&#34;:
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;cast&#34;
                    )
                else:
                    unique_name = construct_unique_name(
                        self.filenames[-1], node.func.func.id
                    )
            else:
                if node.func.id == &#34;list&#34;:
                    unique_name = construct_unique_name(
                        self.filenames[-1], &#34;cast&#34;
                    )
                else:
                    unique_name = construct_unique_name(
                        self.filenames[-1], node.func.id
                    )
            if unique_name not in prev_scope_id_dict.keys(): # and unique_name not in curr_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]

            if isinstance(node.func, ast.Call):
                if node.func.func.id == &#34;list&#34;:
                    args.append(
                        LiteralValue(
                            StructureType.LIST,
                            node.func.func.id,
                            [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                            ref,
                        )
                    )
                    return [
                        Call(
                            func=Name(
                                &#34;cast&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
                else:
                    return [
                        Call(
                            func=Name(
                                node.func.func.id,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
            else:
                if node.func.id == &#34;list&#34;:
                    args.append(
                        LiteralValue(
                            StructureType.LIST,
                            node.func.id,
                            [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                            ref,
                        )
                    )
                    return [
                        Call(
                            func=Name(
                                &#34;cast&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
                else:
                    return [
                        Call(
                            func=Name(
                                node.func.id,
                                id=curr_scope_id_dict[unique_name] if unique_name in curr_scope_id_dict else prev_scope_id_dict[unique_name], # NOTE: do this everywhere?
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]

    def collect_fields(
        self, node: ast.FunctionDef, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Attempts to solve the problem of collecting any additional fields
        for a class that get created in functions outside of __init__
        &#34;&#34;&#34;
        fields = []
        for n in node.body:
            if isinstance(n, ast.Assign) and isinstance(
                n.targets[0], ast.Attribute
            ):
                attr_node = n.targets[0]
                if isinstance(attr_node.value, ast.Attribute):
                    if attr_node.value.value == &#34;self&#34;:
                        ref = [
                            SourceRef(
                                source_file_name=self.filenames[-1],
                                col_start=attr_node.col_offset,
                                col_end=attr_node.end_col_offset,
                                row_start=attr_node.lineno,
                                row_end=attr_node.end_lineno,
                            )
                        ]
                        # Need IDs for name, which one?
                        attr_id = self.insert_next_id(
                            curr_scope_id_dict, attr_node.value.attr
                        )
                        fields.append(
                            Var(
                                Name(
                                    attr_node.value.attr,
                                    id=attr_id,
                                    source_refs=ref,
                                ),
                                &#34;float&#34;,
                                source_refs=ref,
                            )
                        )
                elif attr_node.value.id == &#34;self&#34;:
                    ref = [
                        SourceRef(
                            source_file_name=self.filenames[-1],
                            col_start=attr_node.col_offset,
                            col_end=attr_node.end_col_offset,
                            row_start=attr_node.lineno,
                            row_end=attr_node.end_lineno,
                        )
                    ]
                    # Need IDs for name, which one?
                    attr_id = self.insert_next_id(
                        curr_scope_id_dict, attr_node.attr
                    )
                    fields.append(
                        Var(
                            Name(attr_node.attr, id=attr_id, source_refs=ref),
                            &#34;float&#34;,
                            source_refs=ref,
                        )
                    )

        return fields

    @visit.register
    def visit_ClassDef(
        self,
        node: ast.ClassDef,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST ClassDef node, which is used to define user classes.
        Acquiring the fields of the class involves going through the __init__
        function and seeing if the attributes are associated with the self
        parameter. In addition, we add to the &#39;classes&#39; dictionary the name of
        the class and a list of all its functions.

        Args:
            node (ast.ClassDef): A PyAST class definition node

        Returns:
            ClassDef: A CAST class definition node
        &#34;&#34;&#34;
        name = node.name
        self.classes[name] = []

        bases = []
        for base in node.bases:
            bases.extend(
                self.visit(base, prev_scope_id_dict, curr_scope_id_dict)
            )

        fields = []
        funcs = []
        for func in node.body:
            if isinstance(func, ast.FunctionDef):
                if func.name != &#34;__init__&#34;:
                    fields.extend(
                        self.collect_fields(
                            func, prev_scope_id_dict, curr_scope_id_dict
                        )
                    )
                funcs.extend(
                    self.visit(func, prev_scope_id_dict, curr_scope_id_dict)
                )
                # curr_scope_id_dict = {}
                # if isinstance(func,ast.FunctionDef):
                self.classes[name].append(func.name)
                # self.insert_next_id(prev_scope_id_dict, name)
                self.insert_next_id(prev_scope_id_dict, f&#34;{name}.{func.name}&#34;)

        # print(prev_scope_id_dict)
        # print(curr_scope_id_dict)
        # Get the fields in the class from init
        init_func = None
        for f in node.body:
            if isinstance(f, ast.FunctionDef) and f.name == &#34;__init__&#34;:
                init_func = f.body
                break

        if init_func != None:
            for func_node in init_func:
                if isinstance(func_node, ast.Assign) and isinstance(
                    func_node.targets[0], ast.Attribute
                ):
                    attr_node = func_node.targets[0]
                    if attr_node.value.id == &#34;self&#34;:
                        ref = [
                            SourceRef(
                                source_file_name=self.filenames[-1],
                                col_start=attr_node.col_offset,
                                col_end=attr_node.end_col_offset,
                                row_start=attr_node.lineno,
                                row_end=attr_node.end_lineno,
                            )
                        ]
                        # Need IDs for name, which one?
                        attr_id = self.insert_next_id(
                            curr_scope_id_dict, attr_node.attr
                        )
                        fields.append(
                            Var(
                                Name(
                                    attr_node.attr, id=attr_id, source_refs=ref
                                ),
                                &#34;float&#34;,
                                source_refs=ref,
                            )
                        )

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [RecordDef(name, bases, funcs, fields, source_refs=ref)]

    @visit.register
    def visit_Compare(
        self,
        node: ast.Compare,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Compare node, which consists of boolean operations

        Args:
            node (ast.Compare): A PyAST Compare node

        Returns:
            Operator: An Operator node, which in this case will hold a boolean
            operation
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]


        # Fetch the first element (which is in node.left)
        #left = node.left
        #ops = [op for op in node.ops]
        # Grab the first comparison operation
        # print(left)
        # print(node.ops)
        # op = get_op(node.ops.pop(0))
        # op = get_op(ops.pop())

        
        # maintain a stack of if statements that we build up
        if_stack = []
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(True))]
        true_val = LiteralValue(
            ScalarType.BOOLEAN,
            &#34;True&#34;,
            source_code_data_type=source_code_data_type,
            source_refs=ref,
        )
        false_val = LiteralValue(
            ScalarType.BOOLEAN,
            &#34;False&#34;,
            source_code_data_type=source_code_data_type,
            source_refs=ref,
        )


        idx = len(node.comparators) - 1
        op_idx = len(node.ops) - 1
        tree_root = None
        while idx &gt; 0:
            op = get_op(node.ops[op_idx])
            l = self.visit(node.comparators[idx - 1], prev_scope_id_dict, curr_scope_id_dict)[0]
            r = self.visit(node.comparators[idx], prev_scope_id_dict, curr_scope_id_dict)[0] 

            if op == &#34;ast.And&#34;:
                test = ModelIf(expr=l, body=[r], orelse=[false_val], source_refs=ref)
            elif op == &#34;ast.Or&#34;:
                test = ModelIf(expr=l, body=[true_val], orelse=[r], source_refs=ref)
            else:
                test = Operator(source_language=&#34;Python&#34;, interpreter=&#34;Python&#34;,
                                version=get_python_version(),
                                op=op,
                                operands=[l,r],
                                source_refs=ref)
            if tree_root == None:        
                tree_root = test
            else:
                tree_root = ModelIf(expr=test,body=[tree_root],orelse=[false_val], source_refs=ref)

            op_idx = op_idx - 1
            idx = idx - 1

        op = get_op(node.ops[op_idx])
        l = self.visit(node.left, prev_scope_id_dict, curr_scope_id_dict)[0]
        r = self.visit(node.comparators[idx], prev_scope_id_dict, curr_scope_id_dict)[0] 
        if op == &#34;ast.And&#34;:
            test = ModelIf(expr=l, body=[r], orelse=[false_val], source_refs=ref)
        elif op == &#34;ast.Or&#34;:
            test = ModelIf(expr=l, body=[true_val], orelse=[r], source_refs=ref)
        else:
            test = Operator(source_language=&#34;Python&#34;, interpreter=&#34;Python&#34;,
                            version=get_python_version(),
                            op=op,
                            operands=[l,r],
                            source_refs=ref)

        if tree_root == None:
            tree_root = test
        else:
            tree_root = ModelIf(expr=test,body=[tree_root],orelse=[false_val], source_refs=ref)

        return [tree_root]


    @visit.register
    def visit_Constant(
        self,
        node: ast.Constant,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Constant node, which can hold either numeric or
        string values. A dictionary is used to index into which operation
        we&#39;re doing.

        Args:
            node (ast.Constant): A PyAST Constant node

        Returns:
            Number: A CAST numeric node, if the node&#39;s value is an int or float
            String: A CAST string node, if the node&#39;s value is a string
            Boolean: A CAST boolean node, if the node&#39;s value is a boolean

        Raises:
            TypeError: If the node&#39;s value is something else that isn&#39;t
                       recognized by the other two cases
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(node.value))]
        # NOTE: We have to check the types such that no ancestor is checked before a descendant
        # boolean values are also seen as integers with isinstance()
        # TODO: Consider using type() with a map instead of isinstance to check types
        if isinstance(node.value, bool):
            return [
                LiteralValue(
                    ScalarType.BOOLEAN,
                    str(node.value),
                    source_code_data_type,
                    ref,
                )
            ]
        elif isinstance(node.value, int):
            return [
                LiteralValue(
                    ScalarType.INTEGER, node.value, source_code_data_type, ref
                )
            ]
        elif isinstance(node.value, float):
            return [
                LiteralValue(
                    ScalarType.ABSTRACTFLOAT,
                    node.value,
                    source_code_data_type,
                    ref,
                )
            ]
        elif isinstance(node.value, str):
            return [
                LiteralValue(
                    StructureType.LIST, node.value, source_code_data_type, ref
                )
            ]
        elif node.value is None:
            return [LiteralValue(None, None, source_code_data_type, ref)]
        elif isinstance(node.value, type(...)):
            return []
        else:
            raise TypeError(f&#34;Type {str(type(node.value))} not supported&#34;)

    @visit.register
    def visit_Continue(
        self,
        node: ast.Continue,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Continue node, which is just a continue statement
           nothing to be done for a Continue node, just return a ModelContinue node

        Args:
            node (ast.Continue): An AST Continue node

        Returns:
            ModelContinue: A CAST Continue node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [ModelContinue(source_refs=ref)]

    @visit.register
    def visit_Dict(
        self,
        node: ast.Dict,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Dict node, which represents a dictionary.

        Args:
            node (ast.Dict): A PyAST dictionary node

        Returns:
            Dict: A CAST Dictionary node.
        &#34;&#34;&#34;
        # TODO: when a ** shows up in a dictionary

        keys = []
        values = []
        if len(node.keys) &gt; 0:
            for piece in node.keys:
                if piece != None:
                    keys.extend(
                        self.visit(
                            piece, prev_scope_id_dict, curr_scope_id_dict
                        )
                    )

        if len(node.values) &gt; 0:
            for piece in node.values:
                if piece != None:
                    values.extend(
                        self.visit(
                            piece, prev_scope_id_dict, curr_scope_id_dict
                        )
                    )

        k = [e.value if hasattr(e, &#34;value&#34;) else e for e in keys]
        v = [e.value if hasattr(e, &#34;value&#34;) else e for e in values]

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        for key in k:
            if isinstance(key, LiteralValue) and key.value_type == StructureType.TUPLE:
                return [
                    LiteralValue(
                        StructureType.MAP,
                        &#34;&#34;,
                        source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, str(dict)],
                        source_refs=ref,
                    )
                ]

        # return [LiteralValue(StructureType.MAP, str(dict(list(zip(k,v)))), source_code_data_type=[&#34;Python&#34;,&#34;3.8&#34;,str(dict)], source_refs=ref)]
        return [
            LiteralValue(
                StructureType.MAP,
                str(list(zip(k, v))),
                source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, str(dict)],
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_Expr(
        self,
        node: ast.Expr,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Expr node, which represents some kind of standalone
        expression.

        Args:
            node (ast.Expr): A PyAST Expression node

        Returns:
            Expr:      A CAST Expression node
            [AstNode]: A list of AstNodes if the expression consists
                       of more than one node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_For(
        self, node: ast.For, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST For node, which represents Python for loops.
        A For loop needs different handling than a while loop.
        In particular, a For loop acts on an iterator as opposed to acting on
        some kind of condition. In order to make this translation a little easier to handle
        we leverage the iterator constructs to convert the For loop into a while loop using
        the iterators.

        Args:
            node (ast.For): A PyAST For loop node.

        Returns:
            Loop: A CAST loop node, which generically represents both For
                  loops and While loops.
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        target = self.visit(
            node.target, prev_scope_id_dict, curr_scope_id_dict
        )[0]
        iterable = self.visit(
            node.iter, prev_scope_id_dict, curr_scope_id_dict
        )[0]

        # The body of a loop contains its own scope (it can create variables only it can see and can use
        # variables from its enclosing scope) so we copy the current scope and merge scopes
        # to create the enclosing scope for the loop body
        curr_scope_copy = copy.deepcopy(curr_scope_id_dict)
        merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
        loop_scope_id_dict = {}

        # When we pass in scopes, we pass what&#39;s currently in the previous scope along with
        # the curr scope which would consist of the loop variables (node.target) and the item
        # we loop over (iter) though the second one shouldn&#39;t ever be accessed
        body = []
        for piece in node.body + node.orelse:
            body.extend(
                self.visit(piece, curr_scope_id_dict, loop_scope_id_dict)
            )

        # Once we&#39;re out of the loop body we can copy the current scope back
        curr_scope_id_dict = copy.deepcopy(curr_scope_copy)

        # TODO: Mark these as variables that were generated by this script at some point
        # (^ This was a really old request, not sure if it&#39;s still needed at this point)
        iterator_name = f&#34;generated_iter_{self.var_count}&#34;
        self.var_count += 1

        iterator_id = self.insert_next_id(curr_scope_id_dict, iterator_name)

        # &#39;iter&#39; and &#39;next&#39; are python built-ins
        iter_id = -1
        if &#34;iter&#34; not in self.global_identifier_dict.keys():
            iter_id = self.insert_next_id(self.global_identifier_dict, &#34;iter&#34;)
        else:
            iter_id = self.global_identifier_dict[&#34;iter&#34;]

        if &#34;next&#34; not in self.global_identifier_dict.keys():
            next_id = self.insert_next_id(self.global_identifier_dict, &#34;next&#34;)
        else:
            next_id = self.global_identifier_dict[&#34;next&#34;]

        stop_cond_name = f&#34;sc_{self.var_count}&#34;
        self.var_count += 1

        stop_cond_id = self.insert_next_id(curr_scope_id_dict, stop_cond_name)

        iter_var_cast = Var(
            Name(name=iterator_name, id=iterator_id, source_refs=ref),
            &#34;iterator&#34;,
            source_refs=ref,
        )

        stop_cond_var_cast = Var(
            Name(name=stop_cond_name, id=stop_cond_id, source_refs=ref),
            &#34;boolean&#34;,
            source_refs=ref,
        )

        iter_var = Assignment(
            iter_var_cast,
            Call(
                func=Name(name=&#34;iter&#34;, id=iter_id, source_refs=ref),
                arguments=[iterable],
                source_refs=ref,
            ),
            source_refs=ref,
        )

        source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
        first_next = Assignment(
            LiteralValue(StructureType.TUPLE, [target, iter_var_cast, stop_cond_var_cast], source_code_data_type, source_refs=ref),
            Call(
                func=Name(name=&#34;next&#34;, id=next_id, source_refs=ref),
                arguments=[
                    Var(
                        Name(
                            name=iterator_name, id=iterator_id, source_refs=ref
                        ),
                        &#34;iterator&#34;,
                        source_refs=ref,
                    )
                ],
                source_refs=ref,
            ),
            source_refs=ref,
        )
        loop_cond = Operator(source_language=&#34;Python&#34;, 
                    interpreter=&#34;Python&#34;, 
                    version=get_python_version(), 
                    op=&#34;ast.Eq&#34;, 
                    operands=[stop_cond_var_cast,
                    LiteralValue(
                        ScalarType.BOOLEAN,
                        False,
                        [&#34;Python&#34;, &#34;3.8&#34;, &#34;boolean&#34;],
                        source_refs=ref,
                    )], 
                    source_refs=ref)

        source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
        loop_assign = Assignment(
            LiteralValue(StructureType.TUPLE, [target, iter_var_cast, stop_cond_var_cast], source_code_data_type, source_refs=ref),
            Call(
                func=Name(name=&#34;next&#34;, id=next_id, source_refs=ref),
                arguments=[
                    Var(
                        Name(
                            name=iterator_name, id=iterator_id, source_refs=ref
                        ),
                        &#34;iterator&#34;,
                        source_refs=ref,
                    )
                ],
                source_refs=ref,
            ),
            source_refs=ref,
        )

        return [
            Loop(
                pre=[iter_var, first_next],
                expr=loop_cond,
                body=body + [loop_assign],
                post=[],
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_FunctionDef(
        self,
        node: ast.FunctionDef,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST FunctionDef node. Which is used for a Python
        function definition.

        Args:
            node (ast.FunctionDef): A PyAST function definition node

        Returns:
            FunctionDef: A CAST Function Definition node
        &#34;&#34;&#34;

        # Copy the enclosing scope dictionary as it is before we visit the current function
        # The idea for this is to prevent any weird overwritting issues that may arise from modifying
        # dictionaries in place
        prev_scope_id_dict_copy = copy.deepcopy(prev_scope_id_dict)

        body = []
        args = []
        curr_scope_id_dict = {}
        arg_count = len(node.args.args)
        kwonlyargs_count = len(node.args.kwonlyargs)
        default_val_count = len(node.args.defaults)
        if arg_count &gt; 0:
            # No argument has a default value
            if default_val_count == 0:
                for arg in node.args.args:
                    # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                    # self.insert_next_id(curr_scope_id_dict, arg.arg)
                    # self.insert_next_id(curr_scope_id_dict, f&#34;{node.name}.{arg.arg}&#34;)
                    self.insert_next_id(curr_scope_id_dict, f&#34;{arg.arg}&#34;)
                    # self.insert_next_id(curr_scope_id_dict, unique_name)
                    arg_ref = SourceRef(self.filenames[-1], arg.col_offset, arg.end_col_offset, arg.lineno, arg.end_lineno)
                    args.append(
                        Var(
                            Name(
                                arg.arg,
                                id=curr_scope_id_dict[arg.arg],
                                # id=curr_scope_id_dict[f&#34;{node.name}.{arg.arg}&#34;],
                                source_refs=[arg_ref]
                            ),
                            &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                            None,
                            source_refs=[arg_ref]
                        )
                    )
            else:
                # Implies that all arguments have default values
                if arg_count == default_val_count:
                    for i, arg in enumerate(node.args.args, 0):
                        self.insert_next_id(curr_scope_id_dict, arg.arg)
                        val = self.visit(
                            node.args.defaults[i],
                            prev_scope_id_dict,
                            curr_scope_id_dict,
                        )[0]
                        args.append(
                            Var(
                                Name(
                                    arg.arg,
                                    id=curr_scope_id_dict[arg.arg],
                                    source_refs=[
                                        SourceRef(
                                            self.filenames[-1],
                                            arg.col_offset,
                                            arg.end_col_offset,
                                            arg.lineno,
                                            arg.end_lineno,
                                        )
                                    ],
                                ),
                                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                                val,
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            )
                        )

                # There&#39;s less default values than actual args, the positional-only arguments come first
                else:
                    pos_idx = 0
                    for arg in node.args.args:
                        if arg_count == default_val_count:
                            break
                        self.insert_next_id(curr_scope_id_dict, arg.arg)
                        args.append(
                            Var(
                                Name(
                                    arg.arg,
                                    id=curr_scope_id_dict[arg.arg],
                                    source_refs=[
                                        SourceRef(
                                            self.filenames[-1],
                                            arg.col_offset,
                                            arg.end_col_offset,
                                            arg.lineno,
                                            arg.end_lineno,
                                        )
                                    ],
                                ),
                                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                                None,
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            )
                        )

                        pos_idx += 1
                        arg_count -= 1

                    default_index = 0
                    while arg_count &gt; 0:
                        # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                        arg = node.args.args[pos_idx]
                        self.insert_next_id(curr_scope_id_dict, arg.arg)
                        val = self.visit(
                            node.args.defaults[default_index],
                            prev_scope_id_dict,
                            curr_scope_id_dict,
                        )[0]
                        # self.insert_next_id(curr_scope_id_dict, unique_name)
                        args.append(
                            Var(
                                Name(
                                    arg.arg,
                                    id=curr_scope_id_dict[arg.arg],
                                    source_refs=[
                                        SourceRef(
                                            self.filenames[-1],
                                            arg.col_offset,
                                            arg.end_col_offset,
                                            arg.lineno,
                                            arg.end_lineno,
                                        )
                                    ],
                                ),
                                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                                val,
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            )
                        )

                        pos_idx += 1
                        arg_count -= 1
                        default_index += 1

        if kwonlyargs_count &gt; 0:
            for arg in node.args.kwonlyargs:
                # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                self.insert_next_id(curr_scope_id_dict, arg.arg)
                # self.insert_next_id(curr_scope_id_dict, unique_name)
                args.append(
                    Var(
                        Name(
                            arg.arg,
                            id=curr_scope_id_dict[arg.arg],
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        ),
                        &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                        None,
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    )
                )

        # Store &#39;*args&#39; as a name
        arg = node.args.vararg
        if arg != None:
            self.insert_next_id(curr_scope_id_dict, arg.arg)
            args.append(
                Var(
                    Name(
                        arg.arg,
                        id=curr_scope_id_dict[arg.arg],
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    ),
                    &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                    None,
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                )
            )

        # Store &#39;**kwargs&#39; as a name
        arg = node.args.kwarg
        if arg != None:
            self.insert_next_id(curr_scope_id_dict, arg.arg)
            args.append(
                Var(
                    Name(
                        arg.arg,
                        id=curr_scope_id_dict[arg.arg],
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    ),
                    &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                    None,
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                )
            )

        functions_to_visit = []

        if len(node.body) &gt; 0:
            # To account for nested loops we check to see if the CAST node is in a list and
            # extend accordingly

            for piece in node.body:
                if isinstance(piece, ast.Assign):
                    names = get_node_name(piece)

                    for var_name in names:
                        # unique_name = construct_unique_name(
                        #    self.filenames[-1], var_name
                        # )
                        self.insert_next_id(curr_scope_id_dict, var_name)
                            
                    merge_dicts(curr_scope_id_dict, prev_scope_id_dict)
            # merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
            for piece in node.body:

                if isinstance(piece, ast.FunctionDef):
                    unique_name = construct_unique_name(self.filenames[-1], piece.name)
                    self.insert_next_id(curr_scope_id_dict, unique_name)
                    prev_scope_id_dict[unique_name] = curr_scope_id_dict[unique_name]
                    # functions_to_visit.append(piece)
                    #continue

                    # print(curr_scope_id_dict)
                    # print(prev_scope_id_dict)

                # Have to figure out name IDs for imports (i.e. other modules)
                # These asserts will keep us from visiting them from now
                # assert not isinstance(piece, ast.Import)
                # assert not isinstance(piece, ast.ImportFrom)
                to_add = self.visit(
                    piece, prev_scope_id_dict, curr_scope_id_dict
                )

                # TODO: Find the case where &#34;__getitem__&#34; is used
                if hasattr(to_add, &#34;__iter__&#34;) or hasattr(
                    to_add, &#34;__getitem__&#34;
                ):
                    body.extend(to_add)
                elif to_add == None:
                    body.extend([])
                else:
                    raise TypeError(
                        f&#34;Unexpected type in visit_FuncDef: {type(to_add)}&#34;
                    )

            # Merge keys from prev_scope not in cur_scope into cur_scope
            # merge_dicts(prev_scope_id_dict, curr_scope_id_dict)

            # Visit the deferred functions
            #for piece in functions_to_visit:
             #   to_add = self.visit(piece, curr_scope_id_dict, {})
              #  body.extend(to_add)

        # TODO: Decorators? Returns? Type_comment?
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # &#34;Revert&#34; the enclosing scope dictionary to what it was before we went into this function
        # since none of the variables within here should exist outside of here..?
        # TODO: this might need to be different, since Python variables can exist outside of a scope??
        prev_scope_id_dict = copy.deepcopy(prev_scope_id_dict_copy)

        # Global level (i.e. module level) functions have their module names appended to them, we make sure
        # we have the correct name depending on whether or not we&#39;re visiting a global
        # level function or a function enclosed within another function
        if node.name in prev_scope_id_dict.keys():
            if self.legacy:
                return [FunctionDef(node.name, args, body, source_refs=ref)]
            else:
                return [
                    FunctionDef(
                        Name(
                            node.name,
                            prev_scope_id_dict[node.name],
                            source_refs=ref,
                        ),
                        args,
                        body,
                        source_refs=ref,
                    )
                ]
        else:
            unique_name = construct_unique_name(self.filenames[-1], node.name)
            if unique_name in prev_scope_id_dict.keys():
                if self.legacy:
                    return [
                        FunctionDef(node.name, args, body, source_refs=ref)
                    ]
                else:
                    return [
                        FunctionDef(
                            Name(
                                node.name,
                                prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            args,
                            body,
                            source_refs=ref,
                        )
                    ]
            else:
                self.insert_next_id(prev_scope_id_dict, unique_name)
                return [
                    FunctionDef(
                        Name(
                            node.name,
                            prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        args,
                        body,
                        source_refs=ref,
                    )
                ]

    @visit.register
    def visit_Lambda(
        self,
        node: ast.Lambda,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Lambda node. Which is used for a Python Lambda
        function definition. It works pretty analogously to the FunctionDef
        node visitor. It also returns a FunctionDef node like the PyAST
        FunctionDef node visitor.

        Args:
            node (ast.Lambda): A PyAST lambda function definition node

        Returns:
            FunctionDef: A CAST Function Definition node

        &#34;&#34;&#34;

        curr_scope_id_dict = {}

        args = []
        # TODO: Correct typing instead of just &#39;float&#39;
        if len(node.args.args) &gt; 0:
            for arg in node.args.args:
                self.insert_next_id(curr_scope_id_dict, arg.arg)

                args.append(
                    Var(
                        Name(
                            arg.arg,
                            id=curr_scope_id_dict[arg.arg],
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        ),
                        &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    )
                )

        body = self.visit(node.body, prev_scope_id_dict, curr_scope_id_dict)

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        # TODO: add an ID for lambda name
        if self.legacy:
            return [FunctionDef(&#34;LAMBDA&#34;, args, body, source_refs=ref)]
        else:
            lambda_name = f&#34;%lambda{self.lambda_count}&#34;
            self.lambda_count += 1
            lambda_id = -1 # TODO

            name_node = Name(lambda_name, lambda_id, source_refs=ref)
            self.generated_fns.append(FunctionDef(name_node, args, body, source_refs=ref))
        
            # NOTE: What should the arguments be?
            to_ret = [Call(func=Name(lambda_name, lambda_id, source_refs=ref),arguments=args,source_refs=ref)]

            return to_ret

    @visit.register
    def visit_ListComp(
        self,
        node: ast.ListComp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST ListComp node, which are used for Python list comprehensions.
        List comprehensions generate a list from some generator expression.

        Args:
            node (ast.ListComp): A PyAST list comprehension node

        Returns:
            Loop:
        &#34;&#34;&#34;

        ref = [
            self.filenames[-1],
            node.col_offset,
            node.end_col_offset,
            node.lineno,
            node.end_lineno,
        ]

        temp_list_name = f&#34;list__temp_&#34;
        temp_assign = ast.Assign(
            targets=[
                ast.Name(
                    id=temp_list_name,
                    ctx=ast.Store(),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ],
            value=ast.List(
                elts=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            ),
            type_comment=None,
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )

        generators = node.generators
        first_gen = generators[-1]
        i = len(generators) - 2

        # Constructs the Python AST for the innermost loop in the list comprehension
        if len(first_gen.ifs) &gt; 0:
            innermost_loop_body = [
                ast.If(
                    test=first_gen.ifs[0],
                    body=[
                        ast.Expr(
                            value=ast.Call(
                                func=ast.Attribute(
                                    value=ast.Name(
                                        id=temp_list_name,
                                        ctx=ast.Load(),
                                        col_offset=ref[1],
                                        end_col_offset=ref[2],
                                        lineno=ref[3],
                                        end_lineno=ref[4],
                                    ),
                                    attr=&#34;append&#34;,
                                    ctx=ast.Load(),
                                    col_offset=ref[1],
                                    end_col_offset=ref[2],
                                    lineno=ref[3],
                                    end_lineno=ref[4],
                                ),
                                args=[node.elt],
                                keywords=[],
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            ),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ]
        else:
            innermost_loop_body = [
                ast.Expr(
                    value=ast.Call(
                        func=ast.Attribute(
                            value=ast.Name(
                                id=temp_list_name,
                                ctx=ast.Load(),
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            ),
                            attr=&#34;append&#34;,
                            ctx=ast.Load(),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        ),
                        args=[node.elt],
                        keywords=[],
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    ),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ]

        loop_collection = [
            ast.For(
                target=self.identify_piece(
                    first_gen.target, prev_scope_id_dict, curr_scope_id_dict
                ),
                iter=first_gen.iter,
                # iter=self.identify_piece(first_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                body=innermost_loop_body,
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ]

        # Every other loop in the list comprehension wraps itself around the previous loop that we
        # added
        while i &gt;= 0:
            curr_gen = generators[i]
            if len(curr_gen.ifs) &gt; 0:
                # TODO: if multiple ifs exist per a single generator then we have to expand this
                curr_if = curr_gen.ifs[0]
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    iter=self.identify_piece(
                        curr_gen.iter, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    body=[
                        ast.If(
                            test=curr_if,
                            body=[loop_collection[0]],
                            orelse=[],
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )

            else:
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    iter=self.identify_piece(
                        curr_gen.iter, curr_scope_id_dict, prev_scope_id_dict
                    ),
                    body=[loop_collection[0]],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )

            loop_collection.insert(0, next_loop)
            i = i - 1

        temp_cast = self.visit(
            temp_assign, prev_scope_id_dict, curr_scope_id_dict
        )
        loop_cast = self.visit(
            loop_collection[0], prev_scope_id_dict, curr_scope_id_dict
        )

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # TODO: arguments for a comprehension, IDs
        return_cast = [ModelReturn(value=Var(val=Name(name=temp_list_name, source_refs=ref), source_refs=ref), source_refs=ref)]

        comp_func_name = f&#34;%comprehension_list_{self.list_comp_count}&#34;
        self.list_comp_count += 1
        comp_func_id = -1 #TODO

        name_node = Name(comp_func_name, comp_func_id, source_refs=ref)
        func_def_cast = FunctionDef(name=name_node, func_args=[], body=temp_cast+loop_cast+return_cast, source_refs=ref)
        
        self.generated_fns.append(func_def_cast)

        to_ret = [Call(func=Name(comp_func_name, comp_func_id, source_refs=ref),arguments=[],source_refs=ref)]

        return to_ret

    @visit.register
    def visit_DictComp(
        self,
        node: ast.DictComp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        ref = [
            self.filenames[-1],
            node.col_offset,
            node.end_col_offset,
            node.lineno,
            node.end_lineno,
        ]

        # node (ast.DictComp)
        #  key       - what makes the keys
        #  value     - what makes the valuedds
        #  generators - list of &#39;comprehension&#39; nodes

        temp_dict_name = f&#34;dict__temp_&#34;

        generators = node.generators
        first_gen = generators[-1]
        i = len(generators) - 2
        temp_assign = ast.Assign(
            targets=[
                ast.Name(
                    id=temp_dict_name,
                    ctx=ast.Store(),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ],
            value=ast.Dict(
                keys=[],
                values=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            ),
            type_comment=None,
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )

        # Constructs the Python AST for the innermost loop in the dict comprehension
        if len(first_gen.ifs) &gt; 0:
            innermost_loop_body = ast.If(
                test=first_gen.ifs[0],
                body=[
                    ast.Assign(
                        targets=[
                            ast.Subscript(
                                value=ast.Name(
                                    id=temp_dict_name,
                                    ctx=ast.Load(),
                                    col_offset=ref[1],
                                    end_col_offset=ref[2],
                                    lineno=ref[3],
                                    end_lineno=ref[4],
                                ),
                                slice=node.key,
                                ctx=ast.Store(),
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            )
                        ],
                        value=node.value,
                        type_comment=None,
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        else:
            innermost_loop_body = ast.Assign(
                targets=[
                    ast.Subscript(
                        value=ast.Name(
                            id=temp_dict_name,
                            ctx=ast.Load(),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        ),
                        slice=node.key,
                        ctx=ast.Store(),
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                value=node.value,
                type_comment=None,
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )

        loop_collection = [
            ast.For(
                target=self.identify_piece(
                    first_gen.target, prev_scope_id_dict, curr_scope_id_dict
                ),
                iter=first_gen.iter,
                # iter=self.identify_piece(first_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                body=[innermost_loop_body],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ]

        # Every other loop in the list comprehension wraps itself around the previous loop that we
        # added
        while i &gt;= 0:
            curr_gen = generators[i]
            if len(curr_gen.ifs) &gt; 0:
                # TODO: if multiple ifs exist per a single generator then we have to expand this
                curr_if = curr_gen.ifs[0]
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, prev_scope_id_dict, curr_scope_id_dict
                    ),
                    iter=curr_gen.iter,
                    # iter=self.identify_piece(curr_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                    body=[
                        ast.If(
                            test=curr_if,
                            body=[loop_collection[0]],
                            orelse=[],
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            else:
                next_loop = ast.For(
                    target=self.identify_piece(
                        curr_gen.target, prev_scope_id_dict, curr_scope_id_dict
                    ),
                    iter=curr_gen.iter,
                    # iter=self.identify_piece(curr_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                    body=[loop_collection[0]],
                    orelse=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            loop_collection.insert(0, next_loop)
            i = i - 1

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        temp_cast = self.visit(
            temp_assign, prev_scope_id_dict, curr_scope_id_dict
        )
        loop_cast = self.visit(
            loop_collection[0], prev_scope_id_dict, curr_scope_id_dict
        )

        # TODO: Arguments for comprehension, IDs
        return_cast = [ModelReturn(value=Var(val=Name(name=temp_dict_name, id=-1, source_refs=ref), source_refs=ref), source_refs=ref)]

        comp_func_name = f&#34;%comprehension_dict_{self.dict_comp_count}&#34;
        self.dict_comp_count += 1
        comp_func_id = -1 # TODO

        name_node = Name(comp_func_name, comp_func_id, source_refs=ref)
        func_def_cast = FunctionDef(name=name_node, func_args=[], body=temp_cast+loop_cast+return_cast, source_refs=ref)
        
        self.generated_fns.append(func_def_cast)

        to_ret = [Call(func=Name(comp_func_name, comp_func_id, source_refs=ref),arguments=[],source_refs=ref)]

        return to_ret

    @visit.register
    def visit_If(
        self, node: ast.If, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST If node. Which is used to represent If statements.
        We visit each of the pieces accordingly and construct the CAST
        representation. else/elif statements are stored in the &#39;orelse&#39; field,
        if there are any.

        Args:
            node (ast.If): A PyAST If node.

        Returns:
            ModelIf: A CAST If statement node.
        &#34;&#34;&#34;

        # node_test = self.visit(
        #     node.test, prev_scope_id_dict, curr_scope_id_dict
        # )
        node_test = self.create_cond(
            node, prev_scope_id_dict, curr_scope_id_dict
        )

        node_body = []
        if len(node.body) &gt; 0:
            for piece in node.body:
                node_body.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )

        node_orelse = []
        if len(node.orelse) &gt; 0:
            for piece in node.orelse:
                node_orelse.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]


        if isinstance(node_test, list):
            return [ModelIf(node_test[0], node_body, node_orelse, source_refs=ref)]
        else:
            return [ModelIf(node_test, node_body, node_orelse, source_refs=ref)]

    @visit.register
    def visit_Global(
        self,
        node: ast.Global,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Global node.
        What this does is write in the IDs for variables that are
        explicitly declared as global within a scope using the global keyword
        as follows
        global x [, y, z, etc..]

        Args:
            node (ast.Global): A PyAST Global node
            prev_scope_id_dict (Dict): Dictionary containing the scope&#39;s current variable : ID maps

        Returns:
            List: empty list
        &#34;&#34;&#34;

        for v in node.names:
            unique_name = construct_unique_name(self.filenames[-1], v)
            curr_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]
        return []

    @visit.register
    def visit_IfExp(
        self,
        node: ast.IfExp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST IfExp node, which is Python&#39;s ternary operator.
        The node gets translated into a CAST ModelIf node by visiting all its parts,
        since IfExp behaves like an If statement.

        # TODO: Rethink how this is done to better reflect
         - ternary for assignments
         - ternary in function call arguments

        # NOTE: Do we want to treat this as a conditional block in GroMEt? But it shouldn&#39;t show up in the expression tree

        Args:
            node (ast.IfExp): [description]
        &#34;&#34;&#34;

        node_test = self.visit(
            node.test, prev_scope_id_dict, curr_scope_id_dict
        )
        node_body = self.visit(
            node.body, prev_scope_id_dict, curr_scope_id_dict
        )
        node_orelse = self.visit(
            node.orelse, prev_scope_id_dict, curr_scope_id_dict
        )
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        return [ModelIf(node_test[0], node_body, node_orelse, source_refs=ref)]

    @visit.register
    def visit_Import(
        self,
        node: ast.Import,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Import node, which is used for importing libraries
        that are used in programs. In particular, it&#39;s imports in the form of
        &#39;import X&#39;, where X is some library.

        Args:
            node (ast.Import): A PyAST Import node

        Returns:
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        names = node.names
        to_ret = []
        for alias in names:
            as_name = alias.asname
            orig_name = alias.name

            # Construct the path of the module, relative to where we are at
            # TODO: (Still have to handle things like &#39;..&#39;)
            name = alias.name

            # module1.x, module2.x
            # {module1: {x: 1}, module2: {x: 4}}

            # For cases like &#39;import module as something_else&#39;
            # We note the alias that the import uses for this module
            # Qualify names
            if as_name is not None:
                self.aliases[as_name] = orig_name
                name = alias.asname

            # TODO: Could use a flag to mark a Module as an import (old)
            if orig_name in BUILTINS or find_std_lib_module(orig_name):
                self.insert_next_id(self.global_identifier_dict, name)
                to_ret.append(
                    ModelImport(
                        name=orig_name,
                        alias=as_name,
                        symbol=None,
                        all=False,
                        source_refs=ref,
                    )
                )
        return to_ret

    @visit.register
    def visit_ImportFrom(
        self,
        node: ast.ImportFrom,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST ImportFrom node, which is used for importing libraries
        that are used in programs. In particular, it&#39;s imports in the form of
        &#39;import X&#39;, where X is some library.

        Args:
            node (ast.Import): A PyAST Import node

        Returns:
        &#34;&#34;&#34;

        # Construct the path of the module, relative to where we are at
        # (TODO: Still have to handle things like &#39;..&#39;)
        # TODO: What about importing individual functions from a module M
        #        that call other functions from that same module M
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        name = node.module
        if name in self.aliases:
            name = self.aliases[name]

        aliases = node.names
        to_ret = []
        for (
            alias
        ) in (
            aliases
        ):  # Iterate through the symbols that are being imported and create individual imports for each
            if alias.asname is not None:
                self.aliases[alias.asname] = alias.name

            if name in BUILTINS or find_std_lib_module(name):
                if alias.name == &#34;*&#34;:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=None,
                            all=True,
                            source_refs=ref,
                        )
                    )
                else:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=alias.name,
                            all=False,
                            source_refs=ref,
                        )
                    )
            else:  # User defined module import
                if alias.name == &#34;*&#34;:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=None,
                            all=True,
                            source_refs=ref,
                        )
                    )
                else:
                    to_ret.append(
                        ModelImport(
                            name=name,
                            alias=None,
                            symbol=alias.name,
                            all=False,
                            source_refs=ref,
                        )
                    )

        return to_ret

    @visit.register
    def visit_List(
        self,
        node: ast.List,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST List node. Which is used to represent Python lists.

        Args:
            node (ast.List): A PyAST List node.

        Returns:
            List: A CAST List node.
        &#34;&#34;&#34;

        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        # TODO: How to handle constructors with variables?
        if len(node.elts) &gt; 0:
            to_ret = []
            for piece in node.elts:
                to_ret.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )
            # TODO: How to represent computations like &#39;[0.0] * 1000&#39; in some kind of type constructing system
            # and then how could we store that in these LiteralValue nodes?
            return [
                LiteralValue(
                    StructureType.LIST, to_ret, source_code_data_type, ref
                )
            ]
            # return [List(to_ret,source_refs=ref)]
        else:
            return [
                LiteralValue(
                    StructureType.LIST, [], source_code_data_type, ref
                )
            ]
            # return [List([],source_refs=ref)]

    @visit.register
    def visit_Module(
        self,
        node: ast.Module,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Module node. This is the starting point of CAST Generation,
        as the body of the Module node (usually) contains the entire Python
        program.

        Args:
            node (ast.Module): A PyAST Module node.

        Returns:
            Module: A CAST Module node.
        &#34;&#34;&#34;

        # Visit all the nodes and make a Module object out of them
        body = []
        funcs = []
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=-1,
                col_end=-1,
                row_start=-1,
                row_end=-1,
            )
        ]
        self.module_stack.append(node)
        
        # Attempt to capture all global variable names
        # before we do any function definitions
        # (functions can use global variables so they need them all available)
        for line in node.body:
            if isinstance(line, ast.Assign):
                names = get_node_name(line)

                for var_name in names:
                    unique_name = construct_unique_name(
                        self.filenames[-1], var_name
                    )
                    self.insert_next_id(self.global_identifier_dict, unique_name)
        
        merge_dicts(self.global_identifier_dict, curr_scope_id_dict)
        merge_dicts(curr_scope_id_dict, prev_scope_id_dict)
        for piece in node.body:
            # Defer visiting function defs until all global vars are processed
            if isinstance(piece, ast.FunctionDef):
                unique_name = construct_unique_name(
                    self.filenames[-1], piece.name
                )
                self.insert_next_id(curr_scope_id_dict, unique_name)
                prev_scope_id_dict[unique_name] = curr_scope_id_dict[
                    unique_name
                ]
                #funcs.append(piece)
                #continue

            to_add = self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)

            # Global variables (which come about from assignments at the module level)
            # need to have their identifier names set correctly so they can be
            # accessed appropriately later on
            # We check if we just visited an assign and fix its key/value pair in the dictionary
            # So instead of
            #   &#34;var_name&#34; -&gt; ID
            # It becomes
            #   &#34;module_name.var_name&#34; -&gt; ID
            # in the dictionary
            # If an assign happens at the global level, then we must also make sure to
            # Update the global dictionary at this time so that the IDs are defined
            # and are correct
            if isinstance(piece, ast.Assign):
                names = get_node_name(to_add[0])

                for var_name in names:
                    #temp_id = curr_scope_id_dict[var_name]
                    del curr_scope_id_dict[var_name]
                    #unique_name = construct_unique_name(
                    #    self.filenames[-1], var_name
                    #)
                    #curr_scope_id_dict[unique_name] = temp_id
                    #merge_dicts(
                    #    curr_scope_id_dict, self.global_identifier_dict
                    #)

            if isinstance(to_add, Module):
                body.extend([to_add])
            else:
                body.extend(to_add)

        #merge_dicts(curr_scope_id_dict, self.global_identifier_dict)
        #merge_dicts(prev_scope_id_dict, curr_scope_id_dict)

        # Visit all the functions
        #for piece in funcs:
         #   to_add = self.visit(piece, curr_scope_id_dict, {})
          #  body.extend(to_add)

        self.module_stack.pop()
        return Module(
            name=self.filenames[-1].split(&#34;.&#34;)[0], body=self.generated_fns+body, source_refs=ref
        )

    @visit.register
    def visit_Name(
        self,
        node: ast.Name,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;This visits PyAST Name nodes, which consist of
           id: The name of a variable as a string
           ctx: The context in which the variable is being used

        Args:
            node (ast.Name): A PyAST Name node

        Returns:
            Expr: A CAST Expression node

        &#34;&#34;&#34;
        # TODO: Typing so it&#39;s not hardcoded to floats
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        if isinstance(node.ctx, ast.Load):
            if node.id in self.aliases:
                return [Name(self.aliases[node.id], id=-1, source_refs=ref)]

            if node.id not in curr_scope_id_dict:
                if node.id in prev_scope_id_dict:
                    curr_scope_id_dict[node.id] = prev_scope_id_dict[node.id]
                else:
                    unique_name = construct_unique_name(
                        self.filenames[-1], node.id
                    )

                    # We can have the very odd case where a variable is used in a function before
                    # it even exists. To my knowledge this happens in one scenario:
                    # - A global variable, call it z, is used in a function
                    # - Before that function is called in Python code, that global variable
                    #   z is set by another module/another piece of code as a global
                    #   (i.e. by doing module_name.z = a value)
                    # It&#39;s not something that is very common (or good) to do, but regardless
                    # we&#39;ll catch it here just in case.
                    if unique_name not in self.global_identifier_dict.keys():
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    curr_scope_id_dict[node.id] = self.global_identifier_dict[
                        unique_name
                    ]

            return [
                Name(node.id, id=curr_scope_id_dict[node.id], source_refs=ref)
            ]

        if isinstance(node.ctx, ast.Store):
            if node.id in self.aliases:
                return [
                    Var(
                        Name(self.aliases[node.id], id=-1, source_refs=ref),
                        &#34;float&#34;,
                        source_refs=ref,
                    )
                ]

            if node.id not in curr_scope_id_dict:
                # We construct the unique name for the case that
                # An assignment to a global happens in the global scope
                # (i.e. a loop at the global level)
                # Check if it&#39;s in the previous scope not as a global (general case when in a function)
                # then check if it&#39;s in the previous scope as a global (when we&#39;re at the global scope)
                unique_name = construct_unique_name(
                    self.filenames[-1], node.id
                )
                if node.id in prev_scope_id_dict:
                    curr_scope_id_dict[node.id] = prev_scope_id_dict[node.id]
                elif unique_name in prev_scope_id_dict:
                    curr_scope_id_dict[node.id] = prev_scope_id_dict[
                        unique_name
                    ]
                else:
                    self.insert_next_id(curr_scope_id_dict, node.id)

            return [
                Var(
                    Name(
                        node.id,
                        id=curr_scope_id_dict[node.id],
                        source_refs=ref,
                    ),
                    &#34;float&#34;,
                    source_refs=ref,
                )
            ]

        if isinstance(node.ctx, ast.Del):
            # TODO: At some point..
            raise NotImplementedError()

    @visit.register
    def visit_Pass(
        self,
        node: ast.Pass,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;A PyAST Pass visitor, for essentially NOPs.&#34;&#34;&#34;
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Raise(
        self,
        node: ast.Raise,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;A PyAST Raise visitor, for Raising exceptions

        TODO: To be implemented.
        &#34;&#34;&#34;
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        exc_name = &#34;&#34;
        if isinstance(node.exc, ast.Name):
            exc_name = node.exc.id
        elif isinstance(node.exc, ast.Call):
            if isinstance(node.exc.func, ast.Name):
                exc_name = node.exc.func.id

        raise_id = -1
        if &#34;raise&#34; not in self.global_identifier_dict.keys():
            raise_id = self.insert_next_id(
                self.global_identifier_dict, &#34;raise&#34;
            )
        else:
            raise_id = self.global_identifier_dict[&#34;raise&#34;]

        return [
            Call(
                func=Name(&#34;raise&#34;, raise_id, source_refs=ref),
                arguments=[
                    LiteralValue(
                        StructureType.LIST,
                        exc_name,
                        source_code_data_type,
                        ref,
                    )
                ],
                source_refs=ref,
            )
        ]

    @visit.register
    def visit_Return(
        self,
        node: ast.Return,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Return node and creates a CAST return node
           that has one field, which is the expression computing the value
           to be returned. The PyAST&#39;s value node is visited.
           The CAST node is then returned.

        Args:
            node (ast.Return): A PyAST Return node

        Returns:
            ModelReturn: A CAST Return node
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        if node.value != None:
            return [
                ModelReturn(
                    self.visit(
                        node.value, prev_scope_id_dict, curr_scope_id_dict
                    )[0],
                    source_refs=ref,
                )
            ]
        else:
            source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(node.value))]
            val = LiteralValue(None, None, source_code_data_type, ref)
            return [ModelReturn(val, source_refs=ref)]

    @visit.register
    def visit_UnaryOp(
        self,
        node: ast.UnaryOp,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST UnaryOp node. Which represents Python unary operations.
        A dictionary is used to index into which operation we&#39;re doing.

        Args:
            node (ast.UnaryOp): A PyAST UnaryOp node.

        Returns:
            UnaryOp: A CAST UnaryOp node.
        &#34;&#34;&#34;

        op = get_op(node.op)
        operand = node.operand

        opd = self.visit(operand, prev_scope_id_dict, curr_scope_id_dict)

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        return [Operator(source_language=&#34;Python&#34;, 
                interpreter=&#34;Python&#34;, 
                version=get_python_version(), 
                op=op, 
                operands=[opd[0]], 
                source_refs=ref)]

    @visit.register
    def visit_Set(
        self, node: ast.Set, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST Set node. Which is used to represent Python sets.

        Args:
            node (ast.Set): A PyAST Set node.

        Returns:
            Set: A CAST Set node.
        &#34;&#34;&#34;

        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        if len(node.elts) &gt; 0:
            to_ret = []
            for piece in node.elts:
                to_ret.extend(
                    self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
                )
            return [
                LiteralValue(
                    StructureType.SET, to_ret, source_code_data_type, ref
                )
            ]
        else:
            return [
                LiteralValue(
                    StructureType.SET, to_ret, source_code_data_type, ref
                )
            ]

    @visit.register
    def visit_Subscript(
        self,
        node: ast.Subscript,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Subscript node, which represents subscripting into
        a list in Python. A Subscript is either a Slice (i.e. x[0:2]), an
        Extended slice (i.e. x[0:2, 3]), or a constant (i.e. x[3]).
        In the Slice case, a loop is generated that fetches the correct elements and puts them
        into a list.
        In the Extended slice case, nested loops are generated as needed to create a final
        result list with the selected elements.
        In the constant case, we can visit and generate a CAST Subscript in a normal way.

        Args:
            node (ast.Subscript): A PyAST Subscript node

        Returns:
            Subscript: A CAST Subscript node
        &#34;&#34;&#34;

        # value = self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)[0]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # &#39;Visit&#39; the slice
        slc = node.slice
        temp_var = f&#34;generated_index_{self.var_count}&#34;
        self.var_count += 1

        if isinstance(slc, ast.Slice):
            if slc.lower is not None:
                start = self.visit(
                    slc.lower, prev_scope_id_dict, curr_scope_id_dict
                )[0]
            else:
                start = LiteralValue(
                    value_type=ScalarType.INTEGER,
                    value=0,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                    source_refs=ref,
                )

            if slc.upper is not None:
                stop = self.visit(
                    slc.upper, prev_scope_id_dict, curr_scope_id_dict
                )[0]
            else:
                if isinstance(node.value, ast.Call):
                    if isinstance(node.value.func, ast.Attribute):
                        stop = Call(
                            func=Name(&#34;len&#34;, source_refs=ref),
                            arguments=[Name(node.value.func.attr, source_refs=ref)],
                            source_refs=ref,
                        )
                    else:
                        stop = Call(
                            func=Name(&#34;len&#34;, source_refs=ref),
                            arguments=[Name(node.value.func.id, source_refs=ref)],
                            source_refs=ref,
                        )
                elif isinstance(node.value, ast.Attribute):
                    stop = Call(
                        func=Name(&#34;len&#34;, source_refs=ref),
                        arguments=[Name(node.value.attr, source_refs=ref)],
                        source_refs=ref,
                    )
                else:
                    if isinstance(node.value, ast.Subscript):
                        id = self.visit(
                            node.value, prev_scope_id_dict, curr_scope_id_dict
                        )
                    else:
                        id = node.value.id
                    stop = Call(
                        func=Name(&#34;len&#34;, source_refs=ref),
                        arguments=[Name(id, source_refs=ref)],
                        source_refs=ref,
                    )

            if slc.step is not None:
                step = self.visit(
                    slc.step, prev_scope_id_dict, curr_scope_id_dict
                )[0]
            else:
                step = LiteralValue(
                    value_type=ScalarType.INTEGER,
                    value=1,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                    source_refs=ref,
                )

            unique_name = construct_unique_name(self.filenames[-1], &#34;slice&#34;)
            if unique_name not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]

            slice_call = Call(
                func=Name(
                    &#34;slice&#34;,
                    id=prev_scope_id_dict[unique_name],
                    source_refs=ref,
                ),
                arguments=[start, stop, step],
                source_refs=ref,
            )

            val = self.visit(
                node.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]

            unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
            if unique_name not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]
            # return[Call(Name(&#34;Concatenate&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref), str_pieces, source_refs=ref)]

            get_call = Call(
                func=Name(
                    &#34;_get&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref
                ),
                arguments=[val, slice_call],
                source_refs=ref,
            )

            return [get_call]
        elif isinstance(slc, ast.Index):

            val = self.visit(
                node.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            slice_val = self.visit(
                slc.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
            if unique_name not in prev_scope_id_dict.keys():
                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                    unique_name
                ]
            get_call = Call(
                func=Name(
                    &#34;_get&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref
                ),
                arguments=[val, slice_val],
                source_refs=ref,
            )
            return [get_call]
        elif isinstance(slc, ast.ExtSlice):
            dims = slc.dims
            result = []
            source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
            ref = [
                SourceRef(
                    source_file_name=self.filenames[-1],
                    col_start=node.col_offset,
                    col_end=node.end_col_offset,
                    row_start=node.lineno,
                    row_end=node.end_lineno,
                )
            ]
            return [
                LiteralValue(
                    StructureType.LIST,
                    &#34;NotImplemented&#34;,
                    source_code_data_type,
                    ref,
                )
            ]

        # else:
        #   sl = self.visit(slc, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Index(
        self,
        node: ast.Index,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Index node, which represents the value being used
        for an index. This visitor doesn&#39;t create its own CAST node, but
        returns CAST depending on the value that the Index node holds.

        Args:
            node (ast.Index): A CAST Index node.

        Returns:
            AstNode: Depending on what the value of the Index node is,
                     different CAST nodes are returned.
        &#34;&#34;&#34;

        return self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)

    @visit.register
    def visit_Tuple(
        self,
        node: ast.Tuple,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST Tuple node. Which is used to represent Python tuple.

        Args:
            node (ast.Tuple): A PyAST Tuple node.

        Returns:
            Set: A CAST Tuple node.
        &#34;&#34;&#34;

        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        # if len(node.elts) &gt; 0:
        to_ret = []
        for piece in node.elts:
            to_ret.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
        return [LiteralValue(StructureType.TUPLE, to_ret, source_code_data_type, source_refs=ref)]

    @visit.register
    def visit_Try(
        self, node: ast.Try, prev_scope_id_dict, curr_scope_id_dict
    ):
        &#34;&#34;&#34;Visits a PyAST Try node, which represents Try/Except blocks.
        These are used for Python&#39;s exception handling

        Currently, the visitor just bypasses the Try/Except feature and just
        generates CAST for the body of the &#39;Try&#39; block, assuming the exception(s)
        are never thrown.
        &#34;&#34;&#34;

        body = []
        for piece in node.body:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        for piece in node.orelse:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        for piece in node.finalbody:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )

        return body

    @visit.register
    def visit_Yield(
        self,
        node: ast.Yield,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_Assert(
        self,
        node: ast.Assert,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    @visit.register
    def visit_While(
        self,
        node: ast.While,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST While node, which represents a while loop.

        Args:
            node (ast.While): a PyAST while node

        Returns:
            Loop: A CAST loop node, which generically represents both For
                  loops and While loops.
        &#34;&#34;&#34;
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]

        # test_cond = self.visit(node.test, prev_scope_id_dict, curr_scope_id_dict)[0]
        test = self.create_cond(node, prev_scope_id_dict, curr_scope_id_dict)

        # Loops have their own enclosing scopes
        curr_scope_copy = copy.deepcopy(curr_scope_id_dict)
        merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
        loop_body_scope = {}
        body = []
        for piece in node.body + node.orelse:
            to_add = self.visit(piece, curr_scope_id_dict, loop_body_scope)
            body.extend(to_add)

        curr_scope_id_dict = copy.deepcopy(curr_scope_copy)

        # loop_body_fn_def = FunctionDef(name=&#34;while_temp&#34;, func_args=None, body=body)
        # return [Loop(init=[], expr=test, body=loop_body_fn_def, source_refs=ref)]
        if isinstance(test, list):
            return [Loop(pre=[], expr=test[0], body=body, post=[], source_refs=ref)]
        else:
            return [Loop(pre=[], expr=test, body=body, post=[], source_refs=ref)]

    @visit.register
    def visit_With(
        self,
        node: ast.With,
        prev_scope_id_dict,
        curr_scope_id_dict,
    ):
        &#34;&#34;&#34;Visits a PyAST With node. With nodes are used as follows:
        with a as b, c as d:
            do things with b and d
        To use aliases on variables and operate on them
        This visitor unrolls the With block and generates the appropriate cast for the
        underlying operations

        Args:
            node (ast.With): a PyAST with node

        Args:
            [AstNode]: A list of CAST nodes, representing whatever operations were happening in the With
                       block before they got unrolled

        &#34;&#34;&#34;

        ref = None
        variables = []
        for item in node.items:
            ref = [
                SourceRef(
                    source_file_name=self.filenames[-1],
                    col_start=node.col_offset,
                    col_end=node.end_col_offset,
                    row_start=node.lineno,
                    row_end=node.end_lineno,
                )
            ]
            if item.optional_vars != None:
                l = self.visit(
                    item.optional_vars, prev_scope_id_dict, curr_scope_id_dict
                )
                r = self.visit(
                    item.context_expr, prev_scope_id_dict, curr_scope_id_dict
                )
                variables.extend(
                    [Assignment(left=l[0], right=r[0], source_refs=ref)]
                )
            else:
                variables.extend(
                    [
                        self.visit(
                            item.context_expr,
                            prev_scope_id_dict,
                            curr_scope_id_dict,
                        )[0]
                    ]
                )

        body = []
        for piece in node.body:
            body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )

        return variables + body</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.check_alias"><code class="name flex">
<span>def <span class="ident">check_alias</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a python string that represents a name,
this function checks to see if that name is an alias
for a different name, and returns it if it is indeed an alias.
Otherwise, the original name is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_alias(self, name):
    &#34;&#34;&#34;Given a python string that represents a name,
    this function checks to see if that name is an alias
    for a different name, and returns it if it is indeed an alias.
    Otherwise, the original name is returned.
    &#34;&#34;&#34;
    if name in self.aliases:
        return self.aliases[name]
    else:
        return name</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.collect_fields"><code class="name flex">
<span>def <span class="ident">collect_fields</span></span>(<span>self, node:_ast.FunctionDef, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to solve the problem of collecting any additional fields
for a class that get created in functions outside of <strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_fields(
    self, node: ast.FunctionDef, prev_scope_id_dict, curr_scope_id_dict
):
    &#34;&#34;&#34;Attempts to solve the problem of collecting any additional fields
    for a class that get created in functions outside of __init__
    &#34;&#34;&#34;
    fields = []
    for n in node.body:
        if isinstance(n, ast.Assign) and isinstance(
            n.targets[0], ast.Attribute
        ):
            attr_node = n.targets[0]
            if isinstance(attr_node.value, ast.Attribute):
                if attr_node.value.value == &#34;self&#34;:
                    ref = [
                        SourceRef(
                            source_file_name=self.filenames[-1],
                            col_start=attr_node.col_offset,
                            col_end=attr_node.end_col_offset,
                            row_start=attr_node.lineno,
                            row_end=attr_node.end_lineno,
                        )
                    ]
                    # Need IDs for name, which one?
                    attr_id = self.insert_next_id(
                        curr_scope_id_dict, attr_node.value.attr
                    )
                    fields.append(
                        Var(
                            Name(
                                attr_node.value.attr,
                                id=attr_id,
                                source_refs=ref,
                            ),
                            &#34;float&#34;,
                            source_refs=ref,
                        )
                    )
            elif attr_node.value.id == &#34;self&#34;:
                ref = [
                    SourceRef(
                        source_file_name=self.filenames[-1],
                        col_start=attr_node.col_offset,
                        col_end=attr_node.end_col_offset,
                        row_start=attr_node.lineno,
                        row_end=attr_node.end_lineno,
                    )
                ]
                # Need IDs for name, which one?
                attr_id = self.insert_next_id(
                    curr_scope_id_dict, attr_node.attr
                )
                fields.append(
                    Var(
                        Name(attr_node.attr, id=attr_id, source_refs=ref),
                        &#34;float&#34;,
                        source_refs=ref,
                    )
                )

    return fields</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.create_binary_compare_tree"><code class="name flex">
<span>def <span class="ident">create_binary_compare_tree</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_binary_compare_tree(self, node):
    if isinstance(node, (ast.Compare, ast.UnaryOp, ast.Call, ast.Name, ast.Attribute, ast.Constant, ast.Subscript)):
        return node
    # elif isinstance(node, ast.UnaryOp):
    #    return node
    #elif isinstance(node, ast.Call):
     #   return node
    elif isinstance(node, ast.BoolOp):
        # &gt; 2 values implies nested &#39;and&#39; or &#39;or&#39;
        if len(node.values) &gt; 2:
            op = [node.op]
            # left_most = self.create_binary_compare_tree(node.values[0])
            # Build binary trees of ast.Compare nodes their children being 
            # the original leaves
            # In other words decompress the tree so it&#39;s binary instead of n-ary

            idx = len(node.values) - 1
            tree_root = None
            while idx &gt;= 0:
                if tree_root == None:        
                    left_child = self.create_binary_compare_tree(node.values[idx - 1]) 
                    right_child = self.create_binary_compare_tree(node.values[idx]) 

                    compare_op = ast.Compare(
                        left=left_child,
                        ops=op,
                        comparators=[right_child],
                        col_offset=node.col_offset,
                        end_col_offset=node.end_col_offset,
                        lineno=node.lineno,
                        end_lineno=node.end_lineno,
                    )

                    tree_root = compare_op
                    idx = idx - 2
                else:
                    left_child = self.create_binary_compare_tree(node.values[idx])

                    compare_op = ast.Compare(
                        left=left_child,
                        ops=op,
                        comparators=[tree_root],
                        col_offset=node.col_offset,
                        end_col_offset=node.end_col_offset,
                        lineno=node.lineno,
                        end_lineno=node.end_lineno,
                    )

                    tree_root = compare_op
                    idx = idx - 1

            return tree_root
        else:
            op = [node.op]

            left_child = self.create_binary_compare_tree(node.values[0])
            right_child = self.create_binary_compare_tree(node.values[1])
            compare_op = ast.Compare(
                left=left_child,
                ops=op,
                comparators=[right_child],
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            )
            
            return compare_op
    print(f&#34;catch type {type(node)}&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.create_cond"><code class="name flex">
<span>def <span class="ident">create_cond</span></span>(<span>self, node, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Used in while and if statement creation.
This function determines what kind of conditional we have for an if statement or a while loop
Either the conditional explicitly checks a value using a comparison operator or it doesnt
In the case that it doesn't explicitly then we have to add in an explicit check</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cond(self, node, prev_scope_id_dict, curr_scope_id_dict):
    &#34;&#34;&#34;Used in while and if statement creation.
    This function determines what kind of conditional we have for an if statement or a while loop
    Either the conditional explicitly checks a value using a comparison operator or it doesnt
    In the case that it doesn&#39;t explicitly then we have to add in an explicit check
    &#34;&#34;&#34;
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    test_cond = self.visit(
        node.test, prev_scope_id_dict, curr_scope_id_dict
    )[0]
    bool_func = &#34;bool&#34;
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(True))]
    true_val = LiteralValue(
        ScalarType.BOOLEAN,
        &#34;True&#34;,
        source_code_data_type=source_code_data_type,
        source_refs=ref,
    )
    if isinstance(node.test, (ast.Name, ast.Constant)):
        if bool_func not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if bool_func not in self.global_identifier_dict.keys():
                self.insert_next_id(self.global_identifier_dict, bool_func)

            prev_scope_id_dict[bool_func] = self.global_identifier_dict[
                bool_func
            ]
        bool_call = Call(
            func=Name(
                &#34;bool&#34;, id=prev_scope_id_dict[bool_func], source_refs=ref
            ),
            arguments=[test_cond],
            source_refs=ref,
        )
        test = [Operator(source_language=&#34;Python&#34;, 
                    interpreter=&#34;Python&#34;, 
                    version=get_python_version(), 
                    op=&#34;ast.Eq&#34;, 
                    operands=[bool_call,true_val], 
                    source_refs=ref)]

    elif isinstance(node.test, ast.UnaryOp) and isinstance(
        node.test.operand, (ast.Name, ast.Constant, ast.Call)
    ):
        if bool_func not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if bool_func not in self.global_identifier_dict.keys():
                self.insert_next_id(self.global_identifier_dict, bool_func)

            prev_scope_id_dict[bool_func] = self.global_identifier_dict[
                bool_func
            ]
        bool_call = Call(
            func=Name(
                &#34;bool&#34;, id=prev_scope_id_dict[bool_func], source_refs=ref
            ),
            arguments=[test_cond],
            source_refs=ref,
        )
        test = [Operator(source_language=&#34;Python&#34;, 
                    interpreter=&#34;Python&#34;, 
                    version=get_python_version(), 
                    op=&#34;ast.Eq&#34;, 
                    operands=[bool_call,true_val], 
                    source_refs=ref)]

    else:
        test = test_cond

    return test</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.find_function"><code class="name flex">
<span>def <span class="ident">find_function</span></span>(<span>module_node:_ast.Module, f_name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a PyAST Module node, we search for a particular FunctionDef node
which is given to us by its function name f_name.</p>
<p>This function searches at the top level, that is it only searches FunctionDefs that
exist at the module level, and will not search deeper for functions within functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_function(module_node: ast.Module, f_name: str):
    &#34;&#34;&#34;Given a PyAST Module node, we search for a particular FunctionDef node
    which is given to us by its function name f_name.

    This function searches at the top level, that is it only searches FunctionDefs that
    exist at the module level, and will not search deeper for functions within functions.
    &#34;&#34;&#34;
    for stmt in module_node.body:
        if isinstance(stmt, ast.FunctionDef) and stmt.name == f_name:
            return stmt

    return None</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.identify_piece"><code class="name flex">
<span>def <span class="ident">identify_piece</span></span>(<span>self, piece:<a title="skema.program_analysis.CAST2FN.model.cast.ast_node.AstNode" href="../../CAST2FN/model/cast/ast_node.html#skema.program_analysis.CAST2FN.model.cast.ast_node.AstNode">AstNode</a>, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to 'centralize' the handling of different node types
in list/dictionary/set comprehensions.
Take the following list comprehensions as examples
L = [ele<strong>2 for small_l in d
for ele in small_l]
&ndash; comp1
L = [ele</strong>2 for small_l in foo.bar() for ele in small_l]
&ndash; comp2
L = [ele**2 for small_l in foo.baz
for ele in small_l]
&ndash; comp3
F1
F2
F3
F4
F5</p>
<p>In these comprehensions F3 has a different type for its node
- In comp1 it's a list
- In comp2 it's an attribute of an object with a function call
- In comp3 it's an attribute of an object without a function call</p>
<p>The code that handles comprehensions generates slightly different AST depending
on what type these fields (F1 through F5) are, but this handling becomes very repetitive
and difficult to maintain if it's written in the comprehension visitors. Thus, this method
is to contain that handling in one place. This method acts on one field at a time, and thus will
be called multiple times per comprehension as necessary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>piece</code></strong> :&ensp;<code>AstNode</code></dt>
<dd>The current Python AST node we're looking at, generally an individual field
of the list comprehension</dd>
<dt><strong><code>prev_scope_id_dict</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Scope dictionaries in case something needs to be accessed or changed</dd>
<dt><strong><code>curr_scope_id_dict</code></strong> :&ensp;<code>Dict</code></dt>
<dd>see above</dd>
</dl>
<p>[ELT for TARGET in ITER]
F1
F2
F3
F1 - doesn't need to be handled here because that's just code that is done somewhere else
F2/F4 - commonly it's a Name or a Tuple node
F3/F5 - generally a list, or something that gives back a list like:
* a subscript
* an attribute of an object with or w/out a function call</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_piece(
    self,
    piece: AstNode,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;This function is used to &#39;centralize&#39; the handling of different node types
    in list/dictionary/set comprehensions.
    Take the following list comprehensions as examples
    L = [ele**2 for small_l in d         for ele in small_l]   -- comp1
    L = [ele**2 for small_l in foo.bar() for ele in small_l]   -- comp2
    L = [ele**2 for small_l in foo.baz   for ele in small_l]   -- comp3
           F1         F2        F3            F4      F5

    In these comprehensions F3 has a different type for its node
        - In comp1 it&#39;s a list
        - In comp2 it&#39;s an attribute of an object with a function call
        - In comp3 it&#39;s an attribute of an object without a function call

    The code that handles comprehensions generates slightly different AST depending
    on what type these fields (F1 through F5) are, but this handling becomes very repetitive
    and difficult to maintain if it&#39;s written in the comprehension visitors. Thus, this method
    is to contain that handling in one place. This method acts on one field at a time, and thus will
    be called multiple times per comprehension as necessary.

    Args:
        piece (AstNode): The current Python AST node we&#39;re looking at, generally an individual field
                         of the list comprehension
        prev_scope_id_dict (Dict): Scope dictionaries in case something needs to be accessed or changed
        curr_scope_id_dict (Dict): see above

    [ELT for TARGET in ITER]
      F1       F2      F3
    F1 - doesn&#39;t need to be handled here because that&#39;s just code that is done somewhere else
    F2/F4 - commonly it&#39;s a Name or a Tuple node
    F3/F5 - generally a list, or something that gives back a list like:
            * a subscript
            * an attribute of an object with or w/out a function call
    &#34;&#34;&#34;
    if isinstance(piece, ast.Tuple):  # for targets (generator.target)
        return piece
    elif isinstance(piece, ast.Name):
        ref = [
            self.filenames[-1],
            piece.col_offset,
            piece.end_col_offset,
            piece.lineno,
            piece.end_lineno,
        ]
        # return ast.Name(id=piece.id, ctx=ast.Store(), col_offset=None, end_col_offset=None, lineno=None, end_lineno=None)
        return ast.Name(
            id=piece.id,
            ctx=ast.Store(),
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )
    elif isinstance(piece, ast.Subscript):  # for iters (generator.iter)
        return piece.value
    elif isinstance(piece, ast.Call):
        return piece.func
    else:
        return piece</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.insert_alias"><code class="name flex">
<span>def <span class="ident">insert_alias</span></span>(<span>self, originString, alias)</span>
</code></dt>
<dd>
<div class="desc"><p>Inserts an alias into a dictionary that keeps track of aliases for
names that are aliased. For example, the following import
import numpy as np
np is an alias for the original name numpy</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>original</code></strong> :&ensp;<code>String</code></dt>
<dd>The original name that is being aliased</dd>
</dl>
<p>alias
(String): The alias of the original name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_alias(self, originString, alias):
    &#34;&#34;&#34;Inserts an alias into a dictionary that keeps track of aliases for
        names that are aliased. For example, the following import
        import numpy as np
        np is an alias for the original name numpy

    Args:
        original (String): The original name that is being aliased
        alias    (String): The alias of the original name
    &#34;&#34;&#34;
    # TODO
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.insert_next_id"><code class="name flex">
<span>def <span class="ident">insert_next_id</span></span>(<span>self, scope_dict:dict, dict_key:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a scope_dictionary and a variable name as a key,
we insert a new key_value pair for the scope dictionary
The ID that we inserted gets returned because some visitors
need the ID for some additional work. In the cases where the returned
ID isn't needed it gets ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scope_dict</code></strong> :&ensp;<code>Dict</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>dict_key</code></strong> :&ensp;<code>str</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_next_id(self, scope_dict: dict, dict_key: str):
    &#34;&#34;&#34;Given a scope_dictionary and a variable name as a key,
    we insert a new key_value pair for the scope dictionary
    The ID that we inserted gets returned because some visitors
    need the ID for some additional work. In the cases where the returned
    ID isn&#39;t needed it gets ignored.

    Args:
        scope_dict (Dict): _description_
        dict_key (str): _description_
    &#34;&#34;&#34;
    new_id_to_insert = self.id_count
    scope_dict[dict_key] = new_id_to_insert
    self.id_count += 1
    return new_id_to_insert</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node:<a title="skema.program_analysis.CAST2FN.model.cast.ast_node.AstNode" href="../../CAST2FN/model/cast/ast_node.html#skema.program_analysis.CAST2FN.model.cast.ast_node.AstNode">AstNode</a>, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatchmethod
def visit(
    self, node: AstNode, prev_scope_id_dict, curr_scope_id_dict
):
    # print(f&#34;Trying to visit a node of type {type(node)} but a visitor doesn&#39;t exist&#34;)
    # if(node != None):
    #    print(f&#34;This is at line {node.lineno}&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Assert"><code class="name flex">
<span>def <span class="ident">visit_Assert</span></span>(<span>self, node:_ast.Assert, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Assert(
    self,
    node: ast.Assert,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [
        LiteralValue(
            StructureType.LIST,
            &#34;NotImplemented&#34;,
            source_code_data_type,
            ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Assign"><code class="name flex">
<span>def <span class="ident">visit_Assign</span></span>(<span>self, node:_ast.Assign, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Assign node, and returns its CAST representation.
Either the assignment is simple, like x = {expression},
or the assignment is complex, like x = y = z = &hellip; {expression}
Which determines how we generate the CAST for this node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Assign</code></dt>
<dd>A PyAST Assignment node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Assignment</code></dt>
<dd>An assignment CAST node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Assign(
    self,
    node: ast.Assign,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Assign node, and returns its CAST representation.
    Either the assignment is simple, like x = {expression},
    or the assignment is complex, like x = y = z = ... {expression}
    Which determines how we generate the CAST for this node.

    Args:
        node (ast.Assign): A PyAST Assignment node.

    Returns:
        Assignment: An assignment CAST node
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    left = []
    right = []

    if len(node.targets) == 1:  
        # x = 1, or maybe x = y, in general x = {expression}
        if isinstance(node.targets[0], ast.Subscript):  
            # List subscript nodes get replaced out by
            # A function call to a &#34;list_set&#34;
            sub_node = node.targets[0]
            if isinstance(node.value, ast.Subscript):
                unique_name = construct_unique_name(
                    self.filenames[-1], &#34;_get&#34;
                )
                if unique_name not in prev_scope_id_dict.keys():
                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if (
                        unique_name
                        not in self.global_identifier_dict.keys()
                    ):
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]
                idx = self.visit(
                    node.value.slice,
                    prev_scope_id_dict,
                    curr_scope_id_dict,
                )[0]
                val = self.visit(
                    node.value.value,
                    prev_scope_id_dict,
                    curr_scope_id_dict,
                )[0]
                args = [val, idx]

                val = Call(
                    func=Name(
                        &#34;_get&#34;,
                        id=prev_scope_id_dict[unique_name],
                        source_refs=ref,
                    ),
                    arguments=args,
                    source_refs=ref,
                )
            else:
                val = self.visit(
                    node.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]

            idx = self.visit(
                sub_node.slice, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            list_name = self.visit(
                sub_node.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            # print(&#34;-------------&#34;)
            # print(type(node.value))
            # print(type(sub_node.slice))
            # print(type(sub_node.value))
            # print(&#34;-------------&#34;)

            # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
            # This should only be the case for built-in python functions (i.e print, len, etc...)
            # Otherwise it would be an error to call a function before it is defined
            # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
            unique_name = construct_unique_name(self.filenames[-1], &#34;_set&#34;)
            if unique_name not in prev_scope_id_dict.keys():

                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[
                    unique_name
                ] = self.global_identifier_dict[unique_name]

            args = [list_name, idx, val]
            return [
                Assignment(
                    Var(val=list_name, type=&#34;Any&#34;, source_refs=ref),
                    Call(
                        func=Name(
                            &#34;_set&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    ),
                    source_refs=ref,
                )
            ]

        if isinstance(node.value, ast.Subscript):

            # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
            # This should only be the case for built-in python functions (i.e print, len, etc...)
            # Otherwise it would be an error to call a function before it is defined
            # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
            unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
            if unique_name not in prev_scope_id_dict.keys():

                # If a built-in is called, then it gets added to the global dictionary if
                # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                # function
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                prev_scope_id_dict[
                    unique_name
                ] = self.global_identifier_dict[unique_name]

            var_name = self.visit(
                node.targets[0], prev_scope_id_dict, curr_scope_id_dict
            )[0]
            idx = self.visit(
                node.value.slice, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            val = self.visit(
                node.value.value, prev_scope_id_dict, curr_scope_id_dict
            )[0]
            args = [val, idx]
            return [
                Assignment(
                    var_name,
                    Call(
                        func=Name(
                            &#34;_get&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    ),
                    source_refs=ref,
                )
            ]

        if isinstance(node.value, ast.BinOp):  # Checking if we have an assignment of the form
            # x = LIST * NUM or x = NUM * LIST
            binop = node.value
            list_node = None
            operand = None
            if isinstance(binop.left, ast.List):
                list_node = binop.left
                operand = binop.right
            elif isinstance(binop.right, ast.List):
                list_node = binop.right
                operand = binop.left

            if list_node is not None:
                cons = ValueConstructor()
                lit_type = (
                    ScalarType.ABSTRACTFLOAT
                    if type(list_node.elts[0].value) == float
                    else ScalarType.INTEGER
                )
                cons.dim = None
                t = get_op(binop.op)
                cons.operator = (
                    &#34;*&#34;
                    if get_op(binop.op) == &#34;Mult&#34;
                    else &#34;+&#34;
                    if get_op(binop.op) == &#34;Add&#34;
                    else None
                )
                cons.size = self.visit(
                    operand, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                cons.initial_value = LiteralValue(
                    value_type=lit_type,
                    value=list_node.elts[0].value,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                    source_refs=ref,
                )

                # TODO: Source code data type metadata
                to_ret = LiteralValue(
                    value_type=&#34;List[Any]&#34;,
                    value=cons,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                    source_refs=ref,
                )
                unique_name = construct_unique_name(
                    self.filenames[-1], &#34;_get&#34;
                )
                if unique_name not in prev_scope_id_dict.keys():

                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if (
                        unique_name
                        not in self.global_identifier_dict.keys()
                    ):
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]

                # TODO: Augment this _List_num constructor with the following
                # First argument should be a list with the initial amount of elements
                # Then second arg is how many times to repeat that
                # When we say List for the first argument: It should be a literal value List that holds the elements
                to_ret = Call(
                    func=Name(
                        &#34;_List_num&#34;,
                        id=prev_scope_id_dict[unique_name],
                        source_refs=ref,
                    ),
                    arguments=[cons.initial_value, cons.size],
                    source_refs=ref,
                )

                # print(to_ret)
                l_visit = self.visit(
                    node.targets[0], prev_scope_id_dict, curr_scope_id_dict
                )
                left.extend(l_visit)
                return [Assignment(left[0], to_ret, source_refs=ref)]

        l_visit = self.visit(
            node.targets[0], prev_scope_id_dict, curr_scope_id_dict
        )
        r_visit = self.visit(
            node.value, prev_scope_id_dict, curr_scope_id_dict
        )
        left.extend(l_visit)
        right.extend(r_visit)
    elif len(node.targets) &gt; 1:
        # x = y = z = ... {Expression} (multiple assignments in one line)
        left.extend(
            self.visit(
                node.targets[0], prev_scope_id_dict, curr_scope_id_dict
            )
        )
        node.targets = node.targets[1:]
        right.extend(
            self.visit(node, prev_scope_id_dict, curr_scope_id_dict)
        )
    else:
        raise ValueError(
            f&#34;Unexpected number of targets for node: {len(node.targets)}&#34;
        )

    # ref = [SourceRef(source_file_name=self.filenames[-1], col_start=node.col_offset, col_end=node.end_col_offset, row_start=node.lineno, row_end=node.end_lineno)]

    return [Assignment(left[0], right[0], source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node:_ast.Attribute, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Attribute node, which is used when accessing
the attribute of a class. Whether it's a field or method of a class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Attribute</code></dt>
<dd>A PyAST Attribute node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Attribute</code></dt>
<dd>A CAST Attribute node representing an Attribute access</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Attribute(
    self,
    node: ast.Attribute,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Attribute node, which is used when accessing
    the attribute of a class. Whether it&#39;s a field or method of a class.

    Args:
        node (ast.Attribute): A PyAST Attribute node

    Returns:
        Attribute: A CAST Attribute node representing an Attribute access
    &#34;&#34;&#34;
    # node.value and node.attr
    # node.value is some kind of AST node
    # node.attr is a string (or perhaps name)

    # node.value.id gets us module name (string)
    # node.attr gets us attribute we&#39;re accessing (string)
    # helper(node.attr) -&gt; &#34;module_name&#34;.node.attr

    # x.T -&gt; node.value: the node x (Name) -&gt; node.attr is just &#34;T&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    value_cast = self.visit(
        node.value, prev_scope_id_dict, curr_scope_id_dict
    )
    unique_name = (
        node.attr
    )  # TODO: This unique name might change to better reflect what it belongs to (i.e. x.T instead of just T)

    if isinstance(node.ctx, ast.Load):
        if unique_name not in curr_scope_id_dict:
            if unique_name in prev_scope_id_dict:
                curr_scope_id_dict[unique_name] = prev_scope_id_dict[
                    unique_name
                ]
            else:
                if (
                    unique_name not in self.global_identifier_dict
                ):  # added for random.seed not exising, and other modules like that. in other words for functions in modules that we don&#39;t have visibility for.
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )
                curr_scope_id_dict[
                    unique_name
                ] = self.global_identifier_dict[unique_name]
    if isinstance(node.ctx, ast.Store):
        if unique_name not in curr_scope_id_dict:
            if unique_name in prev_scope_id_dict:
                curr_scope_id_dict[unique_name] = prev_scope_id_dict[
                    unique_name
                ]
            else:
                self.insert_next_id(curr_scope_id_dict, unique_name)

    attr_cast = Name(
        name=node.attr, id=curr_scope_id_dict[unique_name], source_refs=ref
    )

    return [Attribute(value_cast[0], attr_cast, source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_AugAssign"><code class="name flex">
<span>def <span class="ident">visit_AugAssign</span></span>(<span>self, node:_ast.AugAssign, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST AugAssign node, which is used for an
augmented assignment, like x += 1. AugAssign node is converted
to a regular PyAST Assign node and passed to that visitor to
generate CAST.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.AugAssign</code></dt>
<dd>A PyAST AugAssign node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Assign</code></dt>
<dd>A CAST Assign node, generated by the Assign visitor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_AugAssign(
    self,
    node: ast.AugAssign,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST AugAssign node, which is used for an
    augmented assignment, like x += 1. AugAssign node is converted
    to a regular PyAST Assign node and passed to that visitor to
    generate CAST.

    Args:
        node (ast.AugAssign): A PyAST AugAssign node

    Returns:
        Assign: A CAST Assign node, generated by the Assign visitor.
    &#34;&#34;&#34;

    # Convert AugAssign to regular Assign, and visit
    target = node.target
    value = node.value

    if isinstance(target, ast.Attribute):
        convert = ast.Assign(
            targets=[target],
            value=ast.BinOp(
                left=target,
                op=node.op,
                right=value,
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            ),
            col_offset=node.col_offset,
            end_col_offset=node.end_col_offset,
            lineno=node.lineno,
            end_lineno=node.end_lineno,
        )
    elif isinstance(target, ast.Subscript):
        convert = ast.Assign(
            targets=[target],
            value=ast.BinOp(
                left=target,
                ctx=ast.Load(),
                op=node.op,
                right=value,
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            ),
            col_offset=node.col_offset,
            end_col_offset=node.end_col_offset,
            lineno=node.lineno,
            end_lineno=node.end_lineno,
        )
    else:
        convert = ast.Assign(
            targets=[target],
            value=ast.BinOp(
                left=ast.Name(
                    target.id,
                    ctx=ast.Load(),
                    col_offset=node.col_offset,
                    end_col_offset=node.end_col_offset,
                    lineno=node.lineno,
                    end_lineno=node.end_lineno,
                ),
                op=node.op,
                right=value,
                col_offset=node.col_offset,
                end_col_offset=node.end_col_offset,
                lineno=node.lineno,
                end_lineno=node.end_lineno,
            ),
            col_offset=node.col_offset,
            end_col_offset=node.end_col_offset,
            lineno=node.lineno,
            end_lineno=node.end_lineno,
        )

    return self.visit(convert, prev_scope_id_dict, curr_scope_id_dict)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node:_ast.BinOp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST BinOp node, which consists of all the arithmetic
and bitwise operators.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.BinOp</code></dt>
<dd>A PyAST Binary operator node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Operator</code></dt>
<dd>A CAST operator node representing a math
operation (arithmetic or bitwise)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_BinOp(
    self,
    node: ast.BinOp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST BinOp node, which consists of all the arithmetic
    and bitwise operators.

    Args:
        node (ast.BinOp): A PyAST Binary operator node

    Returns:
        Operator: A CAST operator node representing a math
                  operation (arithmetic or bitwise)
    &#34;&#34;&#34;

    left = self.visit(node.left, prev_scope_id_dict, curr_scope_id_dict)
    op = get_op(node.op)
    right = self.visit(node.right, prev_scope_id_dict, curr_scope_id_dict)

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    leftb = []
    rightb = []

    if len(left) &gt; 1:
        leftb = left[0:-1]
    if len(right) &gt; 1:
        rightb = right[0:-1]

    return (
        leftb 
        + rightb
        + [Operator(source_language=&#34;Python&#34;, 
                    interpreter=&#34;Python&#34;, 
                    version=get_python_version(), 
                    op=op, 
                    operands=[left[-1], right[-1]], 
                    source_refs=ref)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_BoolOp"><code class="name flex">
<span>def <span class="ident">visit_BoolOp</span></span>(<span>self, node:_ast.BoolOp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a BoolOp node, which is a boolean operation connected with 'and'/'or's
The BoolOp node gets converted into an AST Compare node, and then the work is
passed off to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.BoolOp</code></dt>
<dd>An AST BoolOp node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BinaryOp</code></dt>
<dd>A BinaryOp node that is composed of operations connected with 'and'/'or's</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_BoolOp(
    self,
    node: ast.BoolOp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a BoolOp node, which is a boolean operation connected with &#39;and&#39;/&#39;or&#39;s
       The BoolOp node gets converted into an AST Compare node, and then the work is
       passed off to it.

    Args:
        node (ast.BoolOp): An AST BoolOp node

    Returns:
        BinaryOp: A BinaryOp node that is composed of operations connected with &#39;and&#39;/&#39;or&#39;s

    &#34;&#34;&#34;
    
    x = self.create_binary_compare_tree(node)
    &#34;&#34;&#34;
    print(&#34;Root&#34;)
    print(x.ops)
    print(x.left)
    print(x.comparators)

    print(&#34;Left&#34;)
    print(x.left.ops)
    print(x.left.left)
    print(x.left.comparators)

    print(&#34;Right&#34;)
    print(x.comparators[0].ops)
    print(x.comparators[0].left)
    print(x.comparators[0].comparators)
    &#34;&#34;&#34;

    return self.visit(x, prev_scope_id_dict, curr_scope_id_dict)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Break"><code class="name flex">
<span>def <span class="ident">visit_Break</span></span>(<span>self, node:_ast.Break, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Break node, which is just a break statement
nothing to be done for a Break node, just return a ModelBreak()
object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Break</code></dt>
<dd>An AST Break node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelBreak</code></dt>
<dd>A CAST Break node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Break(
    self,
    node: ast.Break,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Break node, which is just a break statement
       nothing to be done for a Break node, just return a ModelBreak()
       object

    Args:
        node (ast.Break): An AST Break node

    Returns:
        ModelBreak: A CAST Break node

    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [ModelBreak(source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node:_ast.Call, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Call node, which represents a function call.
Special care must be taken to see if it's a function call or a class's
method call. The CAST is generated a little different depending on
what kind of call it is.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Call</code></dt>
<dd>a PyAST Call node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Call</code></dt>
<dd>A CAST function call node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Call(
    self,
    node: ast.Call,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Call node, which represents a function call.
    Special care must be taken to see if it&#39;s a function call or a class&#39;s
    method call. The CAST is generated a little different depending on
    what kind of call it is.

    Args:
        node (ast.Call): a PyAST Call node

    Returns:
        Call: A CAST function call node
    &#34;&#34;&#34;

    args = []
    func_args = []
    kw_args = []
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    if len(node.args) &gt; 0:
        for arg in node.args:
            if isinstance(arg, ast.Subscript):
                unique_name = construct_unique_name(
                    self.filenames[-1], &#34;_get&#34;
                )
                if unique_name not in prev_scope_id_dict.keys():
                    # If a built-in is called, then it gets added to the global dictionary if
                    # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
                    # function
                    if (
                        unique_name
                        not in self.global_identifier_dict.keys()
                    ):
                        self.insert_next_id(
                            self.global_identifier_dict, unique_name
                        )

                    prev_scope_id_dict[
                        unique_name
                    ] = self.global_identifier_dict[unique_name]
                idx = self.visit(
                    arg.slice, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                val = self.visit(
                    arg.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                args = [val, idx]

                func_args.extend(
                    [
                        Call(
                            func=Name(
                                &#34;_get&#34;,
                                id=prev_scope_id_dict[unique_name],
                                source_refs=ref,
                            ),
                            arguments=args,
                            source_refs=ref,
                        )
                    ]
                )
            elif isinstance(arg, ast.Starred):
                if isinstance(arg.value, ast.Subscript):
                    func_args.append(
                        Name(
                            name=arg.value.value.id, id=-1, source_refs=ref
                        )
                    )
                else:
                    func_args.append(
                        Name(name=arg.value.id, id=-1, source_refs=ref)
                    )
            else:
                res = self.visit(
                    arg, prev_scope_id_dict, curr_scope_id_dict
                )
                if res != None:
                    func_args.extend(res)

    # g(3,id=4) TODO: Think more about this
    if len(node.keywords) &gt; 0:
        for arg in node.keywords:
            # print(prev_scope_id_dict)
            # print(curr_scope_id_dict)
            if arg.arg != None:
                val = self.visit(
                    arg.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]

                assign_node = Assignment(
                    left=Var(
                        Name(
                            name=arg.arg, id=100, source_refs=ref
                        ),  # TODO: add a proper ID here
                        type=&#34;float&#34;,
                        source_refs=ref,
                    ),
                    right=val,
                    source_refs=ref,
                )
            elif isinstance(arg.value, ast.Dict):
                val = self.visit(
                    arg.value, prev_scope_id_dict, curr_scope_id_dict
                )[0]
                assign_node = val
            else:
                if isinstance(arg.value, ast.Attribute) and isinstance(
                    arg.value.value, ast.Attribute
                ):
                    assign_node = Name(
                        name=arg.value.value.attr, id=-1, source_refs=ref
                    )
                elif isinstance(arg.value, ast.Call):
                    assign_node = Name(
                        name=arg.value.func.id, id=-1, source_refs=ref
                    )
                elif isinstance(arg.value, ast.Attribute):
                    assign_node = Name(
                        name=arg.value.value, id=-1, source_refs=ref
                    )
                elif isinstance(arg.value, ast.Subscript):
                    assign_node = Name(
                        name=arg.value.value.id, id=-1, source_refs=ref
                    )
                else:
                    assign_node = Name(
                        name=arg.value.id, id=-1, source_refs=ref
                    )
            kw_args.append(assign_node)
            # kw_args.extend(self.visit(arg.value, prev_scope_id_dict, curr_scope_id_dict))

    args = func_args + kw_args

    if isinstance(node.func, ast.Attribute):
        # print(node.func.attr)
        res = self.visit(node.func, prev_scope_id_dict, curr_scope_id_dict)
        return [Call(func=res[0], arguments=args, source_refs=ref)]
    else:
        # In the case we&#39;re calling a function that doesn&#39;t have an identifier already
        # This should only be the case for built-in python functions (i.e print, len, etc...)
        # Otherwise it would be an error to call a function before it is defined
        # (An ID would exist for a user-defined function here even if it isn&#39;t visited yet because of deferment)
        if isinstance(node.func, ast.Call):
            if node.func.func.id == &#34;list&#34;:
                unique_name = construct_unique_name(
                    self.filenames[-1], &#34;cast&#34;
                )
            else:
                unique_name = construct_unique_name(
                    self.filenames[-1], node.func.func.id
                )
        else:
            if node.func.id == &#34;list&#34;:
                unique_name = construct_unique_name(
                    self.filenames[-1], &#34;cast&#34;
                )
            else:
                unique_name = construct_unique_name(
                    self.filenames[-1], node.func.id
                )
        if unique_name not in prev_scope_id_dict.keys(): # and unique_name not in curr_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if unique_name not in self.global_identifier_dict.keys():
                self.insert_next_id(
                    self.global_identifier_dict, unique_name
                )

            prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]

        if isinstance(node.func, ast.Call):
            if node.func.func.id == &#34;list&#34;:
                args.append(
                    LiteralValue(
                        StructureType.LIST,
                        node.func.func.id,
                        [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                        ref,
                    )
                )
                return [
                    Call(
                        func=Name(
                            &#34;cast&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    )
                ]
            else:
                return [
                    Call(
                        func=Name(
                            node.func.func.id,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    )
                ]
        else:
            if node.func.id == &#34;list&#34;:
                args.append(
                    LiteralValue(
                        StructureType.LIST,
                        node.func.id,
                        [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;],
                        ref,
                    )
                )
                return [
                    Call(
                        func=Name(
                            &#34;cast&#34;,
                            id=prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    )
                ]
            else:
                return [
                    Call(
                        func=Name(
                            node.func.id,
                            id=curr_scope_id_dict[unique_name] if unique_name in curr_scope_id_dict else prev_scope_id_dict[unique_name], # NOTE: do this everywhere?
                            source_refs=ref,
                        ),
                        arguments=args,
                        source_refs=ref,
                    )
                ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node:_ast.ClassDef, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST ClassDef node, which is used to define user classes.
Acquiring the fields of the class involves going through the <strong>init</strong>
function and seeing if the attributes are associated with the self
parameter. In addition, we add to the 'classes' dictionary the name of
the class and a list of all its functions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.ClassDef</code></dt>
<dd>A PyAST class definition node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ClassDef</code></dt>
<dd>A CAST class definition node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_ClassDef(
    self,
    node: ast.ClassDef,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST ClassDef node, which is used to define user classes.
    Acquiring the fields of the class involves going through the __init__
    function and seeing if the attributes are associated with the self
    parameter. In addition, we add to the &#39;classes&#39; dictionary the name of
    the class and a list of all its functions.

    Args:
        node (ast.ClassDef): A PyAST class definition node

    Returns:
        ClassDef: A CAST class definition node
    &#34;&#34;&#34;
    name = node.name
    self.classes[name] = []

    bases = []
    for base in node.bases:
        bases.extend(
            self.visit(base, prev_scope_id_dict, curr_scope_id_dict)
        )

    fields = []
    funcs = []
    for func in node.body:
        if isinstance(func, ast.FunctionDef):
            if func.name != &#34;__init__&#34;:
                fields.extend(
                    self.collect_fields(
                        func, prev_scope_id_dict, curr_scope_id_dict
                    )
                )
            funcs.extend(
                self.visit(func, prev_scope_id_dict, curr_scope_id_dict)
            )
            # curr_scope_id_dict = {}
            # if isinstance(func,ast.FunctionDef):
            self.classes[name].append(func.name)
            # self.insert_next_id(prev_scope_id_dict, name)
            self.insert_next_id(prev_scope_id_dict, f&#34;{name}.{func.name}&#34;)

    # print(prev_scope_id_dict)
    # print(curr_scope_id_dict)
    # Get the fields in the class from init
    init_func = None
    for f in node.body:
        if isinstance(f, ast.FunctionDef) and f.name == &#34;__init__&#34;:
            init_func = f.body
            break

    if init_func != None:
        for func_node in init_func:
            if isinstance(func_node, ast.Assign) and isinstance(
                func_node.targets[0], ast.Attribute
            ):
                attr_node = func_node.targets[0]
                if attr_node.value.id == &#34;self&#34;:
                    ref = [
                        SourceRef(
                            source_file_name=self.filenames[-1],
                            col_start=attr_node.col_offset,
                            col_end=attr_node.end_col_offset,
                            row_start=attr_node.lineno,
                            row_end=attr_node.end_lineno,
                        )
                    ]
                    # Need IDs for name, which one?
                    attr_id = self.insert_next_id(
                        curr_scope_id_dict, attr_node.attr
                    )
                    fields.append(
                        Var(
                            Name(
                                attr_node.attr, id=attr_id, source_refs=ref
                            ),
                            &#34;float&#34;,
                            source_refs=ref,
                        )
                    )

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [RecordDef(name, bases, funcs, fields, source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Compare"><code class="name flex">
<span>def <span class="ident">visit_Compare</span></span>(<span>self, node:_ast.Compare, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Compare node, which consists of boolean operations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Compare</code></dt>
<dd>A PyAST Compare node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Operator</code></dt>
<dd>An Operator node, which in this case will hold a boolean</dd>
</dl>
<p>operation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Compare(
    self,
    node: ast.Compare,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Compare node, which consists of boolean operations

    Args:
        node (ast.Compare): A PyAST Compare node

    Returns:
        Operator: An Operator node, which in this case will hold a boolean
        operation
    &#34;&#34;&#34;
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]


    # Fetch the first element (which is in node.left)
    #left = node.left
    #ops = [op for op in node.ops]
    # Grab the first comparison operation
    # print(left)
    # print(node.ops)
    # op = get_op(node.ops.pop(0))
    # op = get_op(ops.pop())

    
    # maintain a stack of if statements that we build up
    if_stack = []
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(True))]
    true_val = LiteralValue(
        ScalarType.BOOLEAN,
        &#34;True&#34;,
        source_code_data_type=source_code_data_type,
        source_refs=ref,
    )
    false_val = LiteralValue(
        ScalarType.BOOLEAN,
        &#34;False&#34;,
        source_code_data_type=source_code_data_type,
        source_refs=ref,
    )


    idx = len(node.comparators) - 1
    op_idx = len(node.ops) - 1
    tree_root = None
    while idx &gt; 0:
        op = get_op(node.ops[op_idx])
        l = self.visit(node.comparators[idx - 1], prev_scope_id_dict, curr_scope_id_dict)[0]
        r = self.visit(node.comparators[idx], prev_scope_id_dict, curr_scope_id_dict)[0] 

        if op == &#34;ast.And&#34;:
            test = ModelIf(expr=l, body=[r], orelse=[false_val], source_refs=ref)
        elif op == &#34;ast.Or&#34;:
            test = ModelIf(expr=l, body=[true_val], orelse=[r], source_refs=ref)
        else:
            test = Operator(source_language=&#34;Python&#34;, interpreter=&#34;Python&#34;,
                            version=get_python_version(),
                            op=op,
                            operands=[l,r],
                            source_refs=ref)
        if tree_root == None:        
            tree_root = test
        else:
            tree_root = ModelIf(expr=test,body=[tree_root],orelse=[false_val], source_refs=ref)

        op_idx = op_idx - 1
        idx = idx - 1

    op = get_op(node.ops[op_idx])
    l = self.visit(node.left, prev_scope_id_dict, curr_scope_id_dict)[0]
    r = self.visit(node.comparators[idx], prev_scope_id_dict, curr_scope_id_dict)[0] 
    if op == &#34;ast.And&#34;:
        test = ModelIf(expr=l, body=[r], orelse=[false_val], source_refs=ref)
    elif op == &#34;ast.Or&#34;:
        test = ModelIf(expr=l, body=[true_val], orelse=[r], source_refs=ref)
    else:
        test = Operator(source_language=&#34;Python&#34;, interpreter=&#34;Python&#34;,
                        version=get_python_version(),
                        op=op,
                        operands=[l,r],
                        source_refs=ref)

    if tree_root == None:
        tree_root = test
    else:
        tree_root = ModelIf(expr=test,body=[tree_root],orelse=[false_val], source_refs=ref)

    return [tree_root]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node:_ast.Constant, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Constant node, which can hold either numeric or
string values. A dictionary is used to index into which operation
we're doing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Constant</code></dt>
<dd>A PyAST Constant node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Number</code></dt>
<dd>A CAST numeric node, if the node's value is an int or float</dd>
<dt><code>String</code></dt>
<dd>A CAST string node, if the node's value is a string</dd>
<dt><code>Boolean</code></dt>
<dd>A CAST boolean node, if the node's value is a boolean</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the node's value is something else that isn't
recognized by the other two cases</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Constant(
    self,
    node: ast.Constant,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Constant node, which can hold either numeric or
    string values. A dictionary is used to index into which operation
    we&#39;re doing.

    Args:
        node (ast.Constant): A PyAST Constant node

    Returns:
        Number: A CAST numeric node, if the node&#39;s value is an int or float
        String: A CAST string node, if the node&#39;s value is a string
        Boolean: A CAST boolean node, if the node&#39;s value is a boolean

    Raises:
        TypeError: If the node&#39;s value is something else that isn&#39;t
                   recognized by the other two cases
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(node.value))]
    # NOTE: We have to check the types such that no ancestor is checked before a descendant
    # boolean values are also seen as integers with isinstance()
    # TODO: Consider using type() with a map instead of isinstance to check types
    if isinstance(node.value, bool):
        return [
            LiteralValue(
                ScalarType.BOOLEAN,
                str(node.value),
                source_code_data_type,
                ref,
            )
        ]
    elif isinstance(node.value, int):
        return [
            LiteralValue(
                ScalarType.INTEGER, node.value, source_code_data_type, ref
            )
        ]
    elif isinstance(node.value, float):
        return [
            LiteralValue(
                ScalarType.ABSTRACTFLOAT,
                node.value,
                source_code_data_type,
                ref,
            )
        ]
    elif isinstance(node.value, str):
        return [
            LiteralValue(
                StructureType.LIST, node.value, source_code_data_type, ref
            )
        ]
    elif node.value is None:
        return [LiteralValue(None, None, source_code_data_type, ref)]
    elif isinstance(node.value, type(...)):
        return []
    else:
        raise TypeError(f&#34;Type {str(type(node.value))} not supported&#34;)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Continue"><code class="name flex">
<span>def <span class="ident">visit_Continue</span></span>(<span>self, node:_ast.Continue, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Continue node, which is just a continue statement
nothing to be done for a Continue node, just return a ModelContinue node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Continue</code></dt>
<dd>An AST Continue node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelContinue</code></dt>
<dd>A CAST Continue node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Continue(
    self,
    node: ast.Continue,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Continue node, which is just a continue statement
       nothing to be done for a Continue node, just return a ModelContinue node

    Args:
        node (ast.Continue): An AST Continue node

    Returns:
        ModelContinue: A CAST Continue node
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [ModelContinue(source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Delete"><code class="name flex">
<span>def <span class="ident">visit_Delete</span></span>(<span>self, node:_ast.Delete, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Delete(
    self,
    node: ast.Delete,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    # print(&#34;Delete not generating CAST yet&#34;)
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [
        LiteralValue(
            StructureType.LIST,
            &#34;NotImplemented&#34;,
            source_code_data_type,
            ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Dict"><code class="name flex">
<span>def <span class="ident">visit_Dict</span></span>(<span>self, node:_ast.Dict, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Dict node, which represents a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Dict</code></dt>
<dd>A PyAST dictionary node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>A CAST Dictionary node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Dict(
    self,
    node: ast.Dict,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Dict node, which represents a dictionary.

    Args:
        node (ast.Dict): A PyAST dictionary node

    Returns:
        Dict: A CAST Dictionary node.
    &#34;&#34;&#34;
    # TODO: when a ** shows up in a dictionary

    keys = []
    values = []
    if len(node.keys) &gt; 0:
        for piece in node.keys:
            if piece != None:
                keys.extend(
                    self.visit(
                        piece, prev_scope_id_dict, curr_scope_id_dict
                    )
                )

    if len(node.values) &gt; 0:
        for piece in node.values:
            if piece != None:
                values.extend(
                    self.visit(
                        piece, prev_scope_id_dict, curr_scope_id_dict
                    )
                )

    k = [e.value if hasattr(e, &#34;value&#34;) else e for e in keys]
    v = [e.value if hasattr(e, &#34;value&#34;) else e for e in values]

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    for key in k:
        if isinstance(key, LiteralValue) and key.value_type == StructureType.TUPLE:
            return [
                LiteralValue(
                    StructureType.MAP,
                    &#34;&#34;,
                    source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, str(dict)],
                    source_refs=ref,
                )
            ]

    # return [LiteralValue(StructureType.MAP, str(dict(list(zip(k,v)))), source_code_data_type=[&#34;Python&#34;,&#34;3.8&#34;,str(dict)], source_refs=ref)]
    return [
        LiteralValue(
            StructureType.MAP,
            str(list(zip(k, v))),
            source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, str(dict)],
            source_refs=ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_DictComp"><code class="name flex">
<span>def <span class="ident">visit_DictComp</span></span>(<span>self, node:_ast.DictComp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_DictComp(
    self,
    node: ast.DictComp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    ref = [
        self.filenames[-1],
        node.col_offset,
        node.end_col_offset,
        node.lineno,
        node.end_lineno,
    ]

    # node (ast.DictComp)
    #  key       - what makes the keys
    #  value     - what makes the valuedds
    #  generators - list of &#39;comprehension&#39; nodes

    temp_dict_name = f&#34;dict__temp_&#34;

    generators = node.generators
    first_gen = generators[-1]
    i = len(generators) - 2
    temp_assign = ast.Assign(
        targets=[
            ast.Name(
                id=temp_dict_name,
                ctx=ast.Store(),
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ],
        value=ast.Dict(
            keys=[],
            values=[],
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        ),
        type_comment=None,
        col_offset=ref[1],
        end_col_offset=ref[2],
        lineno=ref[3],
        end_lineno=ref[4],
    )

    # Constructs the Python AST for the innermost loop in the dict comprehension
    if len(first_gen.ifs) &gt; 0:
        innermost_loop_body = ast.If(
            test=first_gen.ifs[0],
            body=[
                ast.Assign(
                    targets=[
                        ast.Subscript(
                            value=ast.Name(
                                id=temp_dict_name,
                                ctx=ast.Load(),
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            ),
                            slice=node.key,
                            ctx=ast.Store(),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        )
                    ],
                    value=node.value,
                    type_comment=None,
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ],
            orelse=[],
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )
    else:
        innermost_loop_body = ast.Assign(
            targets=[
                ast.Subscript(
                    value=ast.Name(
                        id=temp_dict_name,
                        ctx=ast.Load(),
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    ),
                    slice=node.key,
                    ctx=ast.Store(),
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                )
            ],
            value=node.value,
            type_comment=None,
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )

    loop_collection = [
        ast.For(
            target=self.identify_piece(
                first_gen.target, prev_scope_id_dict, curr_scope_id_dict
            ),
            iter=first_gen.iter,
            # iter=self.identify_piece(first_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
            body=[innermost_loop_body],
            orelse=[],
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )
    ]

    # Every other loop in the list comprehension wraps itself around the previous loop that we
    # added
    while i &gt;= 0:
        curr_gen = generators[i]
        if len(curr_gen.ifs) &gt; 0:
            # TODO: if multiple ifs exist per a single generator then we have to expand this
            curr_if = curr_gen.ifs[0]
            next_loop = ast.For(
                target=self.identify_piece(
                    curr_gen.target, prev_scope_id_dict, curr_scope_id_dict
                ),
                iter=curr_gen.iter,
                # iter=self.identify_piece(curr_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                body=[
                    ast.If(
                        test=curr_if,
                        body=[loop_collection[0]],
                        orelse=[],
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        else:
            next_loop = ast.For(
                target=self.identify_piece(
                    curr_gen.target, prev_scope_id_dict, curr_scope_id_dict
                ),
                iter=curr_gen.iter,
                # iter=self.identify_piece(curr_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
                body=[loop_collection[0]],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        loop_collection.insert(0, next_loop)
        i = i - 1

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    temp_cast = self.visit(
        temp_assign, prev_scope_id_dict, curr_scope_id_dict
    )
    loop_cast = self.visit(
        loop_collection[0], prev_scope_id_dict, curr_scope_id_dict
    )

    # TODO: Arguments for comprehension, IDs
    return_cast = [ModelReturn(value=Var(val=Name(name=temp_dict_name, id=-1, source_refs=ref), source_refs=ref), source_refs=ref)]

    comp_func_name = f&#34;%comprehension_dict_{self.dict_comp_count}&#34;
    self.dict_comp_count += 1
    comp_func_id = -1 # TODO

    name_node = Name(comp_func_name, comp_func_id, source_refs=ref)
    func_def_cast = FunctionDef(name=name_node, func_args=[], body=temp_cast+loop_cast+return_cast, source_refs=ref)
    
    self.generated_fns.append(func_def_cast)

    to_ret = [Call(func=Name(comp_func_name, comp_func_id, source_refs=ref),arguments=[],source_refs=ref)]

    return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Ellipsis"><code class="name flex">
<span>def <span class="ident">visit_Ellipsis</span></span>(<span>self, node:ast.Ellipsis, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Ellipsis(
    self,
    node: ast.Ellipsis,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;Ellipsis&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [
        LiteralValue(
            ScalarType.ELLIPSIS, &#34;...&#34;, source_code_data_type, ref
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Expr"><code class="name flex">
<span>def <span class="ident">visit_Expr</span></span>(<span>self, node:_ast.Expr, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Expr node, which represents some kind of standalone
expression.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Expr</code></dt>
<dd>A PyAST Expression node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Expr</code></dt>
<dd>
<p>A CAST Expression node</p>
</dd>
<dt><code>[AstNode]</code></dt>
<dd>A list of AstNodes if the expression consists
of more than one node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Expr(
    self,
    node: ast.Expr,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Expr node, which represents some kind of standalone
    expression.

    Args:
        node (ast.Expr): A PyAST Expression node

    Returns:
        Expr:      A CAST Expression node
        [AstNode]: A list of AstNodes if the expression consists
                   of more than one node
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ExtSlice"><code class="name flex">
<span>def <span class="ident">visit_ExtSlice</span></span>(<span>self, node:_ast.ExtSlice, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_ExtSlice(
    self,
    node: ast.ExtSlice,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    # print(&#34;ExtSlice not generating CAST yet&#34;)
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=-1,
            col_end=-1,
            row_start=-1,
            row_end=-1,
        )
    ]
    return [
        LiteralValue(
            StructureType.LIST,
            &#34;NotImplemented&#34;,
            source_code_data_type,
            ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_For"><code class="name flex">
<span>def <span class="ident">visit_For</span></span>(<span>self, node:_ast.For, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST For node, which represents Python for loops.
A For loop needs different handling than a while loop.
In particular, a For loop acts on an iterator as opposed to acting on
some kind of condition. In order to make this translation a little easier to handle
we leverage the iterator constructs to convert the For loop into a while loop using
the iterators.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.For</code></dt>
<dd>A PyAST For loop node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Loop</code></dt>
<dd>A CAST loop node, which generically represents both For
loops and While loops.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_For(
    self, node: ast.For, prev_scope_id_dict, curr_scope_id_dict
):
    &#34;&#34;&#34;Visits a PyAST For node, which represents Python for loops.
    A For loop needs different handling than a while loop.
    In particular, a For loop acts on an iterator as opposed to acting on
    some kind of condition. In order to make this translation a little easier to handle
    we leverage the iterator constructs to convert the For loop into a while loop using
    the iterators.

    Args:
        node (ast.For): A PyAST For loop node.

    Returns:
        Loop: A CAST loop node, which generically represents both For
              loops and While loops.
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    target = self.visit(
        node.target, prev_scope_id_dict, curr_scope_id_dict
    )[0]
    iterable = self.visit(
        node.iter, prev_scope_id_dict, curr_scope_id_dict
    )[0]

    # The body of a loop contains its own scope (it can create variables only it can see and can use
    # variables from its enclosing scope) so we copy the current scope and merge scopes
    # to create the enclosing scope for the loop body
    curr_scope_copy = copy.deepcopy(curr_scope_id_dict)
    merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
    loop_scope_id_dict = {}

    # When we pass in scopes, we pass what&#39;s currently in the previous scope along with
    # the curr scope which would consist of the loop variables (node.target) and the item
    # we loop over (iter) though the second one shouldn&#39;t ever be accessed
    body = []
    for piece in node.body + node.orelse:
        body.extend(
            self.visit(piece, curr_scope_id_dict, loop_scope_id_dict)
        )

    # Once we&#39;re out of the loop body we can copy the current scope back
    curr_scope_id_dict = copy.deepcopy(curr_scope_copy)

    # TODO: Mark these as variables that were generated by this script at some point
    # (^ This was a really old request, not sure if it&#39;s still needed at this point)
    iterator_name = f&#34;generated_iter_{self.var_count}&#34;
    self.var_count += 1

    iterator_id = self.insert_next_id(curr_scope_id_dict, iterator_name)

    # &#39;iter&#39; and &#39;next&#39; are python built-ins
    iter_id = -1
    if &#34;iter&#34; not in self.global_identifier_dict.keys():
        iter_id = self.insert_next_id(self.global_identifier_dict, &#34;iter&#34;)
    else:
        iter_id = self.global_identifier_dict[&#34;iter&#34;]

    if &#34;next&#34; not in self.global_identifier_dict.keys():
        next_id = self.insert_next_id(self.global_identifier_dict, &#34;next&#34;)
    else:
        next_id = self.global_identifier_dict[&#34;next&#34;]

    stop_cond_name = f&#34;sc_{self.var_count}&#34;
    self.var_count += 1

    stop_cond_id = self.insert_next_id(curr_scope_id_dict, stop_cond_name)

    iter_var_cast = Var(
        Name(name=iterator_name, id=iterator_id, source_refs=ref),
        &#34;iterator&#34;,
        source_refs=ref,
    )

    stop_cond_var_cast = Var(
        Name(name=stop_cond_name, id=stop_cond_id, source_refs=ref),
        &#34;boolean&#34;,
        source_refs=ref,
    )

    iter_var = Assignment(
        iter_var_cast,
        Call(
            func=Name(name=&#34;iter&#34;, id=iter_id, source_refs=ref),
            arguments=[iterable],
            source_refs=ref,
        ),
        source_refs=ref,
    )

    source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
    first_next = Assignment(
        LiteralValue(StructureType.TUPLE, [target, iter_var_cast, stop_cond_var_cast], source_code_data_type, source_refs=ref),
        Call(
            func=Name(name=&#34;next&#34;, id=next_id, source_refs=ref),
            arguments=[
                Var(
                    Name(
                        name=iterator_name, id=iterator_id, source_refs=ref
                    ),
                    &#34;iterator&#34;,
                    source_refs=ref,
                )
            ],
            source_refs=ref,
        ),
        source_refs=ref,
    )
    loop_cond = Operator(source_language=&#34;Python&#34;, 
                interpreter=&#34;Python&#34;, 
                version=get_python_version(), 
                op=&#34;ast.Eq&#34;, 
                operands=[stop_cond_var_cast,
                LiteralValue(
                    ScalarType.BOOLEAN,
                    False,
                    [&#34;Python&#34;, &#34;3.8&#34;, &#34;boolean&#34;],
                    source_refs=ref,
                )], 
                source_refs=ref)

    source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
    loop_assign = Assignment(
        LiteralValue(StructureType.TUPLE, [target, iter_var_cast, stop_cond_var_cast], source_code_data_type, source_refs=ref),
        Call(
            func=Name(name=&#34;next&#34;, id=next_id, source_refs=ref),
            arguments=[
                Var(
                    Name(
                        name=iterator_name, id=iterator_id, source_refs=ref
                    ),
                    &#34;iterator&#34;,
                    source_refs=ref,
                )
            ],
            source_refs=ref,
        ),
        source_refs=ref,
    )

    return [
        Loop(
            pre=[iter_var, first_next],
            expr=loop_cond,
            body=body + [loop_assign],
            post=[],
            source_refs=ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node:_ast.FunctionDef, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST FunctionDef node. Which is used for a Python
function definition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.FunctionDef</code></dt>
<dd>A PyAST function definition node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FunctionDef</code></dt>
<dd>A CAST Function Definition node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_FunctionDef(
    self,
    node: ast.FunctionDef,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST FunctionDef node. Which is used for a Python
    function definition.

    Args:
        node (ast.FunctionDef): A PyAST function definition node

    Returns:
        FunctionDef: A CAST Function Definition node
    &#34;&#34;&#34;

    # Copy the enclosing scope dictionary as it is before we visit the current function
    # The idea for this is to prevent any weird overwritting issues that may arise from modifying
    # dictionaries in place
    prev_scope_id_dict_copy = copy.deepcopy(prev_scope_id_dict)

    body = []
    args = []
    curr_scope_id_dict = {}
    arg_count = len(node.args.args)
    kwonlyargs_count = len(node.args.kwonlyargs)
    default_val_count = len(node.args.defaults)
    if arg_count &gt; 0:
        # No argument has a default value
        if default_val_count == 0:
            for arg in node.args.args:
                # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                # self.insert_next_id(curr_scope_id_dict, arg.arg)
                # self.insert_next_id(curr_scope_id_dict, f&#34;{node.name}.{arg.arg}&#34;)
                self.insert_next_id(curr_scope_id_dict, f&#34;{arg.arg}&#34;)
                # self.insert_next_id(curr_scope_id_dict, unique_name)
                arg_ref = SourceRef(self.filenames[-1], arg.col_offset, arg.end_col_offset, arg.lineno, arg.end_lineno)
                args.append(
                    Var(
                        Name(
                            arg.arg,
                            id=curr_scope_id_dict[arg.arg],
                            # id=curr_scope_id_dict[f&#34;{node.name}.{arg.arg}&#34;],
                            source_refs=[arg_ref]
                        ),
                        &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                        None,
                        source_refs=[arg_ref]
                    )
                )
        else:
            # Implies that all arguments have default values
            if arg_count == default_val_count:
                for i, arg in enumerate(node.args.args, 0):
                    self.insert_next_id(curr_scope_id_dict, arg.arg)
                    val = self.visit(
                        node.args.defaults[i],
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                    args.append(
                        Var(
                            Name(
                                arg.arg,
                                id=curr_scope_id_dict[arg.arg],
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            ),
                            &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                            val,
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        )
                    )

            # There&#39;s less default values than actual args, the positional-only arguments come first
            else:
                pos_idx = 0
                for arg in node.args.args:
                    if arg_count == default_val_count:
                        break
                    self.insert_next_id(curr_scope_id_dict, arg.arg)
                    args.append(
                        Var(
                            Name(
                                arg.arg,
                                id=curr_scope_id_dict[arg.arg],
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            ),
                            &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                            None,
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        )
                    )

                    pos_idx += 1
                    arg_count -= 1

                default_index = 0
                while arg_count &gt; 0:
                    # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
                    arg = node.args.args[pos_idx]
                    self.insert_next_id(curr_scope_id_dict, arg.arg)
                    val = self.visit(
                        node.args.defaults[default_index],
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                    # self.insert_next_id(curr_scope_id_dict, unique_name)
                    args.append(
                        Var(
                            Name(
                                arg.arg,
                                id=curr_scope_id_dict[arg.arg],
                                source_refs=[
                                    SourceRef(
                                        self.filenames[-1],
                                        arg.col_offset,
                                        arg.end_col_offset,
                                        arg.lineno,
                                        arg.end_lineno,
                                    )
                                ],
                            ),
                            &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                            val,
                            source_refs=[
                                SourceRef(
                                    self.filenames[-1],
                                    arg.col_offset,
                                    arg.end_col_offset,
                                    arg.lineno,
                                    arg.end_lineno,
                                )
                            ],
                        )
                    )

                    pos_idx += 1
                    arg_count -= 1
                    default_index += 1

    if kwonlyargs_count &gt; 0:
        for arg in node.args.kwonlyargs:
            # unique_name = construct_unique_name(self.filenames[-1], arg.arg)
            self.insert_next_id(curr_scope_id_dict, arg.arg)
            # self.insert_next_id(curr_scope_id_dict, unique_name)
            args.append(
                Var(
                    Name(
                        arg.arg,
                        id=curr_scope_id_dict[arg.arg],
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    ),
                    &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                    None,
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                )
            )

    # Store &#39;*args&#39; as a name
    arg = node.args.vararg
    if arg != None:
        self.insert_next_id(curr_scope_id_dict, arg.arg)
        args.append(
            Var(
                Name(
                    arg.arg,
                    id=curr_scope_id_dict[arg.arg],
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                ),
                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                None,
                source_refs=[
                    SourceRef(
                        self.filenames[-1],
                        arg.col_offset,
                        arg.end_col_offset,
                        arg.lineno,
                        arg.end_lineno,
                    )
                ],
            )
        )

    # Store &#39;**kwargs&#39; as a name
    arg = node.args.kwarg
    if arg != None:
        self.insert_next_id(curr_scope_id_dict, arg.arg)
        args.append(
            Var(
                Name(
                    arg.arg,
                    id=curr_scope_id_dict[arg.arg],
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                ),
                &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                None,
                source_refs=[
                    SourceRef(
                        self.filenames[-1],
                        arg.col_offset,
                        arg.end_col_offset,
                        arg.lineno,
                        arg.end_lineno,
                    )
                ],
            )
        )

    functions_to_visit = []

    if len(node.body) &gt; 0:
        # To account for nested loops we check to see if the CAST node is in a list and
        # extend accordingly

        for piece in node.body:
            if isinstance(piece, ast.Assign):
                names = get_node_name(piece)

                for var_name in names:
                    # unique_name = construct_unique_name(
                    #    self.filenames[-1], var_name
                    # )
                    self.insert_next_id(curr_scope_id_dict, var_name)
                        
                merge_dicts(curr_scope_id_dict, prev_scope_id_dict)
        # merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
        for piece in node.body:

            if isinstance(piece, ast.FunctionDef):
                unique_name = construct_unique_name(self.filenames[-1], piece.name)
                self.insert_next_id(curr_scope_id_dict, unique_name)
                prev_scope_id_dict[unique_name] = curr_scope_id_dict[unique_name]
                # functions_to_visit.append(piece)
                #continue

                # print(curr_scope_id_dict)
                # print(prev_scope_id_dict)

            # Have to figure out name IDs for imports (i.e. other modules)
            # These asserts will keep us from visiting them from now
            # assert not isinstance(piece, ast.Import)
            # assert not isinstance(piece, ast.ImportFrom)
            to_add = self.visit(
                piece, prev_scope_id_dict, curr_scope_id_dict
            )

            # TODO: Find the case where &#34;__getitem__&#34; is used
            if hasattr(to_add, &#34;__iter__&#34;) or hasattr(
                to_add, &#34;__getitem__&#34;
            ):
                body.extend(to_add)
            elif to_add == None:
                body.extend([])
            else:
                raise TypeError(
                    f&#34;Unexpected type in visit_FuncDef: {type(to_add)}&#34;
                )

        # Merge keys from prev_scope not in cur_scope into cur_scope
        # merge_dicts(prev_scope_id_dict, curr_scope_id_dict)

        # Visit the deferred functions
        #for piece in functions_to_visit:
         #   to_add = self.visit(piece, curr_scope_id_dict, {})
          #  body.extend(to_add)

    # TODO: Decorators? Returns? Type_comment?
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    # &#34;Revert&#34; the enclosing scope dictionary to what it was before we went into this function
    # since none of the variables within here should exist outside of here..?
    # TODO: this might need to be different, since Python variables can exist outside of a scope??
    prev_scope_id_dict = copy.deepcopy(prev_scope_id_dict_copy)

    # Global level (i.e. module level) functions have their module names appended to them, we make sure
    # we have the correct name depending on whether or not we&#39;re visiting a global
    # level function or a function enclosed within another function
    if node.name in prev_scope_id_dict.keys():
        if self.legacy:
            return [FunctionDef(node.name, args, body, source_refs=ref)]
        else:
            return [
                FunctionDef(
                    Name(
                        node.name,
                        prev_scope_id_dict[node.name],
                        source_refs=ref,
                    ),
                    args,
                    body,
                    source_refs=ref,
                )
            ]
    else:
        unique_name = construct_unique_name(self.filenames[-1], node.name)
        if unique_name in prev_scope_id_dict.keys():
            if self.legacy:
                return [
                    FunctionDef(node.name, args, body, source_refs=ref)
                ]
            else:
                return [
                    FunctionDef(
                        Name(
                            node.name,
                            prev_scope_id_dict[unique_name],
                            source_refs=ref,
                        ),
                        args,
                        body,
                        source_refs=ref,
                    )
                ]
        else:
            self.insert_next_id(prev_scope_id_dict, unique_name)
            return [
                FunctionDef(
                    Name(
                        node.name,
                        prev_scope_id_dict[unique_name],
                        source_refs=ref,
                    ),
                    args,
                    body,
                    source_refs=ref,
                )
            ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_GeneratorExp"><code class="name flex">
<span>def <span class="ident">visit_GeneratorExp</span></span>(<span>self, node:_ast.GeneratorExp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_GeneratorExp(
    self,
    node: ast.GeneratorExp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    ref = [
        node.col_offset,
        node.end_col_offset,
        node.lineno,
        node.end_lineno,
    ]
    to_visit = ast.ListComp(
        elt=node.elt,
        generators=node.generators,
        lineno=ref[2],
        col_offset=ref[0],
        end_lineno=ref[3],
        end_col_offset=ref[1],
    )

    return self.visit(to_visit, prev_scope_id_dict, curr_scope_id_dict)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Global"><code class="name flex">
<span>def <span class="ident">visit_Global</span></span>(<span>self, node:_ast.Global, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Global node.
What this does is write in the IDs for variables that are
explicitly declared as global within a scope using the global keyword
as follows
global x [, y, z, etc..]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Global</code></dt>
<dd>A PyAST Global node</dd>
<dt><strong><code>prev_scope_id_dict</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Dictionary containing the scope's current variable : ID maps</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>empty list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Global(
    self,
    node: ast.Global,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Global node.
    What this does is write in the IDs for variables that are
    explicitly declared as global within a scope using the global keyword
    as follows
    global x [, y, z, etc..]

    Args:
        node (ast.Global): A PyAST Global node
        prev_scope_id_dict (Dict): Dictionary containing the scope&#39;s current variable : ID maps

    Returns:
        List: empty list
    &#34;&#34;&#34;

    for v in node.names:
        unique_name = construct_unique_name(self.filenames[-1], v)
        curr_scope_id_dict[unique_name] = self.global_identifier_dict[
            unique_name
        ]
    return []</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_If"><code class="name flex">
<span>def <span class="ident">visit_If</span></span>(<span>self, node:_ast.If, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST If node. Which is used to represent If statements.
We visit each of the pieces accordingly and construct the CAST
representation. else/elif statements are stored in the 'orelse' field,
if there are any.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.If</code></dt>
<dd>A PyAST If node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelIf</code></dt>
<dd>A CAST If statement node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_If(
    self, node: ast.If, prev_scope_id_dict, curr_scope_id_dict
):
    &#34;&#34;&#34;Visits a PyAST If node. Which is used to represent If statements.
    We visit each of the pieces accordingly and construct the CAST
    representation. else/elif statements are stored in the &#39;orelse&#39; field,
    if there are any.

    Args:
        node (ast.If): A PyAST If node.

    Returns:
        ModelIf: A CAST If statement node.
    &#34;&#34;&#34;

    # node_test = self.visit(
    #     node.test, prev_scope_id_dict, curr_scope_id_dict
    # )
    node_test = self.create_cond(
        node, prev_scope_id_dict, curr_scope_id_dict
    )

    node_body = []
    if len(node.body) &gt; 0:
        for piece in node.body:
            node_body.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )

    node_orelse = []
    if len(node.orelse) &gt; 0:
        for piece in node.orelse:
            node_orelse.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]


    if isinstance(node_test, list):
        return [ModelIf(node_test[0], node_body, node_orelse, source_refs=ref)]
    else:
        return [ModelIf(node_test, node_body, node_orelse, source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_IfExp"><code class="name flex">
<span>def <span class="ident">visit_IfExp</span></span>(<span>self, node:_ast.IfExp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST IfExp node, which is Python's ternary operator.
The node gets translated into a CAST ModelIf node by visiting all its parts,
since IfExp behaves like an If statement.</p>
<h1 id="todo-rethink-how-this-is-done-to-better-reflect">TODO: Rethink how this is done to better reflect</h1>
<ul>
<li>ternary for assignments</li>
<li>ternary in function call arguments</li>
</ul>
<h1 id="note-do-we-want-to-treat-this-as-a-conditional-block-in-gromet-but-it-shouldnt-show-up-in-the-expression-tree">NOTE: Do we want to treat this as a conditional block in GroMEt? But it shouldn't show up in the expression tree</h1>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.IfExp</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_IfExp(
    self,
    node: ast.IfExp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST IfExp node, which is Python&#39;s ternary operator.
    The node gets translated into a CAST ModelIf node by visiting all its parts,
    since IfExp behaves like an If statement.

    # TODO: Rethink how this is done to better reflect
     - ternary for assignments
     - ternary in function call arguments

    # NOTE: Do we want to treat this as a conditional block in GroMEt? But it shouldn&#39;t show up in the expression tree

    Args:
        node (ast.IfExp): [description]
    &#34;&#34;&#34;

    node_test = self.visit(
        node.test, prev_scope_id_dict, curr_scope_id_dict
    )
    node_body = self.visit(
        node.body, prev_scope_id_dict, curr_scope_id_dict
    )
    node_orelse = self.visit(
        node.orelse, prev_scope_id_dict, curr_scope_id_dict
    )
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    return [ModelIf(node_test[0], node_body, node_orelse, source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Import"><code class="name flex">
<span>def <span class="ident">visit_Import</span></span>(<span>self, node:_ast.Import, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Import node, which is used for importing libraries
that are used in programs. In particular, it's imports in the form of
'import X', where X is some library.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Import</code></dt>
<dd>A PyAST Import node</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Import(
    self,
    node: ast.Import,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Import node, which is used for importing libraries
    that are used in programs. In particular, it&#39;s imports in the form of
    &#39;import X&#39;, where X is some library.

    Args:
        node (ast.Import): A PyAST Import node

    Returns:
    &#34;&#34;&#34;
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    names = node.names
    to_ret = []
    for alias in names:
        as_name = alias.asname
        orig_name = alias.name

        # Construct the path of the module, relative to where we are at
        # TODO: (Still have to handle things like &#39;..&#39;)
        name = alias.name

        # module1.x, module2.x
        # {module1: {x: 1}, module2: {x: 4}}

        # For cases like &#39;import module as something_else&#39;
        # We note the alias that the import uses for this module
        # Qualify names
        if as_name is not None:
            self.aliases[as_name] = orig_name
            name = alias.asname

        # TODO: Could use a flag to mark a Module as an import (old)
        if orig_name in BUILTINS or find_std_lib_module(orig_name):
            self.insert_next_id(self.global_identifier_dict, name)
            to_ret.append(
                ModelImport(
                    name=orig_name,
                    alias=as_name,
                    symbol=None,
                    all=False,
                    source_refs=ref,
                )
            )
    return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ImportFrom"><code class="name flex">
<span>def <span class="ident">visit_ImportFrom</span></span>(<span>self, node:_ast.ImportFrom, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST ImportFrom node, which is used for importing libraries
that are used in programs. In particular, it's imports in the form of
'import X', where X is some library.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Import</code></dt>
<dd>A PyAST Import node</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_ImportFrom(
    self,
    node: ast.ImportFrom,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST ImportFrom node, which is used for importing libraries
    that are used in programs. In particular, it&#39;s imports in the form of
    &#39;import X&#39;, where X is some library.

    Args:
        node (ast.Import): A PyAST Import node

    Returns:
    &#34;&#34;&#34;

    # Construct the path of the module, relative to where we are at
    # (TODO: Still have to handle things like &#39;..&#39;)
    # TODO: What about importing individual functions from a module M
    #        that call other functions from that same module M
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    name = node.module
    if name in self.aliases:
        name = self.aliases[name]

    aliases = node.names
    to_ret = []
    for (
        alias
    ) in (
        aliases
    ):  # Iterate through the symbols that are being imported and create individual imports for each
        if alias.asname is not None:
            self.aliases[alias.asname] = alias.name

        if name in BUILTINS or find_std_lib_module(name):
            if alias.name == &#34;*&#34;:
                to_ret.append(
                    ModelImport(
                        name=name,
                        alias=None,
                        symbol=None,
                        all=True,
                        source_refs=ref,
                    )
                )
            else:
                to_ret.append(
                    ModelImport(
                        name=name,
                        alias=None,
                        symbol=alias.name,
                        all=False,
                        source_refs=ref,
                    )
                )
        else:  # User defined module import
            if alias.name == &#34;*&#34;:
                to_ret.append(
                    ModelImport(
                        name=name,
                        alias=None,
                        symbol=None,
                        all=True,
                        source_refs=ref,
                    )
                )
            else:
                to_ret.append(
                    ModelImport(
                        name=name,
                        alias=None,
                        symbol=alias.name,
                        all=False,
                        source_refs=ref,
                    )
                )

    return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Index"><code class="name flex">
<span>def <span class="ident">visit_Index</span></span>(<span>self, node:_ast.Index, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Index node, which represents the value being used
for an index. This visitor doesn't create its own CAST node, but
returns CAST depending on the value that the Index node holds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Index</code></dt>
<dd>A CAST Index node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AstNode</code></dt>
<dd>Depending on what the value of the Index node is,
different CAST nodes are returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Index(
    self,
    node: ast.Index,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Index node, which represents the value being used
    for an index. This visitor doesn&#39;t create its own CAST node, but
    returns CAST depending on the value that the Index node holds.

    Args:
        node (ast.Index): A CAST Index node.

    Returns:
        AstNode: Depending on what the value of the Index node is,
                 different CAST nodes are returned.
    &#34;&#34;&#34;

    return self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_JoinedStr"><code class="name flex">
<span>def <span class="ident">visit_JoinedStr</span></span>(<span>self, node:_ast.JoinedStr, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_JoinedStr(
    self,
    node: ast.JoinedStr,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    # print(&#34;JoinedStr not generating CAST yet&#34;)
    str_pieces = []
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    for s in node.values:
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(&#34;str&#34;))]
        if isinstance(s, ast.Str):
            str_pieces.append(
                LiteralValue(
                    StructureType.LIST, s.s, source_code_data_type, ref
                )
            )
        else:
            f_string_val = self.visit(
                s.value, prev_scope_id_dict, curr_scope_id_dict
            )
            str_pieces.append(
                LiteralValue(
                    StructureType.LIST,
                    f_string_val,
                    source_code_data_type,
                    ref,
                )
            )

    unique_name = construct_unique_name(self.filenames[-1], &#34;Concatenate&#34;)
    if unique_name not in prev_scope_id_dict.keys():
        # If a built-in is called, then it gets added to the global dictionary if
        # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
        # function
        if unique_name not in self.global_identifier_dict.keys():
            self.insert_next_id(self.global_identifier_dict, unique_name)

        prev_scope_id_dict[unique_name] = self.global_identifier_dict[
            unique_name
        ]
    return [
        Call(
            func=Name(
                &#34;Concatenate&#34;,
                id=prev_scope_id_dict[unique_name],
                source_refs=ref,
            ),
            arguments=str_pieces,
            source_refs=ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Lambda"><code class="name flex">
<span>def <span class="ident">visit_Lambda</span></span>(<span>self, node:_ast.Lambda, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Lambda node. Which is used for a Python Lambda
function definition. It works pretty analogously to the FunctionDef
node visitor. It also returns a FunctionDef node like the PyAST
FunctionDef node visitor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Lambda</code></dt>
<dd>A PyAST lambda function definition node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FunctionDef</code></dt>
<dd>A CAST Function Definition node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Lambda(
    self,
    node: ast.Lambda,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Lambda node. Which is used for a Python Lambda
    function definition. It works pretty analogously to the FunctionDef
    node visitor. It also returns a FunctionDef node like the PyAST
    FunctionDef node visitor.

    Args:
        node (ast.Lambda): A PyAST lambda function definition node

    Returns:
        FunctionDef: A CAST Function Definition node

    &#34;&#34;&#34;

    curr_scope_id_dict = {}

    args = []
    # TODO: Correct typing instead of just &#39;float&#39;
    if len(node.args.args) &gt; 0:
        for arg in node.args.args:
            self.insert_next_id(curr_scope_id_dict, arg.arg)

            args.append(
                Var(
                    Name(
                        arg.arg,
                        id=curr_scope_id_dict[arg.arg],
                        source_refs=[
                            SourceRef(
                                self.filenames[-1],
                                arg.col_offset,
                                arg.end_col_offset,
                                arg.lineno,
                                arg.end_lineno,
                            )
                        ],
                    ),
                    &#34;float&#34;,  # TODO: Correct typing instead of just &#39;float&#39;
                    source_refs=[
                        SourceRef(
                            self.filenames[-1],
                            arg.col_offset,
                            arg.end_col_offset,
                            arg.lineno,
                            arg.end_lineno,
                        )
                    ],
                )
            )

    body = self.visit(node.body, prev_scope_id_dict, curr_scope_id_dict)

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    # TODO: add an ID for lambda name
    if self.legacy:
        return [FunctionDef(&#34;LAMBDA&#34;, args, body, source_refs=ref)]
    else:
        lambda_name = f&#34;%lambda{self.lambda_count}&#34;
        self.lambda_count += 1
        lambda_id = -1 # TODO

        name_node = Name(lambda_name, lambda_id, source_refs=ref)
        self.generated_fns.append(FunctionDef(name_node, args, body, source_refs=ref))
    
        # NOTE: What should the arguments be?
        to_ret = [Call(func=Name(lambda_name, lambda_id, source_refs=ref),arguments=args,source_refs=ref)]

        return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node:_ast.List, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST List node. Which is used to represent Python lists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.List</code></dt>
<dd>A PyAST List node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>A CAST List node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_List(
    self,
    node: ast.List,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST List node. Which is used to represent Python lists.

    Args:
        node (ast.List): A PyAST List node.

    Returns:
        List: A CAST List node.
    &#34;&#34;&#34;

    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    # TODO: How to handle constructors with variables?
    if len(node.elts) &gt; 0:
        to_ret = []
        for piece in node.elts:
            to_ret.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        # TODO: How to represent computations like &#39;[0.0] * 1000&#39; in some kind of type constructing system
        # and then how could we store that in these LiteralValue nodes?
        return [
            LiteralValue(
                StructureType.LIST, to_ret, source_code_data_type, ref
            )
        ]
        # return [List(to_ret,source_refs=ref)]
    else:
        return [
            LiteralValue(
                StructureType.LIST, [], source_code_data_type, ref
            )
        ]
        # return [List([],source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ListComp"><code class="name flex">
<span>def <span class="ident">visit_ListComp</span></span>(<span>self, node:_ast.ListComp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST ListComp node, which are used for Python list comprehensions.
List comprehensions generate a list from some generator expression.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.ListComp</code></dt>
<dd>A PyAST list comprehension node</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Loop:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_ListComp(
    self,
    node: ast.ListComp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST ListComp node, which are used for Python list comprehensions.
    List comprehensions generate a list from some generator expression.

    Args:
        node (ast.ListComp): A PyAST list comprehension node

    Returns:
        Loop:
    &#34;&#34;&#34;

    ref = [
        self.filenames[-1],
        node.col_offset,
        node.end_col_offset,
        node.lineno,
        node.end_lineno,
    ]

    temp_list_name = f&#34;list__temp_&#34;
    temp_assign = ast.Assign(
        targets=[
            ast.Name(
                id=temp_list_name,
                ctx=ast.Store(),
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ],
        value=ast.List(
            elts=[],
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        ),
        type_comment=None,
        col_offset=ref[1],
        end_col_offset=ref[2],
        lineno=ref[3],
        end_lineno=ref[4],
    )

    generators = node.generators
    first_gen = generators[-1]
    i = len(generators) - 2

    # Constructs the Python AST for the innermost loop in the list comprehension
    if len(first_gen.ifs) &gt; 0:
        innermost_loop_body = [
            ast.If(
                test=first_gen.ifs[0],
                body=[
                    ast.Expr(
                        value=ast.Call(
                            func=ast.Attribute(
                                value=ast.Name(
                                    id=temp_list_name,
                                    ctx=ast.Load(),
                                    col_offset=ref[1],
                                    end_col_offset=ref[2],
                                    lineno=ref[3],
                                    end_lineno=ref[4],
                                ),
                                attr=&#34;append&#34;,
                                ctx=ast.Load(),
                                col_offset=ref[1],
                                end_col_offset=ref[2],
                                lineno=ref[3],
                                end_lineno=ref[4],
                            ),
                            args=[node.elt],
                            keywords=[],
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        ),
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ]
    else:
        innermost_loop_body = [
            ast.Expr(
                value=ast.Call(
                    func=ast.Attribute(
                        value=ast.Name(
                            id=temp_list_name,
                            ctx=ast.Load(),
                            col_offset=ref[1],
                            end_col_offset=ref[2],
                            lineno=ref[3],
                            end_lineno=ref[4],
                        ),
                        attr=&#34;append&#34;,
                        ctx=ast.Load(),
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    ),
                    args=[node.elt],
                    keywords=[],
                    col_offset=ref[1],
                    end_col_offset=ref[2],
                    lineno=ref[3],
                    end_lineno=ref[4],
                ),
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )
        ]

    loop_collection = [
        ast.For(
            target=self.identify_piece(
                first_gen.target, prev_scope_id_dict, curr_scope_id_dict
            ),
            iter=first_gen.iter,
            # iter=self.identify_piece(first_gen.iter, prev_scope_id_dict, curr_scope_id_dict),
            body=innermost_loop_body,
            orelse=[],
            col_offset=ref[1],
            end_col_offset=ref[2],
            lineno=ref[3],
            end_lineno=ref[4],
        )
    ]

    # Every other loop in the list comprehension wraps itself around the previous loop that we
    # added
    while i &gt;= 0:
        curr_gen = generators[i]
        if len(curr_gen.ifs) &gt; 0:
            # TODO: if multiple ifs exist per a single generator then we have to expand this
            curr_if = curr_gen.ifs[0]
            next_loop = ast.For(
                target=self.identify_piece(
                    curr_gen.target, curr_scope_id_dict, prev_scope_id_dict
                ),
                iter=self.identify_piece(
                    curr_gen.iter, curr_scope_id_dict, prev_scope_id_dict
                ),
                body=[
                    ast.If(
                        test=curr_if,
                        body=[loop_collection[0]],
                        orelse=[],
                        col_offset=ref[1],
                        end_col_offset=ref[2],
                        lineno=ref[3],
                        end_lineno=ref[4],
                    )
                ],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )

        else:
            next_loop = ast.For(
                target=self.identify_piece(
                    curr_gen.target, curr_scope_id_dict, prev_scope_id_dict
                ),
                iter=self.identify_piece(
                    curr_gen.iter, curr_scope_id_dict, prev_scope_id_dict
                ),
                body=[loop_collection[0]],
                orelse=[],
                col_offset=ref[1],
                end_col_offset=ref[2],
                lineno=ref[3],
                end_lineno=ref[4],
            )

        loop_collection.insert(0, next_loop)
        i = i - 1

    temp_cast = self.visit(
        temp_assign, prev_scope_id_dict, curr_scope_id_dict
    )
    loop_cast = self.visit(
        loop_collection[0], prev_scope_id_dict, curr_scope_id_dict
    )

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    # TODO: arguments for a comprehension, IDs
    return_cast = [ModelReturn(value=Var(val=Name(name=temp_list_name, source_refs=ref), source_refs=ref), source_refs=ref)]

    comp_func_name = f&#34;%comprehension_list_{self.list_comp_count}&#34;
    self.list_comp_count += 1
    comp_func_id = -1 #TODO

    name_node = Name(comp_func_name, comp_func_id, source_refs=ref)
    func_def_cast = FunctionDef(name=name_node, func_args=[], body=temp_cast+loop_cast+return_cast, source_refs=ref)
    
    self.generated_fns.append(func_def_cast)

    to_ret = [Call(func=Name(comp_func_name, comp_func_id, source_refs=ref),arguments=[],source_refs=ref)]

    return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Module"><code class="name flex">
<span>def <span class="ident">visit_Module</span></span>(<span>self, node:_ast.Module, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Module node. This is the starting point of CAST Generation,
as the body of the Module node (usually) contains the entire Python
program.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Module</code></dt>
<dd>A PyAST Module node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Module</code></dt>
<dd>A CAST Module node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Module(
    self,
    node: ast.Module,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Module node. This is the starting point of CAST Generation,
    as the body of the Module node (usually) contains the entire Python
    program.

    Args:
        node (ast.Module): A PyAST Module node.

    Returns:
        Module: A CAST Module node.
    &#34;&#34;&#34;

    # Visit all the nodes and make a Module object out of them
    body = []
    funcs = []
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=-1,
            col_end=-1,
            row_start=-1,
            row_end=-1,
        )
    ]
    self.module_stack.append(node)
    
    # Attempt to capture all global variable names
    # before we do any function definitions
    # (functions can use global variables so they need them all available)
    for line in node.body:
        if isinstance(line, ast.Assign):
            names = get_node_name(line)

            for var_name in names:
                unique_name = construct_unique_name(
                    self.filenames[-1], var_name
                )
                self.insert_next_id(self.global_identifier_dict, unique_name)
    
    merge_dicts(self.global_identifier_dict, curr_scope_id_dict)
    merge_dicts(curr_scope_id_dict, prev_scope_id_dict)
    for piece in node.body:
        # Defer visiting function defs until all global vars are processed
        if isinstance(piece, ast.FunctionDef):
            unique_name = construct_unique_name(
                self.filenames[-1], piece.name
            )
            self.insert_next_id(curr_scope_id_dict, unique_name)
            prev_scope_id_dict[unique_name] = curr_scope_id_dict[
                unique_name
            ]
            #funcs.append(piece)
            #continue

        to_add = self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)

        # Global variables (which come about from assignments at the module level)
        # need to have their identifier names set correctly so they can be
        # accessed appropriately later on
        # We check if we just visited an assign and fix its key/value pair in the dictionary
        # So instead of
        #   &#34;var_name&#34; -&gt; ID
        # It becomes
        #   &#34;module_name.var_name&#34; -&gt; ID
        # in the dictionary
        # If an assign happens at the global level, then we must also make sure to
        # Update the global dictionary at this time so that the IDs are defined
        # and are correct
        if isinstance(piece, ast.Assign):
            names = get_node_name(to_add[0])

            for var_name in names:
                #temp_id = curr_scope_id_dict[var_name]
                del curr_scope_id_dict[var_name]
                #unique_name = construct_unique_name(
                #    self.filenames[-1], var_name
                #)
                #curr_scope_id_dict[unique_name] = temp_id
                #merge_dicts(
                #    curr_scope_id_dict, self.global_identifier_dict
                #)

        if isinstance(to_add, Module):
            body.extend([to_add])
        else:
            body.extend(to_add)

    #merge_dicts(curr_scope_id_dict, self.global_identifier_dict)
    #merge_dicts(prev_scope_id_dict, curr_scope_id_dict)

    # Visit all the functions
    #for piece in funcs:
     #   to_add = self.visit(piece, curr_scope_id_dict, {})
      #  body.extend(to_add)

    self.module_stack.pop()
    return Module(
        name=self.filenames[-1].split(&#34;.&#34;)[0], body=self.generated_fns+body, source_refs=ref
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node:_ast.Name, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>This visits PyAST Name nodes, which consist of
id: The name of a variable as a string
ctx: The context in which the variable is being used</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Name</code></dt>
<dd>A PyAST Name node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Expr</code></dt>
<dd>A CAST Expression node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Name(
    self,
    node: ast.Name,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;This visits PyAST Name nodes, which consist of
       id: The name of a variable as a string
       ctx: The context in which the variable is being used

    Args:
        node (ast.Name): A PyAST Name node

    Returns:
        Expr: A CAST Expression node

    &#34;&#34;&#34;
    # TODO: Typing so it&#39;s not hardcoded to floats
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    if isinstance(node.ctx, ast.Load):
        if node.id in self.aliases:
            return [Name(self.aliases[node.id], id=-1, source_refs=ref)]

        if node.id not in curr_scope_id_dict:
            if node.id in prev_scope_id_dict:
                curr_scope_id_dict[node.id] = prev_scope_id_dict[node.id]
            else:
                unique_name = construct_unique_name(
                    self.filenames[-1], node.id
                )

                # We can have the very odd case where a variable is used in a function before
                # it even exists. To my knowledge this happens in one scenario:
                # - A global variable, call it z, is used in a function
                # - Before that function is called in Python code, that global variable
                #   z is set by another module/another piece of code as a global
                #   (i.e. by doing module_name.z = a value)
                # It&#39;s not something that is very common (or good) to do, but regardless
                # we&#39;ll catch it here just in case.
                if unique_name not in self.global_identifier_dict.keys():
                    self.insert_next_id(
                        self.global_identifier_dict, unique_name
                    )

                curr_scope_id_dict[node.id] = self.global_identifier_dict[
                    unique_name
                ]

        return [
            Name(node.id, id=curr_scope_id_dict[node.id], source_refs=ref)
        ]

    if isinstance(node.ctx, ast.Store):
        if node.id in self.aliases:
            return [
                Var(
                    Name(self.aliases[node.id], id=-1, source_refs=ref),
                    &#34;float&#34;,
                    source_refs=ref,
                )
            ]

        if node.id not in curr_scope_id_dict:
            # We construct the unique name for the case that
            # An assignment to a global happens in the global scope
            # (i.e. a loop at the global level)
            # Check if it&#39;s in the previous scope not as a global (general case when in a function)
            # then check if it&#39;s in the previous scope as a global (when we&#39;re at the global scope)
            unique_name = construct_unique_name(
                self.filenames[-1], node.id
            )
            if node.id in prev_scope_id_dict:
                curr_scope_id_dict[node.id] = prev_scope_id_dict[node.id]
            elif unique_name in prev_scope_id_dict:
                curr_scope_id_dict[node.id] = prev_scope_id_dict[
                    unique_name
                ]
            else:
                self.insert_next_id(curr_scope_id_dict, node.id)

        return [
            Var(
                Name(
                    node.id,
                    id=curr_scope_id_dict[node.id],
                    source_refs=ref,
                ),
                &#34;float&#34;,
                source_refs=ref,
            )
        ]

    if isinstance(node.ctx, ast.Del):
        # TODO: At some point..
        raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Pass"><code class="name flex">
<span>def <span class="ident">visit_Pass</span></span>(<span>self, node:_ast.Pass, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>A PyAST Pass visitor, for essentially NOPs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Pass(
    self,
    node: ast.Pass,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;A PyAST Pass visitor, for essentially NOPs.&#34;&#34;&#34;
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [
        LiteralValue(
            StructureType.LIST,
            &#34;NotImplemented&#34;,
            source_code_data_type,
            ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Raise"><code class="name flex">
<span>def <span class="ident">visit_Raise</span></span>(<span>self, node:_ast.Raise, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>A PyAST Raise visitor, for Raising exceptions</p>
<p>TODO: To be implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Raise(
    self,
    node: ast.Raise,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;A PyAST Raise visitor, for Raising exceptions

    TODO: To be implemented.
    &#34;&#34;&#34;
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    exc_name = &#34;&#34;
    if isinstance(node.exc, ast.Name):
        exc_name = node.exc.id
    elif isinstance(node.exc, ast.Call):
        if isinstance(node.exc.func, ast.Name):
            exc_name = node.exc.func.id

    raise_id = -1
    if &#34;raise&#34; not in self.global_identifier_dict.keys():
        raise_id = self.insert_next_id(
            self.global_identifier_dict, &#34;raise&#34;
        )
    else:
        raise_id = self.global_identifier_dict[&#34;raise&#34;]

    return [
        Call(
            func=Name(&#34;raise&#34;, raise_id, source_refs=ref),
            arguments=[
                LiteralValue(
                    StructureType.LIST,
                    exc_name,
                    source_code_data_type,
                    ref,
                )
            ],
            source_refs=ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Return"><code class="name flex">
<span>def <span class="ident">visit_Return</span></span>(<span>self, node:_ast.Return, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Return node and creates a CAST return node
that has one field, which is the expression computing the value
to be returned. The PyAST's value node is visited.
The CAST node is then returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Return</code></dt>
<dd>A PyAST Return node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ModelReturn</code></dt>
<dd>A CAST Return node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Return(
    self,
    node: ast.Return,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Return node and creates a CAST return node
       that has one field, which is the expression computing the value
       to be returned. The PyAST&#39;s value node is visited.
       The CAST node is then returned.

    Args:
        node (ast.Return): A PyAST Return node

    Returns:
        ModelReturn: A CAST Return node
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    if node.value != None:
        return [
            ModelReturn(
                self.visit(
                    node.value, prev_scope_id_dict, curr_scope_id_dict
                )[0],
                source_refs=ref,
            )
        ]
    else:
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, str(type(node.value))]
        val = LiteralValue(None, None, source_code_data_type, ref)
        return [ModelReturn(val, source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Set"><code class="name flex">
<span>def <span class="ident">visit_Set</span></span>(<span>self, node:_ast.Set, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Set node. Which is used to represent Python sets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Set</code></dt>
<dd>A PyAST Set node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Set</code></dt>
<dd>A CAST Set node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Set(
    self, node: ast.Set, prev_scope_id_dict, curr_scope_id_dict
):
    &#34;&#34;&#34;Visits a PyAST Set node. Which is used to represent Python sets.

    Args:
        node (ast.Set): A PyAST Set node.

    Returns:
        Set: A CAST Set node.
    &#34;&#34;&#34;

    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    if len(node.elts) &gt; 0:
        to_ret = []
        for piece in node.elts:
            to_ret.extend(
                self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
            )
        return [
            LiteralValue(
                StructureType.SET, to_ret, source_code_data_type, ref
            )
        ]
    else:
        return [
            LiteralValue(
                StructureType.SET, to_ret, source_code_data_type, ref
            )
        ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Slice"><code class="name flex">
<span>def <span class="ident">visit_Slice</span></span>(<span>self, node:_ast.Slice, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Slice(
    self,
    node: ast.Slice,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    # print(&#34;Slice not generating CAST yet&#34;)
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=-1,
            col_end=-1,
            row_start=-1,
            row_end=-1,
        )
    ]
    return [
        LiteralValue(
            StructureType.LIST,
            &#34;NotImplemented&#34;,
            source_code_data_type,
            ref,
        )
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node:_ast.Subscript, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Subscript node, which represents subscripting into
a list in Python. A Subscript is either a Slice (i.e. x[0:2]), an
Extended slice (i.e. x[0:2, 3]), or a constant (i.e. x[3]).
In the Slice case, a loop is generated that fetches the correct elements and puts them
into a list.
In the Extended slice case, nested loops are generated as needed to create a final
result list with the selected elements.
In the constant case, we can visit and generate a CAST Subscript in a normal way.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Subscript</code></dt>
<dd>A PyAST Subscript node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Subscript</code></dt>
<dd>A CAST Subscript node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Subscript(
    self,
    node: ast.Subscript,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Subscript node, which represents subscripting into
    a list in Python. A Subscript is either a Slice (i.e. x[0:2]), an
    Extended slice (i.e. x[0:2, 3]), or a constant (i.e. x[3]).
    In the Slice case, a loop is generated that fetches the correct elements and puts them
    into a list.
    In the Extended slice case, nested loops are generated as needed to create a final
    result list with the selected elements.
    In the constant case, we can visit and generate a CAST Subscript in a normal way.

    Args:
        node (ast.Subscript): A PyAST Subscript node

    Returns:
        Subscript: A CAST Subscript node
    &#34;&#34;&#34;

    # value = self.visit(node.value, prev_scope_id_dict, curr_scope_id_dict)[0]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    # &#39;Visit&#39; the slice
    slc = node.slice
    temp_var = f&#34;generated_index_{self.var_count}&#34;
    self.var_count += 1

    if isinstance(slc, ast.Slice):
        if slc.lower is not None:
            start = self.visit(
                slc.lower, prev_scope_id_dict, curr_scope_id_dict
            )[0]
        else:
            start = LiteralValue(
                value_type=ScalarType.INTEGER,
                value=0,
                source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                source_refs=ref,
            )

        if slc.upper is not None:
            stop = self.visit(
                slc.upper, prev_scope_id_dict, curr_scope_id_dict
            )[0]
        else:
            if isinstance(node.value, ast.Call):
                if isinstance(node.value.func, ast.Attribute):
                    stop = Call(
                        func=Name(&#34;len&#34;, source_refs=ref),
                        arguments=[Name(node.value.func.attr, source_refs=ref)],
                        source_refs=ref,
                    )
                else:
                    stop = Call(
                        func=Name(&#34;len&#34;, source_refs=ref),
                        arguments=[Name(node.value.func.id, source_refs=ref)],
                        source_refs=ref,
                    )
            elif isinstance(node.value, ast.Attribute):
                stop = Call(
                    func=Name(&#34;len&#34;, source_refs=ref),
                    arguments=[Name(node.value.attr, source_refs=ref)],
                    source_refs=ref,
                )
            else:
                if isinstance(node.value, ast.Subscript):
                    id = self.visit(
                        node.value, prev_scope_id_dict, curr_scope_id_dict
                    )
                else:
                    id = node.value.id
                stop = Call(
                    func=Name(&#34;len&#34;, source_refs=ref),
                    arguments=[Name(id, source_refs=ref)],
                    source_refs=ref,
                )

        if slc.step is not None:
            step = self.visit(
                slc.step, prev_scope_id_dict, curr_scope_id_dict
            )[0]
        else:
            step = LiteralValue(
                value_type=ScalarType.INTEGER,
                value=1,
                source_code_data_type=[&#34;Python&#34;, &#34;3.8&#34;, &#34;Float&#34;],
                source_refs=ref,
            )

        unique_name = construct_unique_name(self.filenames[-1], &#34;slice&#34;)
        if unique_name not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if unique_name not in self.global_identifier_dict.keys():
                self.insert_next_id(
                    self.global_identifier_dict, unique_name
                )

            prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]

        slice_call = Call(
            func=Name(
                &#34;slice&#34;,
                id=prev_scope_id_dict[unique_name],
                source_refs=ref,
            ),
            arguments=[start, stop, step],
            source_refs=ref,
        )

        val = self.visit(
            node.value, prev_scope_id_dict, curr_scope_id_dict
        )[0]

        unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
        if unique_name not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if unique_name not in self.global_identifier_dict.keys():
                self.insert_next_id(
                    self.global_identifier_dict, unique_name
                )

            prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]
        # return[Call(Name(&#34;Concatenate&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref), str_pieces, source_refs=ref)]

        get_call = Call(
            func=Name(
                &#34;_get&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref
            ),
            arguments=[val, slice_call],
            source_refs=ref,
        )

        return [get_call]
    elif isinstance(slc, ast.Index):

        val = self.visit(
            node.value, prev_scope_id_dict, curr_scope_id_dict
        )[0]
        slice_val = self.visit(
            slc.value, prev_scope_id_dict, curr_scope_id_dict
        )[0]
        unique_name = construct_unique_name(self.filenames[-1], &#34;_get&#34;)
        if unique_name not in prev_scope_id_dict.keys():
            # If a built-in is called, then it gets added to the global dictionary if
            # it hasn&#39;t been called before. This is to maintain one consistent ID per built-in
            # function
            if unique_name not in self.global_identifier_dict.keys():
                self.insert_next_id(
                    self.global_identifier_dict, unique_name
                )

            prev_scope_id_dict[unique_name] = self.global_identifier_dict[
                unique_name
            ]
        get_call = Call(
            func=Name(
                &#34;_get&#34;, id=prev_scope_id_dict[unique_name], source_refs=ref
            ),
            arguments=[val, slice_val],
            source_refs=ref,
        )
        return [get_call]
    elif isinstance(slc, ast.ExtSlice):
        dims = slc.dims
        result = []
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        return [
            LiteralValue(
                StructureType.LIST,
                &#34;NotImplemented&#34;,
                source_code_data_type,
                ref,
            )
        ]

    # else:
    #   sl = self.visit(slc, prev_scope_id_dict, curr_scope_id_dict)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Try"><code class="name flex">
<span>def <span class="ident">visit_Try</span></span>(<span>self, node:_ast.Try, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Try node, which represents Try/Except blocks.
These are used for Python's exception handling</p>
<p>Currently, the visitor just bypasses the Try/Except feature and just
generates CAST for the body of the 'Try' block, assuming the exception(s)
are never thrown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Try(
    self, node: ast.Try, prev_scope_id_dict, curr_scope_id_dict
):
    &#34;&#34;&#34;Visits a PyAST Try node, which represents Try/Except blocks.
    These are used for Python&#39;s exception handling

    Currently, the visitor just bypasses the Try/Except feature and just
    generates CAST for the body of the &#39;Try&#39; block, assuming the exception(s)
    are never thrown.
    &#34;&#34;&#34;

    body = []
    for piece in node.body:
        body.extend(
            self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
        )
    for piece in node.orelse:
        body.extend(
            self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
        )
    for piece in node.finalbody:
        body.extend(
            self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
        )

    return body</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node:_ast.Tuple, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST Tuple node. Which is used to represent Python tuple.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.Tuple</code></dt>
<dd>A PyAST Tuple node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Set</code></dt>
<dd>A CAST Tuple node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Tuple(
    self,
    node: ast.Tuple,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST Tuple node. Which is used to represent Python tuple.

    Args:
        node (ast.Tuple): A PyAST Tuple node.

    Returns:
        Set: A CAST Tuple node.
    &#34;&#34;&#34;

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    # if len(node.elts) &gt; 0:
    to_ret = []
    for piece in node.elts:
        to_ret.extend(
            self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
        )
    source_code_data_type = [&#34;Python&#34;,&#34;3.8&#34;,&#34;Tuple&#34;]
    return [LiteralValue(StructureType.TUPLE, to_ret, source_code_data_type, source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node:_ast.UnaryOp, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST UnaryOp node. Which represents Python unary operations.
A dictionary is used to index into which operation we're doing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.UnaryOp</code></dt>
<dd>A PyAST UnaryOp node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>UnaryOp</code></dt>
<dd>A CAST UnaryOp node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_UnaryOp(
    self,
    node: ast.UnaryOp,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST UnaryOp node. Which represents Python unary operations.
    A dictionary is used to index into which operation we&#39;re doing.

    Args:
        node (ast.UnaryOp): A PyAST UnaryOp node.

    Returns:
        UnaryOp: A CAST UnaryOp node.
    &#34;&#34;&#34;

    op = get_op(node.op)
    operand = node.operand

    opd = self.visit(operand, prev_scope_id_dict, curr_scope_id_dict)

    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    return [Operator(source_language=&#34;Python&#34;, 
            interpreter=&#34;Python&#34;, 
            version=get_python_version(), 
            op=op, 
            operands=[opd[0]], 
            source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_While"><code class="name flex">
<span>def <span class="ident">visit_While</span></span>(<span>self, node:_ast.While, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST While node, which represents a while loop.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.While</code></dt>
<dd>a PyAST while node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Loop</code></dt>
<dd>A CAST loop node, which generically represents both For
loops and While loops.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_While(
    self,
    node: ast.While,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST While node, which represents a while loop.

    Args:
        node (ast.While): a PyAST while node

    Returns:
        Loop: A CAST loop node, which generically represents both For
              loops and While loops.
    &#34;&#34;&#34;
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]

    # test_cond = self.visit(node.test, prev_scope_id_dict, curr_scope_id_dict)[0]
    test = self.create_cond(node, prev_scope_id_dict, curr_scope_id_dict)

    # Loops have their own enclosing scopes
    curr_scope_copy = copy.deepcopy(curr_scope_id_dict)
    merge_dicts(prev_scope_id_dict, curr_scope_id_dict)
    loop_body_scope = {}
    body = []
    for piece in node.body + node.orelse:
        to_add = self.visit(piece, curr_scope_id_dict, loop_body_scope)
        body.extend(to_add)

    curr_scope_id_dict = copy.deepcopy(curr_scope_copy)

    # loop_body_fn_def = FunctionDef(name=&#34;while_temp&#34;, func_args=None, body=body)
    # return [Loop(init=[], expr=test, body=loop_body_fn_def, source_refs=ref)]
    if isinstance(test, list):
        return [Loop(pre=[], expr=test[0], body=body, post=[], source_refs=ref)]
    else:
        return [Loop(pre=[], expr=test, body=body, post=[], source_refs=ref)]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_With"><code class="name flex">
<span>def <span class="ident">visit_With</span></span>(<span>self, node:_ast.With, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Visits a PyAST With node. With nodes are used as follows:
with a as b, c as d:
do things with b and d
To use aliases on variables and operate on them
This visitor unrolls the With block and generates the appropriate cast for the
underlying operations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>ast.With</code></dt>
<dd>a PyAST with node</dd>
</dl>
<h2 id="args_1">Args</h2>
<p>[AstNode]: A list of CAST nodes, representing whatever operations were happening in the With
block before they got unrolled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_With(
    self,
    node: ast.With,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    &#34;&#34;&#34;Visits a PyAST With node. With nodes are used as follows:
    with a as b, c as d:
        do things with b and d
    To use aliases on variables and operate on them
    This visitor unrolls the With block and generates the appropriate cast for the
    underlying operations

    Args:
        node (ast.With): a PyAST with node

    Args:
        [AstNode]: A list of CAST nodes, representing whatever operations were happening in the With
                   block before they got unrolled

    &#34;&#34;&#34;

    ref = None
    variables = []
    for item in node.items:
        ref = [
            SourceRef(
                source_file_name=self.filenames[-1],
                col_start=node.col_offset,
                col_end=node.end_col_offset,
                row_start=node.lineno,
                row_end=node.end_lineno,
            )
        ]
        if item.optional_vars != None:
            l = self.visit(
                item.optional_vars, prev_scope_id_dict, curr_scope_id_dict
            )
            r = self.visit(
                item.context_expr, prev_scope_id_dict, curr_scope_id_dict
            )
            variables.extend(
                [Assignment(left=l[0], right=r[0], source_refs=ref)]
            )
        else:
            variables.extend(
                [
                    self.visit(
                        item.context_expr,
                        prev_scope_id_dict,
                        curr_scope_id_dict,
                    )[0]
                ]
            )

    body = []
    for piece in node.body:
        body.extend(
            self.visit(piece, prev_scope_id_dict, curr_scope_id_dict)
        )

    return variables + body</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Yield"><code class="name flex">
<span>def <span class="ident">visit_Yield</span></span>(<span>self, node:_ast.Yield, prev_scope_id_dict, curr_scope_id_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@visit.register
def visit_Yield(
    self,
    node: ast.Yield,
    prev_scope_id_dict,
    curr_scope_id_dict,
):
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = [
        SourceRef(
            source_file_name=self.filenames[-1],
            col_start=node.col_offset,
            col_end=node.end_col_offset,
            row_start=node.lineno,
            row_end=node.end_lineno,
        )
    ]
    return [
        LiteralValue(
            StructureType.LIST,
            &#34;NotImplemented&#34;,
            source_code_data_type,
            ref,
        )
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis.CAST.pythonAST" href="index.html">skema.program_analysis.CAST.pythonAST</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.construct_unique_name" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.construct_unique_name">construct_unique_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_node_name" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_node_name">get_node_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_op" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_op">get_op</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_python_version" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.get_python_version">get_python_version</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.merge_dicts" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.merge_dicts">merge_dicts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST">PyASTToCAST</a></code></h4>
<ul class="">
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.check_alias" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.check_alias">check_alias</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.collect_fields" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.collect_fields">collect_fields</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.create_binary_compare_tree" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.create_binary_compare_tree">create_binary_compare_tree</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.create_cond" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.create_cond">create_cond</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.find_function" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.find_function">find_function</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.identify_piece" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.identify_piece">identify_piece</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.insert_alias" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.insert_alias">insert_alias</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.insert_next_id" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.insert_next_id">insert_next_id</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit">visit</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Assert" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Assert">visit_Assert</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Assign" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Assign">visit_Assign</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Attribute" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_AugAssign" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_AugAssign">visit_AugAssign</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_BinOp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_BoolOp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_BoolOp">visit_BoolOp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Break" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Break">visit_Break</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Call" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Call">visit_Call</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ClassDef" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Compare" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Compare">visit_Compare</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Constant" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Continue" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Continue">visit_Continue</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Delete" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Delete">visit_Delete</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Dict" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Dict">visit_Dict</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_DictComp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_DictComp">visit_DictComp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Ellipsis" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Ellipsis">visit_Ellipsis</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Expr" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Expr">visit_Expr</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ExtSlice" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ExtSlice">visit_ExtSlice</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_For" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_For">visit_For</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_FunctionDef" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_GeneratorExp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_GeneratorExp">visit_GeneratorExp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Global" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Global">visit_Global</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_If" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_If">visit_If</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_IfExp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_IfExp">visit_IfExp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Import" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Import">visit_Import</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ImportFrom" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ImportFrom">visit_ImportFrom</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Index" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Index">visit_Index</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_JoinedStr" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_JoinedStr">visit_JoinedStr</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Lambda" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Lambda">visit_Lambda</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_List" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_List">visit_List</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ListComp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_ListComp">visit_ListComp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Module" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Module">visit_Module</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Name" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Name">visit_Name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Pass" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Pass">visit_Pass</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Raise" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Raise">visit_Raise</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Return" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Return">visit_Return</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Set" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Set">visit_Set</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Slice" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Slice">visit_Slice</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Subscript" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Try" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Try">visit_Try</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Tuple" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_UnaryOp" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_UnaryOp">visit_UnaryOp</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_While" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_While">visit_While</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_With" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_With">visit_With</a></code></li>
<li><code><a title="skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Yield" href="#skema.program_analysis.CAST.pythonAST.py_ast_to_cast.PyASTToCAST.visit_Yield">visit_Yield</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>