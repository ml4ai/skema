<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.CAST.python.ts2cast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.CAST.python.ts2cast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os.path
from pathlib import Path
from typing import Any, Dict, List, Union

from tree_sitter import Language, Parser, Node

from skema.program_analysis.CAST2FN.cast import CAST
from skema.program_analysis.CAST2FN.model.cast import (
    Module,
    SourceRef,
    Assignment,
    CASTLiteralValue,
    Var,
    VarType,
    Name,
    Operator,
    AstNode,
    SourceCodeDataType,
    ModelImport,
    FunctionDef,
    Loop,
    Call,
    ModelReturn,
    ModelIf,
    RecordDef,
    Attribute,
    ScalarType,
    StructureType
)

from skema.program_analysis.CAST.python.node_helper import (
    NodeHelper,
    get_first_child_by_type,
    get_children_by_types,
    get_first_child_index,
    get_last_child_index,
    get_control_children,
    get_non_control_children,
    FOR_LOOP_LEFT_TYPES,
    FOR_LOOP_RIGHT_TYPES,
    WHILE_COND_TYPES,
    COMPREHENSION_OPERATORS
)
from skema.program_analysis.CAST.python.util import (
    generate_dummy_source_refs,
    get_op
)
from skema.program_analysis.CAST.fortran.variable_context import VariableContext

from skema.program_analysis.tree_sitter_parsers.build_parsers import INSTALLED_LANGUAGES_FILEPATH


PYTHON_VERSION = &#34;3.10&#34;

class TS2CAST(object):
    def __init__(self, source_file_path: str, from_file = True):
        # from_file flag is used for testing purposes, when we don&#39;t have actual files
        if from_file:
            self.path = Path(source_file_path)
            self.source_file_name = self.path.name
            
            # Python doesn&#39;t have a preprocessing step like fortran
            self.source = self.path.read_text()
        else:
            self.path = &#34;None&#34;
            self.source_file_name = &#34;Temp&#34;
            self.source = source_file_path

        # Run tree-sitter preprocessor output to generate parse tree
        parser = Parser()
        parser.set_language(
            Language(
                INSTALLED_LANGUAGES_FILEPATH,
                &#34;python&#34;
            )
        )

        # Generated FNs by comprehensions/lambdas
        self.generated_fns = []

        # Additional variables used in generation
        self.var_count = 0

        # A dictionary used to keep track of aliases that imports use
        # (like import x as y, or from x import y as z)
        # Used to resolve aliasing in imports
        self.aliases = {}

        # Tree walking structures
        self.variable_context = VariableContext()
        self.node_helper = NodeHelper(self.source, self.source_file_name)

        self.tree = parser.parse(bytes(self.source, &#34;utf8&#34;))

        self.out_cast = self.generate_cast()

    def generate_cast(self) -&gt; List[CAST]:
        &#39;&#39;&#39;Interface for generating CAST.&#39;&#39;&#39;
        module = self.run(self.tree.root_node)
        module.name = self.source_file_name
        return CAST([generate_dummy_source_refs(module)], &#34;Python&#34;) 
        
    def run(self, root) -&gt; List[Module]:
        # In python there&#39;s generally only one module at the top level
        # I believe then we just need to visit the root, which is a module
        # Which can then contain multiple things (Handled at module visitor)
        return self.visit(root)

    # TODO: node helper for ignoring comments

    def check_alias(self, name):
        &#34;&#34;&#34;Given a python string that represents a name,
        this function checks to see if that name is an alias
        for a different name, and returns it if it is indeed an alias.
        Otherwise, the original name is returned.
        &#34;&#34;&#34;
        if name in self.aliases:
            return self.aliases[name]
        else:
            return name

    def visit(self, node: Node):
        # print(f&#34;===Visiting node[{node.type}]===&#34;)
        if node.type == &#34;module&#34;:
            return self.visit_module(node)
        elif node.type == &#34;parenthesized_expression&#34;:
            # Node for &#34;( op )&#34;, extract op
            # The actual op is in the middle of the list of nodes
            return self.visit(node.children[1])
        elif node.type == &#34;expression_statement&#34;:
            return self.visit_expression(node)
        elif node.type == &#34;function_definition&#34;:
            return self.visit_function_def(node)
        elif node.type == &#34;return_statement&#34;:
            return self.visit_return(node)
        elif node.type == &#34;call&#34;:
            return self.visit_call(node)
        elif node.type == &#34;if_statement&#34;:
            return self.visit_if_statement(node)
        elif node.type == &#34;comparison_operator&#34;:
            return self.visit_comparison_op(node)
        elif node.type == &#34;assignment&#34;:
            return self.visit_assignment(node)
        elif node.type == &#34;attribute&#34;:
            return self.visit_attribute(node)
        elif node.type == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node.type == &#34;unary_operator&#34;:
            return self.visit_unary_op(node)
        elif node.type == &#34;binary_operator&#34;:
            return self.visit_binary_op(node)
        elif node.type in [&#34;integer&#34;, &#34;list&#34;]:
            return self.visit_literal(node)
        elif node.type in [&#34;list_pattern&#34;, &#34;pattern_list&#34;, &#34;tuple_pattern&#34;]:
            return self.visit_pattern(node)
        elif node.type == &#34;list_comprehension&#34;:
            return self.visit_list_comprehension(node)
        elif node.type == &#34;dictionary_comprehension&#34;:
            return self.visit_dict_comprehension(node)
        elif node.type == &#34;lambda&#34;:
            return self.visit_lambda(node)
        elif node.type == &#34;pair&#34;:
            return self.visit_pair(node)
        elif node.type == &#34;while_statement&#34;:
            return self.visit_while(node)
        elif node.type == &#34;for_statement&#34;:
            return self.visit_for(node)
        elif node.type == &#34;import_statement&#34;:
            return self.visit_import(node)
        elif node.type == &#34;import_from_statement&#34;:
            return self.visit_import_from(node)
        elif node.type == &#34;yield&#34;:
            return self.visit_yield(node)
        elif node.type == &#34;assert_statement&#34;:
            return self.visit_assert(node)
        else:
            return self._visit_passthrough(node)

    def visit_module(self, node: Node) -&gt; Module:
        # A module is comprised of one or several statements/expressions
        # At the global level
        self.variable_context.push_context()

        body = []
        for child in node.children:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        self.variable_context.pop_context()
        
        return Module(
            name=None,
            body=self.generated_fns + body,
            source_refs = [self.node_helper.get_source_ref(node)]
        )

    def visit_expression(self, node: Node):
        # NOTE: Is there an instance where an &#39;expression statement&#39; node
        # Has more than one child?

        expr_body = []
        for child in node.children:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                expr_body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                expr_body.append(child_cast)

        return expr_body

    def visit_function_def(self, node: Node) -&gt; FunctionDef:
        ref = self.node_helper.get_source_ref(node)

        name_node = get_first_child_by_type(node, &#34;identifier&#34;)
        name = self.visit(name_node)

        # Create new variable context
        self.variable_context.push_context()

        parameters = get_children_by_types(node, [&#34;parameters&#34;])[0]
        parameters = get_non_control_children(parameters)
        
        # The body of the function is stored in a &#39;block&#39; type node
        body = get_children_by_types(node, [&#34;block&#34;])[0].children
        

        func_params = []
        for node in parameters:
            cast = self.visit(node)
            if isinstance(cast, List):
                func_params.extend(cast)
            elif isinstance(cast, AstNode):
                func_params.append(cast)

        func_body = []
        for node in body:
            cast = self.visit(node)
            if isinstance(cast, List):
                func_body.extend(cast)
            elif isinstance(cast, AstNode):
                func_body.append(cast)
            # TODO: Do we need to handle return statements in any special way?

        self.variable_context.pop_context()

        return FunctionDef(
            name=name.val,
            func_args=func_params,
            body=func_body,
            source_refs=[ref]
        )

    def visit_return(self, node: Node) -&gt; ModelReturn:
        ref = self.node_helper.get_source_ref(node)
        ret_val = node.children[1]
        ret_cast = self.visit(ret_val)

        return ModelReturn(value=ret_cast, source_refs=[ref])

    def visit_call(self, node: Node) -&gt; Call:
        ref = self.node_helper.get_source_ref(node)

        func_cast = self.visit(node.children[0])

        func_name = get_func_name_node(func_cast)        

        arg_list = get_first_child_by_type(node, &#34;argument_list&#34;)
        args = get_non_control_children(arg_list)

        func_args = []
        for arg in args:
            cast = get_name_node(self.visit(arg))
            if isinstance(cast, List):
                func_args.extend(cast)
            elif isinstance(cast, AstNode):
                func_args.append(cast)

        if get_name_node(func_cast).name == &#34;range&#34;:
            start_step_value = CASTLiteralValue(
                ScalarType.INTEGER, 
                value=&#34;1&#34;,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1))],
                source_refs=[ref]
            )
            # Add a step value
            if len(func_args) == 2:
                func_args.append(start_step_value)
            # Add a start and step value
            elif len(func_args) == 1:
                func_args.insert(0, start_step_value)
                func_args.append(start_step_value)

        # Function calls only want the &#39;Name&#39; part of the &#39;Var&#39; that the visit returns
        return Call(
            func=func_name, 
            arguments=func_args, 
            source_refs=[ref]
        )

    def visit_comparison_op(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        op = get_op(self.node_helper.get_operator(node.children[1]))
        left, _, right = node.children

        left_cast = get_name_node(self.visit(left))
        right_cast = get_name_node(self.visit(right))

        return Operator(
            op=op, 
            operands=[left_cast, right_cast], 
            source_refs=[ref]
        )

    def visit_if_statement(self, node: Node) -&gt; ModelIf:
        if_condition = self.visit(get_first_child_by_type(node, &#34;comparison_operator&#34;))

        # Get the body of the if true part
        if_true = get_children_by_types(node, [&#34;block&#34;])[0].children

        # Because in tree-sitter the else if, and else aren&#39;t nested, but they&#39;re 
        # in a flat level order, we need to do some arranging of the pieces
        # in order to get the correct CAST nested structure that we use
        # Visit all the alternatives, generate CAST for each one
        # and then join them all together
        alternatives = get_children_by_types(node, [&#34;elif_clause&#34;,&#34;else_clause&#34;])

        if_true_cast = []
        for node in if_true: 
            cast = self.visit(node)
            if isinstance(cast, List):
                if_true_cast.extend(cast)
            elif isinstance(cast, AstNode):
                if_true_cast.append(cast)

        # If we have ts nodes in alternatives, then we&#39;re guaranteed
        # at least an else at the end of the if-statement construct
        # We generate the cast for the final else statement, and then
        # reverse the rest of the if-elses that we have, so we can 
        # create the CAST correctly
        final_else_cast = [] 
        if len(alternatives) &gt; 0:
            final_else = alternatives.pop() 
            alternatives.reverse()
            final_else_body = get_children_by_types(final_else, [&#34;block&#34;])[0].children
            for node in final_else_body:
                cast = self.visit(node)
                if isinstance(cast, List):
                    final_else_cast.extend(cast)
                elif isinstance(cast, AstNode):
                    final_else_cast.append(cast)
        
        # We go through any additional if-else nodes that we may have,
        # generating their ModelIf CAST and appending the tail of the 
        # overall if-else construct, starting with the else at the very end
        # We do this tail appending so that when we finish generating CAST the
        # resulting ModelIf CAST is in the correct order
        alternatives_cast = None
        for ts_node in alternatives:
            assert ts_node.type == &#34;elif_clause&#34;
            temp_cast = self.visit_if_statement(ts_node)
            if alternatives_cast == None:
                temp_cast.orelse = final_else_cast
            else:
                temp_cast.orelse = [alternatives_cast]
            alternatives_cast = temp_cast

        if alternatives_cast == None:
            if_false_cast = final_else_cast 
        else:
            if_false_cast = [alternatives_cast]

        return ModelIf(
            expr=if_condition, 
            body=if_true_cast, 
            orelse=if_false_cast, 
            source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_assignment(self, node: Node) -&gt; Assignment:
        left, _, right = node.children
        ref = self.node_helper.get_source_ref(node)
        
        # For the RHS of an assignment we want the Name CAST node
        # and not the entire Var CAST node if we&#39;re doing an
        # assignment like x = y
        right_cast = get_name_node(self.visit(right))
        
        return Assignment(
            left=self.visit(left),
            right=right_cast,
            source_refs=[ref]
        )

    def visit_unary_op(self, node: Node) -&gt; Operator:
        &#34;&#34;&#34;
            Unary Ops
            OP operand
            where operand is some kind of expression
        &#34;&#34;&#34;
        ref = self.node_helper.get_source_ref(node)
        op = get_op(self.node_helper.get_operator(node.children[0]))
        operand = node.children[1]
        
        if op == &#39;ast.Sub&#39;:
            op = &#39;ast.USub&#39;
        
        # For the operand we need the Name CAST node and
        # not the whole Var CAST node
        # in instances like -x
        operand_cast = get_name_node(self.visit(operand))
        
        if isinstance(operand_cast, Var):
            operand_cast = operand_cast.val

        return Operator(
            op=op, 
            operands=[operand_cast], 
            source_refs=[ref]
        )

    def visit_binary_op(self, node: Node) -&gt; Operator:
        &#34;&#34;&#34;
            Binary Ops
            left OP right
            where left and right can either be operators or literals
        &#34;&#34;&#34;
        ref = self.node_helper.get_source_ref(node)
        op = get_op(self.node_helper.get_operator(node.children[1]))
        left, _, right = node.children

        left_cast = get_name_node(self.visit(left))
        right_cast = get_name_node(self.visit(right))

        return Operator(
            op=op, 
            operands=[left_cast, right_cast], 
            source_refs=[ref]
        )

    def visit_pattern(self, node: Node):
        pattern_cast = []
        for elem in node.children:
            cast = self.visit(elem)
            if isinstance(cast, List):
                pattern_cast.extend(cast)
            elif isinstance(cast, AstNode):
                pattern_cast.append(cast)

        return CASTLiteralValue(value_type=StructureType.TUPLE, value=pattern_cast) 

    def visit_identifier(self, node: Node) -&gt; Var:
        identifier = self.node_helper.get_identifier(node)

        if self.variable_context.is_variable(identifier):
            var_type = self.variable_context.get_type(identifier)
        else:
            var_type = &#34;unknown&#34;
        
        # TODO: Python default values
        default_value = None
        
        value = self.visit_name(node)
        
        return Var(
            val=value,
            type=var_type,
            default_value=default_value,
            source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_literal(self, node: Node) -&gt; Any:
        literal_type = node.type        
        literal_value = self.node_helper.get_identifier(node)
        literal_source_ref = self.node_helper.get_source_ref(node)

        if literal_type == &#34;integer&#34;:
            return CASTLiteralValue(
                value_type=ScalarType.INTEGER,
                value=literal_value,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;float&#34;:
            return CASTLiteralValue(
                value_type=ScalarType.ABSTRACTFLOAT,
                value=literal_value,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1.0))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;true&#34; or literal_type == &#34;false&#34;:
            return CASTLiteralValue(
                value_type=ScalarType.BOOLEAN,
                value=&#34;True&#34; if literal_type == &#34;true&#34; else &#34;False&#34;,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(True))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;list&#34;:
            list_items = []
            for elem in node.children:
                cast = self.visit(elem)
                if isinstance(cast, List):
                    list_items.extend(cast)
                elif isinstance(cast, AstNode):
                    list_items.append(cast)

            return CASTLiteralValue(
                value_type=StructureType.LIST,
                value = list_items,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type([0]))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;tuple&#34;:
            tuple_items = []
            for elem in node.children:
                cast = self.visit(cast)
                if isinstance(cast, List):
                    tuple_items.extend(cast)
                elif isinstance(cast, AstNode):
                    tuple_items.append(cast)

            return CASTLiteralValue(
                value_type=StructureType.LIST,
                value = tuple_items,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type((0)))],
                source_refs=[literal_source_ref]
            )

    def handle_dotted_name(self, import_stmt) -&gt; ModelImport:
        ref = self.node_helper.get_source_ref(import_stmt)
        name = self.node_helper.get_identifier(import_stmt)
        self.visit(import_stmt)

        return name

    def handle_aliased_import(self, import_stmt) -&gt; ModelImport:
        ref = self.node_helper.get_source_ref(import_stmt)
        dot_name = get_children_by_types(import_stmt,[&#34;dotted_name&#34;])[0]
        name = self.handle_dotted_name(dot_name) 
        alias = get_children_by_types(import_stmt, [&#34;identifier&#34;])[0]
        self.visit(alias)

        return (name, self.node_helper.get_identifier(alias)) 

    def visit_import(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        to_ret = []

        names_list = get_children_by_types(node, [&#34;dotted_name&#34;, &#34;aliased_import&#34;])
        for name in names_list:
            if name.type == &#34;dotted_name&#34;:
                resolved_name = self.handle_dotted_name(name)
                to_ret.append(ModelImport(name=resolved_name, alias=None, symbol=None, all=False, source_refs=ref))
            elif name.type == &#34;aliased_import&#34;:
                resolved_name = self.handle_aliased_import(name)
                self.aliases[resolved_name[1]] = resolved_name[0]
                to_ret.append(ModelImport(name=resolved_name[0], alias=resolved_name[1], symbol=None, all=False, source_refs=ref))

        return to_ret

    def visit_import_from(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        to_ret = []

        names_list = get_children_by_types(node, [&#34;dotted_name&#34;, &#34;aliased_import&#34;])
        wild_card = get_children_by_types(node, [&#34;wildcard_import&#34;])
        module_name = self.node_helper.get_identifier(names_list[0])

        # if &#34;wildcard_import&#34; exists then it&#39;ll be in the list
        if len(wild_card) == 1:
            to_ret.append(ModelImport(name=module_name, alias=None, symbol=None, all=True, source_refs=ref))
        else:
            for name in names_list[1:]:
                if name.type == &#34;dotted_name&#34;:
                    resolved_name = self.handle_dotted_name(name) 
                    to_ret.append(ModelImport(name=module_name, alias=None, symbol=resolved_name, all=False, source_refs=ref))
                elif name.type == &#34;aliased_import&#34;:
                    resolved_name = self.handle_aliased_import(name)
                    self.aliases[resolved_name[1]] = resolved_name[0]
                    to_ret.append(ModelImport(name=module_name, alias=resolved_name[1], symbol=resolved_name[0], all=False, source_refs=ref))
            
        return to_ret

    def visit_attribute(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        obj,_,attr = node.children
        obj_cast = self.visit(obj)
        attr_cast = self.visit(attr)

        return Attribute(value= get_name_node(obj_cast), attr=get_name_node(attr_cast), source_refs=ref)

    def handle_for_clause(self, node: Node):
        # Given the &#34;for x in seq&#34; clause of a list comprehension
        # we translate it to a CAST for loop, leaving the actual
        # computation of the body node for the main comprehension handler
        assert node.type == &#34;for_in_clause&#34;
        ref = self.node_helper.get_source_ref(node)

        # NOTE: Assumes the left part with the variable is always the 2nd
        # element in the children and the right part with the actual
        # function call is on the 4th (last) element of the children
        left = self.visit(node.children[1])
        right = self.visit(node.children[-1])

        iterator_name = self.variable_context.generate_iterator()
        stop_cond_name = self.variable_context.generate_stop_condition()
        iter_func = self.get_gromet_function_node(&#34;iter&#34;)
        next_func = self.get_gromet_function_node(&#34;next&#34;)
        
        iter_call = Assignment(
            left = Var(iterator_name, &#34;Iterator&#34;),
            right = Call(
                iter_func,
                arguments=[right]
            )
        )

        next_call = Call(
            next_func,
            arguments=[Var(iterator_name, &#34;Iterator&#34;)]
        )

        next_assign = Assignment(
            left=CASTLiteralValue(
                &#34;Tuple&#34;,
                [
                    left,
                    Var(iterator_name, &#34;Iterator&#34;),
                    Var(stop_cond_name, &#34;Boolean&#34;),
                ],
                source_code_data_type = [&#34;Python&#34;,PYTHON_VERSION,&#34;Tuple&#34;],
                source_refs=ref
            ),
            right=next_call
        )

        loop_pre = []
        loop_pre.append(iter_call)
        loop_pre.append(next_assign)

        loop_expr = Operator(
            source_language=&#34;Python&#34;, 
            interpreter=&#34;Python&#34;, 
            version=PYTHON_VERSION, 
            op=&#34;ast.Eq&#34;, 
            operands=[
                stop_cond_name,
                CASTLiteralValue(
                    ScalarType.BOOLEAN,
                    False,
                    [&#34;Python&#34;, PYTHON_VERSION, &#34;boolean&#34;],
                    source_refs=ref,
                )
            ], 
            source_refs=ref
        )

        loop_body = [None, next_assign]

        return Loop(pre=loop_pre, expr=loop_expr, body=loop_body, post=[])

    def handle_if_clause(self, node: Node):
        assert node.type == &#34;if_clause&#34;
        ref = self.node_helper.get_source_ref(node)
        conditional = get_children_by_types(node, WHILE_COND_TYPES)[0]
        cond_cast = self.visit(conditional)
        
        return ModelIf(expr=cond_cast,body=[],orelse=[],source_refs=ref)

    def construct_loop_construct(self, node: Node):
        return []

    def visit_list_comprehension(self, node: Node) -&gt; Call:
        ref = self.node_helper.get_source_ref(node)

        temp_list_name = self.variable_context.add_variable(
            &#34;list__temp_&#34;, &#34;Unknown&#34;, [ref]
        )

        temp_asg_cast = Assignment(
            left=Var(val=temp_list_name), 
            right=CASTLiteralValue(value=[], value_type=StructureType.LIST),
            source_refs = ref
        )

        append_call = self.get_gromet_function_node(&#34;append&#34;) 
        computation = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]
        computation_cast = self.visit(computation)

        # IDEA: When we see a for_clause we start a new loop construct, and collect if_clauses 
        # as we see them
        clauses = get_children_by_types(node, [&#34;for_in_clause&#34;, &#34;if_clause&#34;])
        loop_start = []
        prev_loop = []
        
        if_start = []
        prev_if = []

        for clause in clauses:
            if clause.type == &#34;for_in_clause&#34;:
                new_loop = self.handle_for_clause(clause)
                if loop_start == []:
                    loop_start = new_loop
                    prev_loop = loop_start
                else:
                    if prev_if == []:
                        prev_loop.body[0] = new_loop
                        prev_loop = new_loop
                    else:
                        prev_loop.body[0] = prev_if
                        prev_if.body = [new_loop]
                        prev_loop = new_loop
                        if_start = []
                        prev_if = []
            elif clause.type == &#34;if_clause&#34;:
                new_if = self.handle_if_clause(clause)
                if if_start == []:
                    if_start = new_if
                    prev_if = if_start
                else:
                    prev_if.body = [new_if]
                    prev_if = new_if
        
        if prev_if == []:
            prev_loop.body[0] = Call(func=Attribute(temp_list_name, append_call), arguments=[computation_cast], source_refs=ref)
        else:
            prev_loop.body[0] = prev_if
            prev_if.body = [Call(func=Attribute(temp_list_name, append_call), arguments=[computation_cast], source_refs=ref)]

        return_cast = ModelReturn(temp_list_name)

        func_name = self.variable_context.generate_func(&#34;%comprehension_list&#34;)
        func_def_cast = FunctionDef(name=func_name, func_args=[], body=[temp_asg_cast,loop_start,return_cast], source_refs=ref)
        
        self.generated_fns.append(func_def_cast)

        return Call(func=func_name, arguments=[], source_refs=ref)

    def visit_pair(self, node: Node):
        key = self.visit(node.children[0])
        value = self.visit(node.children[2])

        return key,value

    def visit_dict_comprehension(self, node: Node) -&gt; Call:
        ref = self.node_helper.get_source_ref(node)

        temp_dict_name = self.variable_context.add_variable(
            &#34;dict__temp_&#34;, &#34;Unknown&#34;, [ref]
        )

        temp_asg_cast = Assignment(
            left=Var(val=temp_dict_name),
            right=CASTLiteralValue(value={}, value_type=StructureType.MAP),
            source_refs = ref
        )

        set_call = self.get_gromet_function_node(&#34;_set&#34;)
        computation = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]
        computation_cast = self.visit(computation)

        # IDEA: When we see a for_clause we start a new loop construct, and collect if_clauses 
        # as we see them
        clauses = get_children_by_types(node, [&#34;for_in_clause&#34;, &#34;if_clause&#34;])
        loop_start = []
        prev_loop = []
        
        if_start = []
        prev_if = []

        for clause in clauses:
            if clause.type == &#34;for_in_clause&#34;:
                new_loop = self.handle_for_clause(clause)
                if loop_start == []:
                    loop_start = new_loop
                    prev_loop = loop_start
                else:
                    if prev_if == []:
                        prev_loop.body[0] = new_loop
                        prev_loop = new_loop
                    else:
                        prev_loop.body[0] = prev_if
                        prev_if.body = [new_loop]
                        prev_loop = new_loop
                        if_start = []
                        prev_if = []
            elif clause.type == &#34;if_clause&#34;:
                new_if = self.handle_if_clause(clause)
                if if_start == []:
                    if_start = new_if
                    prev_if = if_start
                else:
                    prev_if.body = [new_if]
                    prev_if = new_if
        
        if prev_if == []:
            prev_loop.body[0] = Assignment(left=Var(val=temp_dict_name), right=Call(func=set_call, arguments=[temp_dict_name, computation_cast[0].val, computation_cast[1]], source_refs=ref), source_refs=ref)
        else:
            prev_loop.body[0] = prev_if
            prev_loop = Assignment(left=Var(val=temp_dict_name), right=Call(func=set_call, arguments=[temp_dict_name, computation_cast[0].val, computation_cast[1]], source_refs=ref), source_refs=ref)

        return_cast = ModelReturn(temp_dict_name)

        func_name = self.variable_context.generate_func(&#34;%comprehension_dict&#34;)
        func_def_cast = FunctionDef(name=func_name, func_args=[], body=[temp_asg_cast,loop_start,return_cast], source_refs=ref)

        self.generated_fns.append(func_def_cast)

        return Call(func=func_name, arguments=[], source_refs=ref)
    

    def visit_lambda(self, node: Node) -&gt; Call:
        # TODO: we have to determine how to grab the variables that are being
        # used in the lambda that aren&#39;t part of the lambda&#39;s arguments
        ref=self.node_helper.get_source_ref(node)
        params = get_children_by_types(node, [&#34;lambda_parameters&#34;])[0] 
        body = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]

        parameters = []
        for param in params.children:
            cast = self.visit(param)
            if isinstance(cast, list):
                parameters.extend(cast)
            else:
                parameters.append(cast)

        body_cast = self.visit(body)
        func_body = body_cast 

        func_name = self.variable_context.generate_func(&#34;%lambda&#34;)
        func_def_cast = FunctionDef(name=func_name, func_args=parameters, body=[ModelReturn(value=func_body)], source_refs=ref)

        self.generated_fns.append(func_def_cast)
        
        # Collect all the Name node instances to use as arguments for the lambda call
        args = [par.val if isinstance(par, Var) else par for par in parameters]

        return Call(func=func_name, arguments=args, source_refs=ref)

    def visit_while(self, node: Node) -&gt; Loop:
        ref = self.node_helper.get_source_ref(node)
        
        # Push a variable context since a loop 
        # can create variables that only it can see
        self.variable_context.push_context()

        loop_cond_node = get_children_by_types(node, WHILE_COND_TYPES)[0]
        loop_body_node = get_children_by_types(node, [&#34;block&#34;])[0].children

        loop_cond = self.visit(loop_cond_node)

        loop_body = []
        for node in loop_body_node:
            cast = self.visit(node)
            if isinstance(cast, List):
                loop_body.extend(cast)
            elif isinstance(cast, AstNode):
                loop_body.append(cast)

        self.variable_context.pop_context()

        return Loop(
            pre=[],
            expr=loop_cond,
            body=loop_body,
            post=[],
            source_refs = ref
        )

    def visit_for(self, node: Node) -&gt; Loop:
        ref = self.node_helper.get_source_ref(node)

        # Pre: left, right        
        loop_cond_left = get_children_by_types(node, FOR_LOOP_LEFT_TYPES)[0]
        loop_cond_right = get_children_by_types(node, FOR_LOOP_RIGHT_TYPES)[-1]

        # Construct pre and expr value using left and right as needed
        # need calls to &#34;_Iterator&#34;
        
        self.variable_context.push_context()
        iterator_name = self.variable_context.generate_iterator() 
        stop_cond_name = self.variable_context.generate_stop_condition()
        iter_func = self.get_gromet_function_node(&#34;iter&#34;)
        next_func = self.get_gromet_function_node(&#34;next&#34;)

        loop_cond_left_cast = self.visit(loop_cond_left)
        loop_cond_right_cast = self.visit(loop_cond_right)

        loop_pre = []
        loop_pre.append(
            Assignment(
                left = Var(iterator_name, &#34;Iterator&#34;),
                right = Call(
                    iter_func,
                    arguments=[loop_cond_right_cast]
                )
            )
        )

        loop_pre.append(
            Assignment(
                left=CASTLiteralValue(
                    &#34;Tuple&#34;,
                    [
                        loop_cond_left_cast,
                        Var(iterator_name, &#34;Iterator&#34;),
                        Var(stop_cond_name, &#34;Boolean&#34;),
                    ],
                    source_code_data_type = [&#34;Python&#34;,PYTHON_VERSION,&#34;Tuple&#34;],
                    source_refs=ref
                ),
                right=Call(
                    next_func,
                    arguments=[Var(iterator_name, &#34;Iterator&#34;)],
                ),
            )
        )

        loop_expr = Operator(
            source_language=&#34;Python&#34;, 
            interpreter=&#34;Python&#34;, 
            version=PYTHON_VERSION, 
            op=&#34;ast.Eq&#34;, 
            operands=[
                stop_cond_name,
                CASTLiteralValue(
                    ScalarType.BOOLEAN,
                    False,
                    [&#34;Python&#34;, PYTHON_VERSION, &#34;boolean&#34;],
                    source_refs=ref,
                )
            ], 
            source_refs=ref
        )

        loop_body_node = get_children_by_types(node, [&#34;block&#34;])[0].children
        loop_body = []
        for node in loop_body_node:
            cast = self.visit(node)
            if isinstance(cast, List):
                loop_body.extend(cast)
            elif isinstance(cast, AstNode):
                loop_body.append(cast)

        # Insert an additional call to &#39;next&#39; at the end of the loop body,
        # to facilitate looping in GroMEt 
        loop_body.append(
            Assignment(
                left=CASTLiteralValue(
                    &#34;Tuple&#34;,
                    [
                        loop_cond_left_cast,
                        Var(iterator_name, &#34;Iterator&#34;),
                        Var(stop_cond_name, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_func,
                    arguments=[Var(iterator_name, &#34;Iterator&#34;)],
                ),
            )
        )

        self.variable_context.pop_context()
        return Loop(
            pre=loop_pre,
            expr=loop_expr,
            body=loop_body,
            post=[],
            source_refs = ref
        )


    def visit_name(self, node):
        # First, we will check if this name is already defined, and if it is return the name node generated previously
        # NOTE: the call to check_alias is a crucial change, to resolve aliasing
        # need to make sure nothing breaks
        identifier = self.check_alias(self.node_helper.get_identifier(node))
        if self.variable_context.is_variable(identifier):
            return self.variable_context.get_node(identifier)

        return self.variable_context.add_variable(
            identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
        )

    def _visit_passthrough(self, node):
        if len(node.children) == 0:
            return None

        for child in node.children:
            child_cast = self.visit(child)
            if child_cast:
                return child_cast

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        # Idealy, we would be able to create a dummy node and just call the name visitor.
        # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
        if self.variable_context.is_variable(func_name):
            return self.variable_context.get_node(func_name)

        return self.variable_context.add_variable(func_name, &#34;function&#34;, None)
            
    def visit_yield(self, node):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = self.node_helper.get_source_ref(node)
        return [
            CASTLiteralValue(
                StructureType.LIST,
                &#34;YieldNotImplemented&#34;,
                source_code_data_type,
                ref
            )   
        ]

    def visit_assert(self, node):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = self.node_helper.get_source_ref(node)
        return [
            CASTLiteralValue(
                StructureType.LIST,
                &#34;AssertNotImplemented&#34;,
                source_code_data_type,
                ref
            )   
        ]


def get_name_node(node):
    # Given a CAST node, if it&#39;s type Var, then we extract the name node out of it
    # If it&#39;s anything else, then the node just gets returned normally
    cur_node = node
    if isinstance(node, list):
        cur_node = node[0]
    if isinstance(cur_node, Attribute):
        return get_name_node(cur_node.attr)
    if isinstance(cur_node, Var):
        return cur_node.val
    else:
        return node

def get_func_name_node(node):
    # Given a CAST node, we attempt to extract the appropriate name element
    # from it. 
    cur_node = node
    if isinstance(cur_node, Var):
        return cur_node.val
    else:
        return cur_node </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="skema.program_analysis.CAST.python.ts2cast.get_func_name_node"><code class="name flex">
<span>def <span class="ident">get_func_name_node</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_func_name_node(node):
    # Given a CAST node, we attempt to extract the appropriate name element
    # from it. 
    cur_node = node
    if isinstance(cur_node, Var):
        return cur_node.val
    else:
        return cur_node </code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.get_name_node"><code class="name flex">
<span>def <span class="ident">get_name_node</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name_node(node):
    # Given a CAST node, if it&#39;s type Var, then we extract the name node out of it
    # If it&#39;s anything else, then the node just gets returned normally
    cur_node = node
    if isinstance(node, list):
        cur_node = node[0]
    if isinstance(cur_node, Attribute):
        return get_name_node(cur_node.attr)
    if isinstance(cur_node, Var):
        return cur_node.val
    else:
        return node</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST"><code class="flex name class">
<span>class <span class="ident">TS2CAST</span></span>
<span>(</span><span>source_file_path: str, from_file=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TS2CAST(object):
    def __init__(self, source_file_path: str, from_file = True):
        # from_file flag is used for testing purposes, when we don&#39;t have actual files
        if from_file:
            self.path = Path(source_file_path)
            self.source_file_name = self.path.name
            
            # Python doesn&#39;t have a preprocessing step like fortran
            self.source = self.path.read_text()
        else:
            self.path = &#34;None&#34;
            self.source_file_name = &#34;Temp&#34;
            self.source = source_file_path

        # Run tree-sitter preprocessor output to generate parse tree
        parser = Parser()
        parser.set_language(
            Language(
                INSTALLED_LANGUAGES_FILEPATH,
                &#34;python&#34;
            )
        )

        # Generated FNs by comprehensions/lambdas
        self.generated_fns = []

        # Additional variables used in generation
        self.var_count = 0

        # A dictionary used to keep track of aliases that imports use
        # (like import x as y, or from x import y as z)
        # Used to resolve aliasing in imports
        self.aliases = {}

        # Tree walking structures
        self.variable_context = VariableContext()
        self.node_helper = NodeHelper(self.source, self.source_file_name)

        self.tree = parser.parse(bytes(self.source, &#34;utf8&#34;))

        self.out_cast = self.generate_cast()

    def generate_cast(self) -&gt; List[CAST]:
        &#39;&#39;&#39;Interface for generating CAST.&#39;&#39;&#39;
        module = self.run(self.tree.root_node)
        module.name = self.source_file_name
        return CAST([generate_dummy_source_refs(module)], &#34;Python&#34;) 
        
    def run(self, root) -&gt; List[Module]:
        # In python there&#39;s generally only one module at the top level
        # I believe then we just need to visit the root, which is a module
        # Which can then contain multiple things (Handled at module visitor)
        return self.visit(root)

    # TODO: node helper for ignoring comments

    def check_alias(self, name):
        &#34;&#34;&#34;Given a python string that represents a name,
        this function checks to see if that name is an alias
        for a different name, and returns it if it is indeed an alias.
        Otherwise, the original name is returned.
        &#34;&#34;&#34;
        if name in self.aliases:
            return self.aliases[name]
        else:
            return name

    def visit(self, node: Node):
        # print(f&#34;===Visiting node[{node.type}]===&#34;)
        if node.type == &#34;module&#34;:
            return self.visit_module(node)
        elif node.type == &#34;parenthesized_expression&#34;:
            # Node for &#34;( op )&#34;, extract op
            # The actual op is in the middle of the list of nodes
            return self.visit(node.children[1])
        elif node.type == &#34;expression_statement&#34;:
            return self.visit_expression(node)
        elif node.type == &#34;function_definition&#34;:
            return self.visit_function_def(node)
        elif node.type == &#34;return_statement&#34;:
            return self.visit_return(node)
        elif node.type == &#34;call&#34;:
            return self.visit_call(node)
        elif node.type == &#34;if_statement&#34;:
            return self.visit_if_statement(node)
        elif node.type == &#34;comparison_operator&#34;:
            return self.visit_comparison_op(node)
        elif node.type == &#34;assignment&#34;:
            return self.visit_assignment(node)
        elif node.type == &#34;attribute&#34;:
            return self.visit_attribute(node)
        elif node.type == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node.type == &#34;unary_operator&#34;:
            return self.visit_unary_op(node)
        elif node.type == &#34;binary_operator&#34;:
            return self.visit_binary_op(node)
        elif node.type in [&#34;integer&#34;, &#34;list&#34;]:
            return self.visit_literal(node)
        elif node.type in [&#34;list_pattern&#34;, &#34;pattern_list&#34;, &#34;tuple_pattern&#34;]:
            return self.visit_pattern(node)
        elif node.type == &#34;list_comprehension&#34;:
            return self.visit_list_comprehension(node)
        elif node.type == &#34;dictionary_comprehension&#34;:
            return self.visit_dict_comprehension(node)
        elif node.type == &#34;lambda&#34;:
            return self.visit_lambda(node)
        elif node.type == &#34;pair&#34;:
            return self.visit_pair(node)
        elif node.type == &#34;while_statement&#34;:
            return self.visit_while(node)
        elif node.type == &#34;for_statement&#34;:
            return self.visit_for(node)
        elif node.type == &#34;import_statement&#34;:
            return self.visit_import(node)
        elif node.type == &#34;import_from_statement&#34;:
            return self.visit_import_from(node)
        elif node.type == &#34;yield&#34;:
            return self.visit_yield(node)
        elif node.type == &#34;assert_statement&#34;:
            return self.visit_assert(node)
        else:
            return self._visit_passthrough(node)

    def visit_module(self, node: Node) -&gt; Module:
        # A module is comprised of one or several statements/expressions
        # At the global level
        self.variable_context.push_context()

        body = []
        for child in node.children:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        self.variable_context.pop_context()
        
        return Module(
            name=None,
            body=self.generated_fns + body,
            source_refs = [self.node_helper.get_source_ref(node)]
        )

    def visit_expression(self, node: Node):
        # NOTE: Is there an instance where an &#39;expression statement&#39; node
        # Has more than one child?

        expr_body = []
        for child in node.children:
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                expr_body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                expr_body.append(child_cast)

        return expr_body

    def visit_function_def(self, node: Node) -&gt; FunctionDef:
        ref = self.node_helper.get_source_ref(node)

        name_node = get_first_child_by_type(node, &#34;identifier&#34;)
        name = self.visit(name_node)

        # Create new variable context
        self.variable_context.push_context()

        parameters = get_children_by_types(node, [&#34;parameters&#34;])[0]
        parameters = get_non_control_children(parameters)
        
        # The body of the function is stored in a &#39;block&#39; type node
        body = get_children_by_types(node, [&#34;block&#34;])[0].children
        

        func_params = []
        for node in parameters:
            cast = self.visit(node)
            if isinstance(cast, List):
                func_params.extend(cast)
            elif isinstance(cast, AstNode):
                func_params.append(cast)

        func_body = []
        for node in body:
            cast = self.visit(node)
            if isinstance(cast, List):
                func_body.extend(cast)
            elif isinstance(cast, AstNode):
                func_body.append(cast)
            # TODO: Do we need to handle return statements in any special way?

        self.variable_context.pop_context()

        return FunctionDef(
            name=name.val,
            func_args=func_params,
            body=func_body,
            source_refs=[ref]
        )

    def visit_return(self, node: Node) -&gt; ModelReturn:
        ref = self.node_helper.get_source_ref(node)
        ret_val = node.children[1]
        ret_cast = self.visit(ret_val)

        return ModelReturn(value=ret_cast, source_refs=[ref])

    def visit_call(self, node: Node) -&gt; Call:
        ref = self.node_helper.get_source_ref(node)

        func_cast = self.visit(node.children[0])

        func_name = get_func_name_node(func_cast)        

        arg_list = get_first_child_by_type(node, &#34;argument_list&#34;)
        args = get_non_control_children(arg_list)

        func_args = []
        for arg in args:
            cast = get_name_node(self.visit(arg))
            if isinstance(cast, List):
                func_args.extend(cast)
            elif isinstance(cast, AstNode):
                func_args.append(cast)

        if get_name_node(func_cast).name == &#34;range&#34;:
            start_step_value = CASTLiteralValue(
                ScalarType.INTEGER, 
                value=&#34;1&#34;,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1))],
                source_refs=[ref]
            )
            # Add a step value
            if len(func_args) == 2:
                func_args.append(start_step_value)
            # Add a start and step value
            elif len(func_args) == 1:
                func_args.insert(0, start_step_value)
                func_args.append(start_step_value)

        # Function calls only want the &#39;Name&#39; part of the &#39;Var&#39; that the visit returns
        return Call(
            func=func_name, 
            arguments=func_args, 
            source_refs=[ref]
        )

    def visit_comparison_op(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        op = get_op(self.node_helper.get_operator(node.children[1]))
        left, _, right = node.children

        left_cast = get_name_node(self.visit(left))
        right_cast = get_name_node(self.visit(right))

        return Operator(
            op=op, 
            operands=[left_cast, right_cast], 
            source_refs=[ref]
        )

    def visit_if_statement(self, node: Node) -&gt; ModelIf:
        if_condition = self.visit(get_first_child_by_type(node, &#34;comparison_operator&#34;))

        # Get the body of the if true part
        if_true = get_children_by_types(node, [&#34;block&#34;])[0].children

        # Because in tree-sitter the else if, and else aren&#39;t nested, but they&#39;re 
        # in a flat level order, we need to do some arranging of the pieces
        # in order to get the correct CAST nested structure that we use
        # Visit all the alternatives, generate CAST for each one
        # and then join them all together
        alternatives = get_children_by_types(node, [&#34;elif_clause&#34;,&#34;else_clause&#34;])

        if_true_cast = []
        for node in if_true: 
            cast = self.visit(node)
            if isinstance(cast, List):
                if_true_cast.extend(cast)
            elif isinstance(cast, AstNode):
                if_true_cast.append(cast)

        # If we have ts nodes in alternatives, then we&#39;re guaranteed
        # at least an else at the end of the if-statement construct
        # We generate the cast for the final else statement, and then
        # reverse the rest of the if-elses that we have, so we can 
        # create the CAST correctly
        final_else_cast = [] 
        if len(alternatives) &gt; 0:
            final_else = alternatives.pop() 
            alternatives.reverse()
            final_else_body = get_children_by_types(final_else, [&#34;block&#34;])[0].children
            for node in final_else_body:
                cast = self.visit(node)
                if isinstance(cast, List):
                    final_else_cast.extend(cast)
                elif isinstance(cast, AstNode):
                    final_else_cast.append(cast)
        
        # We go through any additional if-else nodes that we may have,
        # generating their ModelIf CAST and appending the tail of the 
        # overall if-else construct, starting with the else at the very end
        # We do this tail appending so that when we finish generating CAST the
        # resulting ModelIf CAST is in the correct order
        alternatives_cast = None
        for ts_node in alternatives:
            assert ts_node.type == &#34;elif_clause&#34;
            temp_cast = self.visit_if_statement(ts_node)
            if alternatives_cast == None:
                temp_cast.orelse = final_else_cast
            else:
                temp_cast.orelse = [alternatives_cast]
            alternatives_cast = temp_cast

        if alternatives_cast == None:
            if_false_cast = final_else_cast 
        else:
            if_false_cast = [alternatives_cast]

        return ModelIf(
            expr=if_condition, 
            body=if_true_cast, 
            orelse=if_false_cast, 
            source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_assignment(self, node: Node) -&gt; Assignment:
        left, _, right = node.children
        ref = self.node_helper.get_source_ref(node)
        
        # For the RHS of an assignment we want the Name CAST node
        # and not the entire Var CAST node if we&#39;re doing an
        # assignment like x = y
        right_cast = get_name_node(self.visit(right))
        
        return Assignment(
            left=self.visit(left),
            right=right_cast,
            source_refs=[ref]
        )

    def visit_unary_op(self, node: Node) -&gt; Operator:
        &#34;&#34;&#34;
            Unary Ops
            OP operand
            where operand is some kind of expression
        &#34;&#34;&#34;
        ref = self.node_helper.get_source_ref(node)
        op = get_op(self.node_helper.get_operator(node.children[0]))
        operand = node.children[1]
        
        if op == &#39;ast.Sub&#39;:
            op = &#39;ast.USub&#39;
        
        # For the operand we need the Name CAST node and
        # not the whole Var CAST node
        # in instances like -x
        operand_cast = get_name_node(self.visit(operand))
        
        if isinstance(operand_cast, Var):
            operand_cast = operand_cast.val

        return Operator(
            op=op, 
            operands=[operand_cast], 
            source_refs=[ref]
        )

    def visit_binary_op(self, node: Node) -&gt; Operator:
        &#34;&#34;&#34;
            Binary Ops
            left OP right
            where left and right can either be operators or literals
        &#34;&#34;&#34;
        ref = self.node_helper.get_source_ref(node)
        op = get_op(self.node_helper.get_operator(node.children[1]))
        left, _, right = node.children

        left_cast = get_name_node(self.visit(left))
        right_cast = get_name_node(self.visit(right))

        return Operator(
            op=op, 
            operands=[left_cast, right_cast], 
            source_refs=[ref]
        )

    def visit_pattern(self, node: Node):
        pattern_cast = []
        for elem in node.children:
            cast = self.visit(elem)
            if isinstance(cast, List):
                pattern_cast.extend(cast)
            elif isinstance(cast, AstNode):
                pattern_cast.append(cast)

        return CASTLiteralValue(value_type=StructureType.TUPLE, value=pattern_cast) 

    def visit_identifier(self, node: Node) -&gt; Var:
        identifier = self.node_helper.get_identifier(node)

        if self.variable_context.is_variable(identifier):
            var_type = self.variable_context.get_type(identifier)
        else:
            var_type = &#34;unknown&#34;
        
        # TODO: Python default values
        default_value = None
        
        value = self.visit_name(node)
        
        return Var(
            val=value,
            type=var_type,
            default_value=default_value,
            source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_literal(self, node: Node) -&gt; Any:
        literal_type = node.type        
        literal_value = self.node_helper.get_identifier(node)
        literal_source_ref = self.node_helper.get_source_ref(node)

        if literal_type == &#34;integer&#34;:
            return CASTLiteralValue(
                value_type=ScalarType.INTEGER,
                value=literal_value,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;float&#34;:
            return CASTLiteralValue(
                value_type=ScalarType.ABSTRACTFLOAT,
                value=literal_value,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1.0))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;true&#34; or literal_type == &#34;false&#34;:
            return CASTLiteralValue(
                value_type=ScalarType.BOOLEAN,
                value=&#34;True&#34; if literal_type == &#34;true&#34; else &#34;False&#34;,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(True))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;list&#34;:
            list_items = []
            for elem in node.children:
                cast = self.visit(elem)
                if isinstance(cast, List):
                    list_items.extend(cast)
                elif isinstance(cast, AstNode):
                    list_items.append(cast)

            return CASTLiteralValue(
                value_type=StructureType.LIST,
                value = list_items,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type([0]))],
                source_refs=[literal_source_ref]
            )
        elif literal_type == &#34;tuple&#34;:
            tuple_items = []
            for elem in node.children:
                cast = self.visit(cast)
                if isinstance(cast, List):
                    tuple_items.extend(cast)
                elif isinstance(cast, AstNode):
                    tuple_items.append(cast)

            return CASTLiteralValue(
                value_type=StructureType.LIST,
                value = tuple_items,
                source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type((0)))],
                source_refs=[literal_source_ref]
            )

    def handle_dotted_name(self, import_stmt) -&gt; ModelImport:
        ref = self.node_helper.get_source_ref(import_stmt)
        name = self.node_helper.get_identifier(import_stmt)
        self.visit(import_stmt)

        return name

    def handle_aliased_import(self, import_stmt) -&gt; ModelImport:
        ref = self.node_helper.get_source_ref(import_stmt)
        dot_name = get_children_by_types(import_stmt,[&#34;dotted_name&#34;])[0]
        name = self.handle_dotted_name(dot_name) 
        alias = get_children_by_types(import_stmt, [&#34;identifier&#34;])[0]
        self.visit(alias)

        return (name, self.node_helper.get_identifier(alias)) 

    def visit_import(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        to_ret = []

        names_list = get_children_by_types(node, [&#34;dotted_name&#34;, &#34;aliased_import&#34;])
        for name in names_list:
            if name.type == &#34;dotted_name&#34;:
                resolved_name = self.handle_dotted_name(name)
                to_ret.append(ModelImport(name=resolved_name, alias=None, symbol=None, all=False, source_refs=ref))
            elif name.type == &#34;aliased_import&#34;:
                resolved_name = self.handle_aliased_import(name)
                self.aliases[resolved_name[1]] = resolved_name[0]
                to_ret.append(ModelImport(name=resolved_name[0], alias=resolved_name[1], symbol=None, all=False, source_refs=ref))

        return to_ret

    def visit_import_from(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        to_ret = []

        names_list = get_children_by_types(node, [&#34;dotted_name&#34;, &#34;aliased_import&#34;])
        wild_card = get_children_by_types(node, [&#34;wildcard_import&#34;])
        module_name = self.node_helper.get_identifier(names_list[0])

        # if &#34;wildcard_import&#34; exists then it&#39;ll be in the list
        if len(wild_card) == 1:
            to_ret.append(ModelImport(name=module_name, alias=None, symbol=None, all=True, source_refs=ref))
        else:
            for name in names_list[1:]:
                if name.type == &#34;dotted_name&#34;:
                    resolved_name = self.handle_dotted_name(name) 
                    to_ret.append(ModelImport(name=module_name, alias=None, symbol=resolved_name, all=False, source_refs=ref))
                elif name.type == &#34;aliased_import&#34;:
                    resolved_name = self.handle_aliased_import(name)
                    self.aliases[resolved_name[1]] = resolved_name[0]
                    to_ret.append(ModelImport(name=module_name, alias=resolved_name[1], symbol=resolved_name[0], all=False, source_refs=ref))
            
        return to_ret

    def visit_attribute(self, node: Node):
        ref = self.node_helper.get_source_ref(node)
        obj,_,attr = node.children
        obj_cast = self.visit(obj)
        attr_cast = self.visit(attr)

        return Attribute(value= get_name_node(obj_cast), attr=get_name_node(attr_cast), source_refs=ref)

    def handle_for_clause(self, node: Node):
        # Given the &#34;for x in seq&#34; clause of a list comprehension
        # we translate it to a CAST for loop, leaving the actual
        # computation of the body node for the main comprehension handler
        assert node.type == &#34;for_in_clause&#34;
        ref = self.node_helper.get_source_ref(node)

        # NOTE: Assumes the left part with the variable is always the 2nd
        # element in the children and the right part with the actual
        # function call is on the 4th (last) element of the children
        left = self.visit(node.children[1])
        right = self.visit(node.children[-1])

        iterator_name = self.variable_context.generate_iterator()
        stop_cond_name = self.variable_context.generate_stop_condition()
        iter_func = self.get_gromet_function_node(&#34;iter&#34;)
        next_func = self.get_gromet_function_node(&#34;next&#34;)
        
        iter_call = Assignment(
            left = Var(iterator_name, &#34;Iterator&#34;),
            right = Call(
                iter_func,
                arguments=[right]
            )
        )

        next_call = Call(
            next_func,
            arguments=[Var(iterator_name, &#34;Iterator&#34;)]
        )

        next_assign = Assignment(
            left=CASTLiteralValue(
                &#34;Tuple&#34;,
                [
                    left,
                    Var(iterator_name, &#34;Iterator&#34;),
                    Var(stop_cond_name, &#34;Boolean&#34;),
                ],
                source_code_data_type = [&#34;Python&#34;,PYTHON_VERSION,&#34;Tuple&#34;],
                source_refs=ref
            ),
            right=next_call
        )

        loop_pre = []
        loop_pre.append(iter_call)
        loop_pre.append(next_assign)

        loop_expr = Operator(
            source_language=&#34;Python&#34;, 
            interpreter=&#34;Python&#34;, 
            version=PYTHON_VERSION, 
            op=&#34;ast.Eq&#34;, 
            operands=[
                stop_cond_name,
                CASTLiteralValue(
                    ScalarType.BOOLEAN,
                    False,
                    [&#34;Python&#34;, PYTHON_VERSION, &#34;boolean&#34;],
                    source_refs=ref,
                )
            ], 
            source_refs=ref
        )

        loop_body = [None, next_assign]

        return Loop(pre=loop_pre, expr=loop_expr, body=loop_body, post=[])

    def handle_if_clause(self, node: Node):
        assert node.type == &#34;if_clause&#34;
        ref = self.node_helper.get_source_ref(node)
        conditional = get_children_by_types(node, WHILE_COND_TYPES)[0]
        cond_cast = self.visit(conditional)
        
        return ModelIf(expr=cond_cast,body=[],orelse=[],source_refs=ref)

    def construct_loop_construct(self, node: Node):
        return []

    def visit_list_comprehension(self, node: Node) -&gt; Call:
        ref = self.node_helper.get_source_ref(node)

        temp_list_name = self.variable_context.add_variable(
            &#34;list__temp_&#34;, &#34;Unknown&#34;, [ref]
        )

        temp_asg_cast = Assignment(
            left=Var(val=temp_list_name), 
            right=CASTLiteralValue(value=[], value_type=StructureType.LIST),
            source_refs = ref
        )

        append_call = self.get_gromet_function_node(&#34;append&#34;) 
        computation = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]
        computation_cast = self.visit(computation)

        # IDEA: When we see a for_clause we start a new loop construct, and collect if_clauses 
        # as we see them
        clauses = get_children_by_types(node, [&#34;for_in_clause&#34;, &#34;if_clause&#34;])
        loop_start = []
        prev_loop = []
        
        if_start = []
        prev_if = []

        for clause in clauses:
            if clause.type == &#34;for_in_clause&#34;:
                new_loop = self.handle_for_clause(clause)
                if loop_start == []:
                    loop_start = new_loop
                    prev_loop = loop_start
                else:
                    if prev_if == []:
                        prev_loop.body[0] = new_loop
                        prev_loop = new_loop
                    else:
                        prev_loop.body[0] = prev_if
                        prev_if.body = [new_loop]
                        prev_loop = new_loop
                        if_start = []
                        prev_if = []
            elif clause.type == &#34;if_clause&#34;:
                new_if = self.handle_if_clause(clause)
                if if_start == []:
                    if_start = new_if
                    prev_if = if_start
                else:
                    prev_if.body = [new_if]
                    prev_if = new_if
        
        if prev_if == []:
            prev_loop.body[0] = Call(func=Attribute(temp_list_name, append_call), arguments=[computation_cast], source_refs=ref)
        else:
            prev_loop.body[0] = prev_if
            prev_if.body = [Call(func=Attribute(temp_list_name, append_call), arguments=[computation_cast], source_refs=ref)]

        return_cast = ModelReturn(temp_list_name)

        func_name = self.variable_context.generate_func(&#34;%comprehension_list&#34;)
        func_def_cast = FunctionDef(name=func_name, func_args=[], body=[temp_asg_cast,loop_start,return_cast], source_refs=ref)
        
        self.generated_fns.append(func_def_cast)

        return Call(func=func_name, arguments=[], source_refs=ref)

    def visit_pair(self, node: Node):
        key = self.visit(node.children[0])
        value = self.visit(node.children[2])

        return key,value

    def visit_dict_comprehension(self, node: Node) -&gt; Call:
        ref = self.node_helper.get_source_ref(node)

        temp_dict_name = self.variable_context.add_variable(
            &#34;dict__temp_&#34;, &#34;Unknown&#34;, [ref]
        )

        temp_asg_cast = Assignment(
            left=Var(val=temp_dict_name),
            right=CASTLiteralValue(value={}, value_type=StructureType.MAP),
            source_refs = ref
        )

        set_call = self.get_gromet_function_node(&#34;_set&#34;)
        computation = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]
        computation_cast = self.visit(computation)

        # IDEA: When we see a for_clause we start a new loop construct, and collect if_clauses 
        # as we see them
        clauses = get_children_by_types(node, [&#34;for_in_clause&#34;, &#34;if_clause&#34;])
        loop_start = []
        prev_loop = []
        
        if_start = []
        prev_if = []

        for clause in clauses:
            if clause.type == &#34;for_in_clause&#34;:
                new_loop = self.handle_for_clause(clause)
                if loop_start == []:
                    loop_start = new_loop
                    prev_loop = loop_start
                else:
                    if prev_if == []:
                        prev_loop.body[0] = new_loop
                        prev_loop = new_loop
                    else:
                        prev_loop.body[0] = prev_if
                        prev_if.body = [new_loop]
                        prev_loop = new_loop
                        if_start = []
                        prev_if = []
            elif clause.type == &#34;if_clause&#34;:
                new_if = self.handle_if_clause(clause)
                if if_start == []:
                    if_start = new_if
                    prev_if = if_start
                else:
                    prev_if.body = [new_if]
                    prev_if = new_if
        
        if prev_if == []:
            prev_loop.body[0] = Assignment(left=Var(val=temp_dict_name), right=Call(func=set_call, arguments=[temp_dict_name, computation_cast[0].val, computation_cast[1]], source_refs=ref), source_refs=ref)
        else:
            prev_loop.body[0] = prev_if
            prev_loop = Assignment(left=Var(val=temp_dict_name), right=Call(func=set_call, arguments=[temp_dict_name, computation_cast[0].val, computation_cast[1]], source_refs=ref), source_refs=ref)

        return_cast = ModelReturn(temp_dict_name)

        func_name = self.variable_context.generate_func(&#34;%comprehension_dict&#34;)
        func_def_cast = FunctionDef(name=func_name, func_args=[], body=[temp_asg_cast,loop_start,return_cast], source_refs=ref)

        self.generated_fns.append(func_def_cast)

        return Call(func=func_name, arguments=[], source_refs=ref)
    

    def visit_lambda(self, node: Node) -&gt; Call:
        # TODO: we have to determine how to grab the variables that are being
        # used in the lambda that aren&#39;t part of the lambda&#39;s arguments
        ref=self.node_helper.get_source_ref(node)
        params = get_children_by_types(node, [&#34;lambda_parameters&#34;])[0] 
        body = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]

        parameters = []
        for param in params.children:
            cast = self.visit(param)
            if isinstance(cast, list):
                parameters.extend(cast)
            else:
                parameters.append(cast)

        body_cast = self.visit(body)
        func_body = body_cast 

        func_name = self.variable_context.generate_func(&#34;%lambda&#34;)
        func_def_cast = FunctionDef(name=func_name, func_args=parameters, body=[ModelReturn(value=func_body)], source_refs=ref)

        self.generated_fns.append(func_def_cast)
        
        # Collect all the Name node instances to use as arguments for the lambda call
        args = [par.val if isinstance(par, Var) else par for par in parameters]

        return Call(func=func_name, arguments=args, source_refs=ref)

    def visit_while(self, node: Node) -&gt; Loop:
        ref = self.node_helper.get_source_ref(node)
        
        # Push a variable context since a loop 
        # can create variables that only it can see
        self.variable_context.push_context()

        loop_cond_node = get_children_by_types(node, WHILE_COND_TYPES)[0]
        loop_body_node = get_children_by_types(node, [&#34;block&#34;])[0].children

        loop_cond = self.visit(loop_cond_node)

        loop_body = []
        for node in loop_body_node:
            cast = self.visit(node)
            if isinstance(cast, List):
                loop_body.extend(cast)
            elif isinstance(cast, AstNode):
                loop_body.append(cast)

        self.variable_context.pop_context()

        return Loop(
            pre=[],
            expr=loop_cond,
            body=loop_body,
            post=[],
            source_refs = ref
        )

    def visit_for(self, node: Node) -&gt; Loop:
        ref = self.node_helper.get_source_ref(node)

        # Pre: left, right        
        loop_cond_left = get_children_by_types(node, FOR_LOOP_LEFT_TYPES)[0]
        loop_cond_right = get_children_by_types(node, FOR_LOOP_RIGHT_TYPES)[-1]

        # Construct pre and expr value using left and right as needed
        # need calls to &#34;_Iterator&#34;
        
        self.variable_context.push_context()
        iterator_name = self.variable_context.generate_iterator() 
        stop_cond_name = self.variable_context.generate_stop_condition()
        iter_func = self.get_gromet_function_node(&#34;iter&#34;)
        next_func = self.get_gromet_function_node(&#34;next&#34;)

        loop_cond_left_cast = self.visit(loop_cond_left)
        loop_cond_right_cast = self.visit(loop_cond_right)

        loop_pre = []
        loop_pre.append(
            Assignment(
                left = Var(iterator_name, &#34;Iterator&#34;),
                right = Call(
                    iter_func,
                    arguments=[loop_cond_right_cast]
                )
            )
        )

        loop_pre.append(
            Assignment(
                left=CASTLiteralValue(
                    &#34;Tuple&#34;,
                    [
                        loop_cond_left_cast,
                        Var(iterator_name, &#34;Iterator&#34;),
                        Var(stop_cond_name, &#34;Boolean&#34;),
                    ],
                    source_code_data_type = [&#34;Python&#34;,PYTHON_VERSION,&#34;Tuple&#34;],
                    source_refs=ref
                ),
                right=Call(
                    next_func,
                    arguments=[Var(iterator_name, &#34;Iterator&#34;)],
                ),
            )
        )

        loop_expr = Operator(
            source_language=&#34;Python&#34;, 
            interpreter=&#34;Python&#34;, 
            version=PYTHON_VERSION, 
            op=&#34;ast.Eq&#34;, 
            operands=[
                stop_cond_name,
                CASTLiteralValue(
                    ScalarType.BOOLEAN,
                    False,
                    [&#34;Python&#34;, PYTHON_VERSION, &#34;boolean&#34;],
                    source_refs=ref,
                )
            ], 
            source_refs=ref
        )

        loop_body_node = get_children_by_types(node, [&#34;block&#34;])[0].children
        loop_body = []
        for node in loop_body_node:
            cast = self.visit(node)
            if isinstance(cast, List):
                loop_body.extend(cast)
            elif isinstance(cast, AstNode):
                loop_body.append(cast)

        # Insert an additional call to &#39;next&#39; at the end of the loop body,
        # to facilitate looping in GroMEt 
        loop_body.append(
            Assignment(
                left=CASTLiteralValue(
                    &#34;Tuple&#34;,
                    [
                        loop_cond_left_cast,
                        Var(iterator_name, &#34;Iterator&#34;),
                        Var(stop_cond_name, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_func,
                    arguments=[Var(iterator_name, &#34;Iterator&#34;)],
                ),
            )
        )

        self.variable_context.pop_context()
        return Loop(
            pre=loop_pre,
            expr=loop_expr,
            body=loop_body,
            post=[],
            source_refs = ref
        )


    def visit_name(self, node):
        # First, we will check if this name is already defined, and if it is return the name node generated previously
        # NOTE: the call to check_alias is a crucial change, to resolve aliasing
        # need to make sure nothing breaks
        identifier = self.check_alias(self.node_helper.get_identifier(node))
        if self.variable_context.is_variable(identifier):
            return self.variable_context.get_node(identifier)

        return self.variable_context.add_variable(
            identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
        )

    def _visit_passthrough(self, node):
        if len(node.children) == 0:
            return None

        for child in node.children:
            child_cast = self.visit(child)
            if child_cast:
                return child_cast

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        # Idealy, we would be able to create a dummy node and just call the name visitor.
        # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
        if self.variable_context.is_variable(func_name):
            return self.variable_context.get_node(func_name)

        return self.variable_context.add_variable(func_name, &#34;function&#34;, None)
            
    def visit_yield(self, node):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = self.node_helper.get_source_ref(node)
        return [
            CASTLiteralValue(
                StructureType.LIST,
                &#34;YieldNotImplemented&#34;,
                source_code_data_type,
                ref
            )   
        ]

    def visit_assert(self, node):
        source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
        ref = self.node_helper.get_source_ref(node)
        return [
            CASTLiteralValue(
                StructureType.LIST,
                &#34;AssertNotImplemented&#34;,
                source_code_data_type,
                ref
            )   
        ]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.check_alias"><code class="name flex">
<span>def <span class="ident">check_alias</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a python string that represents a name,
this function checks to see if that name is an alias
for a different name, and returns it if it is indeed an alias.
Otherwise, the original name is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_alias(self, name):
    &#34;&#34;&#34;Given a python string that represents a name,
    this function checks to see if that name is an alias
    for a different name, and returns it if it is indeed an alias.
    Otherwise, the original name is returned.
    &#34;&#34;&#34;
    if name in self.aliases:
        return self.aliases[name]
    else:
        return name</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.construct_loop_construct"><code class="name flex">
<span>def <span class="ident">construct_loop_construct</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_loop_construct(self, node: Node):
    return []</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.generate_cast"><code class="name flex">
<span>def <span class="ident">generate_cast</span></span>(<span>self) ‑> List[<a title="skema.program_analysis.CAST2FN.cast.CAST" href="../../CAST2FN/cast.html#skema.program_analysis.CAST2FN.cast.CAST">CAST</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Interface for generating CAST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_cast(self) -&gt; List[CAST]:
    &#39;&#39;&#39;Interface for generating CAST.&#39;&#39;&#39;
    module = self.run(self.tree.root_node)
    module.name = self.source_file_name
    return CAST([generate_dummy_source_refs(module)], &#34;Python&#34;) </code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.get_gromet_function_node"><code class="name flex">
<span>def <span class="ident">get_gromet_function_node</span></span>(<span>self, func_name: str) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.name.Name" href="../../CAST2FN/model/cast/name.html#skema.program_analysis.CAST2FN.model.cast.name.Name">Name</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gromet_function_node(self, func_name: str) -&gt; Name:
    # Idealy, we would be able to create a dummy node and just call the name visitor.
    # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
    if self.variable_context.is_variable(func_name):
        return self.variable_context.get_node(func_name)

    return self.variable_context.add_variable(func_name, &#34;function&#34;, None)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_aliased_import"><code class="name flex">
<span>def <span class="ident">handle_aliased_import</span></span>(<span>self, import_stmt) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.model_import.ModelImport" href="../../CAST2FN/model/cast/model_import.html#skema.program_analysis.CAST2FN.model.cast.model_import.ModelImport">ModelImport</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_aliased_import(self, import_stmt) -&gt; ModelImport:
    ref = self.node_helper.get_source_ref(import_stmt)
    dot_name = get_children_by_types(import_stmt,[&#34;dotted_name&#34;])[0]
    name = self.handle_dotted_name(dot_name) 
    alias = get_children_by_types(import_stmt, [&#34;identifier&#34;])[0]
    self.visit(alias)

    return (name, self.node_helper.get_identifier(alias)) </code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_dotted_name"><code class="name flex">
<span>def <span class="ident">handle_dotted_name</span></span>(<span>self, import_stmt) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.model_import.ModelImport" href="../../CAST2FN/model/cast/model_import.html#skema.program_analysis.CAST2FN.model.cast.model_import.ModelImport">ModelImport</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_dotted_name(self, import_stmt) -&gt; ModelImport:
    ref = self.node_helper.get_source_ref(import_stmt)
    name = self.node_helper.get_identifier(import_stmt)
    self.visit(import_stmt)

    return name</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_for_clause"><code class="name flex">
<span>def <span class="ident">handle_for_clause</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_for_clause(self, node: Node):
    # Given the &#34;for x in seq&#34; clause of a list comprehension
    # we translate it to a CAST for loop, leaving the actual
    # computation of the body node for the main comprehension handler
    assert node.type == &#34;for_in_clause&#34;
    ref = self.node_helper.get_source_ref(node)

    # NOTE: Assumes the left part with the variable is always the 2nd
    # element in the children and the right part with the actual
    # function call is on the 4th (last) element of the children
    left = self.visit(node.children[1])
    right = self.visit(node.children[-1])

    iterator_name = self.variable_context.generate_iterator()
    stop_cond_name = self.variable_context.generate_stop_condition()
    iter_func = self.get_gromet_function_node(&#34;iter&#34;)
    next_func = self.get_gromet_function_node(&#34;next&#34;)
    
    iter_call = Assignment(
        left = Var(iterator_name, &#34;Iterator&#34;),
        right = Call(
            iter_func,
            arguments=[right]
        )
    )

    next_call = Call(
        next_func,
        arguments=[Var(iterator_name, &#34;Iterator&#34;)]
    )

    next_assign = Assignment(
        left=CASTLiteralValue(
            &#34;Tuple&#34;,
            [
                left,
                Var(iterator_name, &#34;Iterator&#34;),
                Var(stop_cond_name, &#34;Boolean&#34;),
            ],
            source_code_data_type = [&#34;Python&#34;,PYTHON_VERSION,&#34;Tuple&#34;],
            source_refs=ref
        ),
        right=next_call
    )

    loop_pre = []
    loop_pre.append(iter_call)
    loop_pre.append(next_assign)

    loop_expr = Operator(
        source_language=&#34;Python&#34;, 
        interpreter=&#34;Python&#34;, 
        version=PYTHON_VERSION, 
        op=&#34;ast.Eq&#34;, 
        operands=[
            stop_cond_name,
            CASTLiteralValue(
                ScalarType.BOOLEAN,
                False,
                [&#34;Python&#34;, PYTHON_VERSION, &#34;boolean&#34;],
                source_refs=ref,
            )
        ], 
        source_refs=ref
    )

    loop_body = [None, next_assign]

    return Loop(pre=loop_pre, expr=loop_expr, body=loop_body, post=[])</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_if_clause"><code class="name flex">
<span>def <span class="ident">handle_if_clause</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_if_clause(self, node: Node):
    assert node.type == &#34;if_clause&#34;
    ref = self.node_helper.get_source_ref(node)
    conditional = get_children_by_types(node, WHILE_COND_TYPES)[0]
    cond_cast = self.visit(conditional)
    
    return ModelIf(expr=cond_cast,body=[],orelse=[],source_refs=ref)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, root) ‑> List[<a title="skema.program_analysis.CAST2FN.model.cast.module.Module" href="../../CAST2FN/model/cast/module.html#skema.program_analysis.CAST2FN.model.cast.module.Module">Module</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, root) -&gt; List[Module]:
    # In python there&#39;s generally only one module at the top level
    # I believe then we just need to visit the root, which is a module
    # Which can then contain multiple things (Handled at module visitor)
    return self.visit(root)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node: Node):
    # print(f&#34;===Visiting node[{node.type}]===&#34;)
    if node.type == &#34;module&#34;:
        return self.visit_module(node)
    elif node.type == &#34;parenthesized_expression&#34;:
        # Node for &#34;( op )&#34;, extract op
        # The actual op is in the middle of the list of nodes
        return self.visit(node.children[1])
    elif node.type == &#34;expression_statement&#34;:
        return self.visit_expression(node)
    elif node.type == &#34;function_definition&#34;:
        return self.visit_function_def(node)
    elif node.type == &#34;return_statement&#34;:
        return self.visit_return(node)
    elif node.type == &#34;call&#34;:
        return self.visit_call(node)
    elif node.type == &#34;if_statement&#34;:
        return self.visit_if_statement(node)
    elif node.type == &#34;comparison_operator&#34;:
        return self.visit_comparison_op(node)
    elif node.type == &#34;assignment&#34;:
        return self.visit_assignment(node)
    elif node.type == &#34;attribute&#34;:
        return self.visit_attribute(node)
    elif node.type == &#34;identifier&#34;:
        return self.visit_identifier(node)
    elif node.type == &#34;unary_operator&#34;:
        return self.visit_unary_op(node)
    elif node.type == &#34;binary_operator&#34;:
        return self.visit_binary_op(node)
    elif node.type in [&#34;integer&#34;, &#34;list&#34;]:
        return self.visit_literal(node)
    elif node.type in [&#34;list_pattern&#34;, &#34;pattern_list&#34;, &#34;tuple_pattern&#34;]:
        return self.visit_pattern(node)
    elif node.type == &#34;list_comprehension&#34;:
        return self.visit_list_comprehension(node)
    elif node.type == &#34;dictionary_comprehension&#34;:
        return self.visit_dict_comprehension(node)
    elif node.type == &#34;lambda&#34;:
        return self.visit_lambda(node)
    elif node.type == &#34;pair&#34;:
        return self.visit_pair(node)
    elif node.type == &#34;while_statement&#34;:
        return self.visit_while(node)
    elif node.type == &#34;for_statement&#34;:
        return self.visit_for(node)
    elif node.type == &#34;import_statement&#34;:
        return self.visit_import(node)
    elif node.type == &#34;import_from_statement&#34;:
        return self.visit_import_from(node)
    elif node.type == &#34;yield&#34;:
        return self.visit_yield(node)
    elif node.type == &#34;assert_statement&#34;:
        return self.visit_assert(node)
    else:
        return self._visit_passthrough(node)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_assert"><code class="name flex">
<span>def <span class="ident">visit_assert</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_assert(self, node):
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = self.node_helper.get_source_ref(node)
    return [
        CASTLiteralValue(
            StructureType.LIST,
            &#34;AssertNotImplemented&#34;,
            source_code_data_type,
            ref
        )   
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_assignment"><code class="name flex">
<span>def <span class="ident">visit_assignment</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.assignment.Assignment" href="../../CAST2FN/model/cast/assignment.html#skema.program_analysis.CAST2FN.model.cast.assignment.Assignment">Assignment</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_assignment(self, node: Node) -&gt; Assignment:
    left, _, right = node.children
    ref = self.node_helper.get_source_ref(node)
    
    # For the RHS of an assignment we want the Name CAST node
    # and not the entire Var CAST node if we&#39;re doing an
    # assignment like x = y
    right_cast = get_name_node(self.visit(right))
    
    return Assignment(
        left=self.visit(left),
        right=right_cast,
        source_refs=[ref]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_attribute"><code class="name flex">
<span>def <span class="ident">visit_attribute</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_attribute(self, node: Node):
    ref = self.node_helper.get_source_ref(node)
    obj,_,attr = node.children
    obj_cast = self.visit(obj)
    attr_cast = self.visit(attr)

    return Attribute(value= get_name_node(obj_cast), attr=get_name_node(attr_cast), source_refs=ref)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_binary_op"><code class="name flex">
<span>def <span class="ident">visit_binary_op</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.operator.Operator" href="../../CAST2FN/model/cast/operator.html#skema.program_analysis.CAST2FN.model.cast.operator.Operator">Operator</a></span>
</code></dt>
<dd>
<div class="desc"><p>Binary Ops
left OP right
where left and right can either be operators or literals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_binary_op(self, node: Node) -&gt; Operator:
    &#34;&#34;&#34;
        Binary Ops
        left OP right
        where left and right can either be operators or literals
    &#34;&#34;&#34;
    ref = self.node_helper.get_source_ref(node)
    op = get_op(self.node_helper.get_operator(node.children[1]))
    left, _, right = node.children

    left_cast = get_name_node(self.visit(left))
    right_cast = get_name_node(self.visit(right))

    return Operator(
        op=op, 
        operands=[left_cast, right_cast], 
        source_refs=[ref]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_call"><code class="name flex">
<span>def <span class="ident">visit_call</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.call.Call" href="../../CAST2FN/model/cast/call.html#skema.program_analysis.CAST2FN.model.cast.call.Call">Call</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_call(self, node: Node) -&gt; Call:
    ref = self.node_helper.get_source_ref(node)

    func_cast = self.visit(node.children[0])

    func_name = get_func_name_node(func_cast)        

    arg_list = get_first_child_by_type(node, &#34;argument_list&#34;)
    args = get_non_control_children(arg_list)

    func_args = []
    for arg in args:
        cast = get_name_node(self.visit(arg))
        if isinstance(cast, List):
            func_args.extend(cast)
        elif isinstance(cast, AstNode):
            func_args.append(cast)

    if get_name_node(func_cast).name == &#34;range&#34;:
        start_step_value = CASTLiteralValue(
            ScalarType.INTEGER, 
            value=&#34;1&#34;,
            source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1))],
            source_refs=[ref]
        )
        # Add a step value
        if len(func_args) == 2:
            func_args.append(start_step_value)
        # Add a start and step value
        elif len(func_args) == 1:
            func_args.insert(0, start_step_value)
            func_args.append(start_step_value)

    # Function calls only want the &#39;Name&#39; part of the &#39;Var&#39; that the visit returns
    return Call(
        func=func_name, 
        arguments=func_args, 
        source_refs=[ref]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_comparison_op"><code class="name flex">
<span>def <span class="ident">visit_comparison_op</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_comparison_op(self, node: Node):
    ref = self.node_helper.get_source_ref(node)
    op = get_op(self.node_helper.get_operator(node.children[1]))
    left, _, right = node.children

    left_cast = get_name_node(self.visit(left))
    right_cast = get_name_node(self.visit(right))

    return Operator(
        op=op, 
        operands=[left_cast, right_cast], 
        source_refs=[ref]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_dict_comprehension"><code class="name flex">
<span>def <span class="ident">visit_dict_comprehension</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.call.Call" href="../../CAST2FN/model/cast/call.html#skema.program_analysis.CAST2FN.model.cast.call.Call">Call</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_dict_comprehension(self, node: Node) -&gt; Call:
    ref = self.node_helper.get_source_ref(node)

    temp_dict_name = self.variable_context.add_variable(
        &#34;dict__temp_&#34;, &#34;Unknown&#34;, [ref]
    )

    temp_asg_cast = Assignment(
        left=Var(val=temp_dict_name),
        right=CASTLiteralValue(value={}, value_type=StructureType.MAP),
        source_refs = ref
    )

    set_call = self.get_gromet_function_node(&#34;_set&#34;)
    computation = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]
    computation_cast = self.visit(computation)

    # IDEA: When we see a for_clause we start a new loop construct, and collect if_clauses 
    # as we see them
    clauses = get_children_by_types(node, [&#34;for_in_clause&#34;, &#34;if_clause&#34;])
    loop_start = []
    prev_loop = []
    
    if_start = []
    prev_if = []

    for clause in clauses:
        if clause.type == &#34;for_in_clause&#34;:
            new_loop = self.handle_for_clause(clause)
            if loop_start == []:
                loop_start = new_loop
                prev_loop = loop_start
            else:
                if prev_if == []:
                    prev_loop.body[0] = new_loop
                    prev_loop = new_loop
                else:
                    prev_loop.body[0] = prev_if
                    prev_if.body = [new_loop]
                    prev_loop = new_loop
                    if_start = []
                    prev_if = []
        elif clause.type == &#34;if_clause&#34;:
            new_if = self.handle_if_clause(clause)
            if if_start == []:
                if_start = new_if
                prev_if = if_start
            else:
                prev_if.body = [new_if]
                prev_if = new_if
    
    if prev_if == []:
        prev_loop.body[0] = Assignment(left=Var(val=temp_dict_name), right=Call(func=set_call, arguments=[temp_dict_name, computation_cast[0].val, computation_cast[1]], source_refs=ref), source_refs=ref)
    else:
        prev_loop.body[0] = prev_if
        prev_loop = Assignment(left=Var(val=temp_dict_name), right=Call(func=set_call, arguments=[temp_dict_name, computation_cast[0].val, computation_cast[1]], source_refs=ref), source_refs=ref)

    return_cast = ModelReturn(temp_dict_name)

    func_name = self.variable_context.generate_func(&#34;%comprehension_dict&#34;)
    func_def_cast = FunctionDef(name=func_name, func_args=[], body=[temp_asg_cast,loop_start,return_cast], source_refs=ref)

    self.generated_fns.append(func_def_cast)

    return Call(func=func_name, arguments=[], source_refs=ref)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_expression"><code class="name flex">
<span>def <span class="ident">visit_expression</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_expression(self, node: Node):
    # NOTE: Is there an instance where an &#39;expression statement&#39; node
    # Has more than one child?

    expr_body = []
    for child in node.children:
        child_cast = self.visit(child)
        if isinstance(child_cast, List):
            expr_body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            expr_body.append(child_cast)

    return expr_body</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_for"><code class="name flex">
<span>def <span class="ident">visit_for</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.loop.Loop" href="../../CAST2FN/model/cast/loop.html#skema.program_analysis.CAST2FN.model.cast.loop.Loop">Loop</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_for(self, node: Node) -&gt; Loop:
    ref = self.node_helper.get_source_ref(node)

    # Pre: left, right        
    loop_cond_left = get_children_by_types(node, FOR_LOOP_LEFT_TYPES)[0]
    loop_cond_right = get_children_by_types(node, FOR_LOOP_RIGHT_TYPES)[-1]

    # Construct pre and expr value using left and right as needed
    # need calls to &#34;_Iterator&#34;
    
    self.variable_context.push_context()
    iterator_name = self.variable_context.generate_iterator() 
    stop_cond_name = self.variable_context.generate_stop_condition()
    iter_func = self.get_gromet_function_node(&#34;iter&#34;)
    next_func = self.get_gromet_function_node(&#34;next&#34;)

    loop_cond_left_cast = self.visit(loop_cond_left)
    loop_cond_right_cast = self.visit(loop_cond_right)

    loop_pre = []
    loop_pre.append(
        Assignment(
            left = Var(iterator_name, &#34;Iterator&#34;),
            right = Call(
                iter_func,
                arguments=[loop_cond_right_cast]
            )
        )
    )

    loop_pre.append(
        Assignment(
            left=CASTLiteralValue(
                &#34;Tuple&#34;,
                [
                    loop_cond_left_cast,
                    Var(iterator_name, &#34;Iterator&#34;),
                    Var(stop_cond_name, &#34;Boolean&#34;),
                ],
                source_code_data_type = [&#34;Python&#34;,PYTHON_VERSION,&#34;Tuple&#34;],
                source_refs=ref
            ),
            right=Call(
                next_func,
                arguments=[Var(iterator_name, &#34;Iterator&#34;)],
            ),
        )
    )

    loop_expr = Operator(
        source_language=&#34;Python&#34;, 
        interpreter=&#34;Python&#34;, 
        version=PYTHON_VERSION, 
        op=&#34;ast.Eq&#34;, 
        operands=[
            stop_cond_name,
            CASTLiteralValue(
                ScalarType.BOOLEAN,
                False,
                [&#34;Python&#34;, PYTHON_VERSION, &#34;boolean&#34;],
                source_refs=ref,
            )
        ], 
        source_refs=ref
    )

    loop_body_node = get_children_by_types(node, [&#34;block&#34;])[0].children
    loop_body = []
    for node in loop_body_node:
        cast = self.visit(node)
        if isinstance(cast, List):
            loop_body.extend(cast)
        elif isinstance(cast, AstNode):
            loop_body.append(cast)

    # Insert an additional call to &#39;next&#39; at the end of the loop body,
    # to facilitate looping in GroMEt 
    loop_body.append(
        Assignment(
            left=CASTLiteralValue(
                &#34;Tuple&#34;,
                [
                    loop_cond_left_cast,
                    Var(iterator_name, &#34;Iterator&#34;),
                    Var(stop_cond_name, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_func,
                arguments=[Var(iterator_name, &#34;Iterator&#34;)],
            ),
        )
    )

    self.variable_context.pop_context()
    return Loop(
        pre=loop_pre,
        expr=loop_expr,
        body=loop_body,
        post=[],
        source_refs = ref
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_function_def"><code class="name flex">
<span>def <span class="ident">visit_function_def</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.function_def.FunctionDef" href="../../CAST2FN/model/cast/function_def.html#skema.program_analysis.CAST2FN.model.cast.function_def.FunctionDef">FunctionDef</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_def(self, node: Node) -&gt; FunctionDef:
    ref = self.node_helper.get_source_ref(node)

    name_node = get_first_child_by_type(node, &#34;identifier&#34;)
    name = self.visit(name_node)

    # Create new variable context
    self.variable_context.push_context()

    parameters = get_children_by_types(node, [&#34;parameters&#34;])[0]
    parameters = get_non_control_children(parameters)
    
    # The body of the function is stored in a &#39;block&#39; type node
    body = get_children_by_types(node, [&#34;block&#34;])[0].children
    

    func_params = []
    for node in parameters:
        cast = self.visit(node)
        if isinstance(cast, List):
            func_params.extend(cast)
        elif isinstance(cast, AstNode):
            func_params.append(cast)

    func_body = []
    for node in body:
        cast = self.visit(node)
        if isinstance(cast, List):
            func_body.extend(cast)
        elif isinstance(cast, AstNode):
            func_body.append(cast)
        # TODO: Do we need to handle return statements in any special way?

    self.variable_context.pop_context()

    return FunctionDef(
        name=name.val,
        func_args=func_params,
        body=func_body,
        source_refs=[ref]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_identifier"><code class="name flex">
<span>def <span class="ident">visit_identifier</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.var.Var" href="../../CAST2FN/model/cast/var.html#skema.program_analysis.CAST2FN.model.cast.var.Var">Var</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_identifier(self, node: Node) -&gt; Var:
    identifier = self.node_helper.get_identifier(node)

    if self.variable_context.is_variable(identifier):
        var_type = self.variable_context.get_type(identifier)
    else:
        var_type = &#34;unknown&#34;
    
    # TODO: Python default values
    default_value = None
    
    value = self.visit_name(node)
    
    return Var(
        val=value,
        type=var_type,
        default_value=default_value,
        source_refs=[self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_if_statement"><code class="name flex">
<span>def <span class="ident">visit_if_statement</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.model_if.ModelIf" href="../../CAST2FN/model/cast/model_if.html#skema.program_analysis.CAST2FN.model.cast.model_if.ModelIf">ModelIf</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_if_statement(self, node: Node) -&gt; ModelIf:
    if_condition = self.visit(get_first_child_by_type(node, &#34;comparison_operator&#34;))

    # Get the body of the if true part
    if_true = get_children_by_types(node, [&#34;block&#34;])[0].children

    # Because in tree-sitter the else if, and else aren&#39;t nested, but they&#39;re 
    # in a flat level order, we need to do some arranging of the pieces
    # in order to get the correct CAST nested structure that we use
    # Visit all the alternatives, generate CAST for each one
    # and then join them all together
    alternatives = get_children_by_types(node, [&#34;elif_clause&#34;,&#34;else_clause&#34;])

    if_true_cast = []
    for node in if_true: 
        cast = self.visit(node)
        if isinstance(cast, List):
            if_true_cast.extend(cast)
        elif isinstance(cast, AstNode):
            if_true_cast.append(cast)

    # If we have ts nodes in alternatives, then we&#39;re guaranteed
    # at least an else at the end of the if-statement construct
    # We generate the cast for the final else statement, and then
    # reverse the rest of the if-elses that we have, so we can 
    # create the CAST correctly
    final_else_cast = [] 
    if len(alternatives) &gt; 0:
        final_else = alternatives.pop() 
        alternatives.reverse()
        final_else_body = get_children_by_types(final_else, [&#34;block&#34;])[0].children
        for node in final_else_body:
            cast = self.visit(node)
            if isinstance(cast, List):
                final_else_cast.extend(cast)
            elif isinstance(cast, AstNode):
                final_else_cast.append(cast)
    
    # We go through any additional if-else nodes that we may have,
    # generating their ModelIf CAST and appending the tail of the 
    # overall if-else construct, starting with the else at the very end
    # We do this tail appending so that when we finish generating CAST the
    # resulting ModelIf CAST is in the correct order
    alternatives_cast = None
    for ts_node in alternatives:
        assert ts_node.type == &#34;elif_clause&#34;
        temp_cast = self.visit_if_statement(ts_node)
        if alternatives_cast == None:
            temp_cast.orelse = final_else_cast
        else:
            temp_cast.orelse = [alternatives_cast]
        alternatives_cast = temp_cast

    if alternatives_cast == None:
        if_false_cast = final_else_cast 
    else:
        if_false_cast = [alternatives_cast]

    return ModelIf(
        expr=if_condition, 
        body=if_true_cast, 
        orelse=if_false_cast, 
        source_refs=[self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_import"><code class="name flex">
<span>def <span class="ident">visit_import</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_import(self, node: Node):
    ref = self.node_helper.get_source_ref(node)
    to_ret = []

    names_list = get_children_by_types(node, [&#34;dotted_name&#34;, &#34;aliased_import&#34;])
    for name in names_list:
        if name.type == &#34;dotted_name&#34;:
            resolved_name = self.handle_dotted_name(name)
            to_ret.append(ModelImport(name=resolved_name, alias=None, symbol=None, all=False, source_refs=ref))
        elif name.type == &#34;aliased_import&#34;:
            resolved_name = self.handle_aliased_import(name)
            self.aliases[resolved_name[1]] = resolved_name[0]
            to_ret.append(ModelImport(name=resolved_name[0], alias=resolved_name[1], symbol=None, all=False, source_refs=ref))

    return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_import_from"><code class="name flex">
<span>def <span class="ident">visit_import_from</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_import_from(self, node: Node):
    ref = self.node_helper.get_source_ref(node)
    to_ret = []

    names_list = get_children_by_types(node, [&#34;dotted_name&#34;, &#34;aliased_import&#34;])
    wild_card = get_children_by_types(node, [&#34;wildcard_import&#34;])
    module_name = self.node_helper.get_identifier(names_list[0])

    # if &#34;wildcard_import&#34; exists then it&#39;ll be in the list
    if len(wild_card) == 1:
        to_ret.append(ModelImport(name=module_name, alias=None, symbol=None, all=True, source_refs=ref))
    else:
        for name in names_list[1:]:
            if name.type == &#34;dotted_name&#34;:
                resolved_name = self.handle_dotted_name(name) 
                to_ret.append(ModelImport(name=module_name, alias=None, symbol=resolved_name, all=False, source_refs=ref))
            elif name.type == &#34;aliased_import&#34;:
                resolved_name = self.handle_aliased_import(name)
                self.aliases[resolved_name[1]] = resolved_name[0]
                to_ret.append(ModelImport(name=module_name, alias=resolved_name[1], symbol=resolved_name[0], all=False, source_refs=ref))
        
    return to_ret</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_lambda"><code class="name flex">
<span>def <span class="ident">visit_lambda</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.call.Call" href="../../CAST2FN/model/cast/call.html#skema.program_analysis.CAST2FN.model.cast.call.Call">Call</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_lambda(self, node: Node) -&gt; Call:
    # TODO: we have to determine how to grab the variables that are being
    # used in the lambda that aren&#39;t part of the lambda&#39;s arguments
    ref=self.node_helper.get_source_ref(node)
    params = get_children_by_types(node, [&#34;lambda_parameters&#34;])[0] 
    body = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]

    parameters = []
    for param in params.children:
        cast = self.visit(param)
        if isinstance(cast, list):
            parameters.extend(cast)
        else:
            parameters.append(cast)

    body_cast = self.visit(body)
    func_body = body_cast 

    func_name = self.variable_context.generate_func(&#34;%lambda&#34;)
    func_def_cast = FunctionDef(name=func_name, func_args=parameters, body=[ModelReturn(value=func_body)], source_refs=ref)

    self.generated_fns.append(func_def_cast)
    
    # Collect all the Name node instances to use as arguments for the lambda call
    args = [par.val if isinstance(par, Var) else par for par in parameters]

    return Call(func=func_name, arguments=args, source_refs=ref)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_list_comprehension"><code class="name flex">
<span>def <span class="ident">visit_list_comprehension</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.call.Call" href="../../CAST2FN/model/cast/call.html#skema.program_analysis.CAST2FN.model.cast.call.Call">Call</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_list_comprehension(self, node: Node) -&gt; Call:
    ref = self.node_helper.get_source_ref(node)

    temp_list_name = self.variable_context.add_variable(
        &#34;list__temp_&#34;, &#34;Unknown&#34;, [ref]
    )

    temp_asg_cast = Assignment(
        left=Var(val=temp_list_name), 
        right=CASTLiteralValue(value=[], value_type=StructureType.LIST),
        source_refs = ref
    )

    append_call = self.get_gromet_function_node(&#34;append&#34;) 
    computation = get_children_by_types(node, COMPREHENSION_OPERATORS)[0]
    computation_cast = self.visit(computation)

    # IDEA: When we see a for_clause we start a new loop construct, and collect if_clauses 
    # as we see them
    clauses = get_children_by_types(node, [&#34;for_in_clause&#34;, &#34;if_clause&#34;])
    loop_start = []
    prev_loop = []
    
    if_start = []
    prev_if = []

    for clause in clauses:
        if clause.type == &#34;for_in_clause&#34;:
            new_loop = self.handle_for_clause(clause)
            if loop_start == []:
                loop_start = new_loop
                prev_loop = loop_start
            else:
                if prev_if == []:
                    prev_loop.body[0] = new_loop
                    prev_loop = new_loop
                else:
                    prev_loop.body[0] = prev_if
                    prev_if.body = [new_loop]
                    prev_loop = new_loop
                    if_start = []
                    prev_if = []
        elif clause.type == &#34;if_clause&#34;:
            new_if = self.handle_if_clause(clause)
            if if_start == []:
                if_start = new_if
                prev_if = if_start
            else:
                prev_if.body = [new_if]
                prev_if = new_if
    
    if prev_if == []:
        prev_loop.body[0] = Call(func=Attribute(temp_list_name, append_call), arguments=[computation_cast], source_refs=ref)
    else:
        prev_loop.body[0] = prev_if
        prev_if.body = [Call(func=Attribute(temp_list_name, append_call), arguments=[computation_cast], source_refs=ref)]

    return_cast = ModelReturn(temp_list_name)

    func_name = self.variable_context.generate_func(&#34;%comprehension_list&#34;)
    func_def_cast = FunctionDef(name=func_name, func_args=[], body=[temp_asg_cast,loop_start,return_cast], source_refs=ref)
    
    self.generated_fns.append(func_def_cast)

    return Call(func=func_name, arguments=[], source_refs=ref)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_literal"><code class="name flex">
<span>def <span class="ident">visit_literal</span></span>(<span>self, node: tree_sitter.Node) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_literal(self, node: Node) -&gt; Any:
    literal_type = node.type        
    literal_value = self.node_helper.get_identifier(node)
    literal_source_ref = self.node_helper.get_source_ref(node)

    if literal_type == &#34;integer&#34;:
        return CASTLiteralValue(
            value_type=ScalarType.INTEGER,
            value=literal_value,
            source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1))],
            source_refs=[literal_source_ref]
        )
    elif literal_type == &#34;float&#34;:
        return CASTLiteralValue(
            value_type=ScalarType.ABSTRACTFLOAT,
            value=literal_value,
            source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(1.0))],
            source_refs=[literal_source_ref]
        )
    elif literal_type == &#34;true&#34; or literal_type == &#34;false&#34;:
        return CASTLiteralValue(
            value_type=ScalarType.BOOLEAN,
            value=&#34;True&#34; if literal_type == &#34;true&#34; else &#34;False&#34;,
            source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type(True))],
            source_refs=[literal_source_ref]
        )
    elif literal_type == &#34;list&#34;:
        list_items = []
        for elem in node.children:
            cast = self.visit(elem)
            if isinstance(cast, List):
                list_items.extend(cast)
            elif isinstance(cast, AstNode):
                list_items.append(cast)

        return CASTLiteralValue(
            value_type=StructureType.LIST,
            value = list_items,
            source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type([0]))],
            source_refs=[literal_source_ref]
        )
    elif literal_type == &#34;tuple&#34;:
        tuple_items = []
        for elem in node.children:
            cast = self.visit(cast)
            if isinstance(cast, List):
                tuple_items.extend(cast)
            elif isinstance(cast, AstNode):
                tuple_items.append(cast)

        return CASTLiteralValue(
            value_type=StructureType.LIST,
            value = tuple_items,
            source_code_data_type=[&#34;Python&#34;, PYTHON_VERSION, str(type((0)))],
            source_refs=[literal_source_ref]
        )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_module"><code class="name flex">
<span>def <span class="ident">visit_module</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.module.Module" href="../../CAST2FN/model/cast/module.html#skema.program_analysis.CAST2FN.model.cast.module.Module">Module</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_module(self, node: Node) -&gt; Module:
    # A module is comprised of one or several statements/expressions
    # At the global level
    self.variable_context.push_context()

    body = []
    for child in node.children:
        child_cast = self.visit(child)
        if isinstance(child_cast, List):
            body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            body.append(child_cast)

    self.variable_context.pop_context()
    
    return Module(
        name=None,
        body=self.generated_fns + body,
        source_refs = [self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_name"><code class="name flex">
<span>def <span class="ident">visit_name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_name(self, node):
    # First, we will check if this name is already defined, and if it is return the name node generated previously
    # NOTE: the call to check_alias is a crucial change, to resolve aliasing
    # need to make sure nothing breaks
    identifier = self.check_alias(self.node_helper.get_identifier(node))
    if self.variable_context.is_variable(identifier):
        return self.variable_context.get_node(identifier)

    return self.variable_context.add_variable(
        identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_pair"><code class="name flex">
<span>def <span class="ident">visit_pair</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_pair(self, node: Node):
    key = self.visit(node.children[0])
    value = self.visit(node.children[2])

    return key,value</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_pattern"><code class="name flex">
<span>def <span class="ident">visit_pattern</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_pattern(self, node: Node):
    pattern_cast = []
    for elem in node.children:
        cast = self.visit(elem)
        if isinstance(cast, List):
            pattern_cast.extend(cast)
        elif isinstance(cast, AstNode):
            pattern_cast.append(cast)

    return CASTLiteralValue(value_type=StructureType.TUPLE, value=pattern_cast) </code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_return"><code class="name flex">
<span>def <span class="ident">visit_return</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.model_return.ModelReturn" href="../../CAST2FN/model/cast/model_return.html#skema.program_analysis.CAST2FN.model.cast.model_return.ModelReturn">ModelReturn</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_return(self, node: Node) -&gt; ModelReturn:
    ref = self.node_helper.get_source_ref(node)
    ret_val = node.children[1]
    ret_cast = self.visit(ret_val)

    return ModelReturn(value=ret_cast, source_refs=[ref])</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_unary_op"><code class="name flex">
<span>def <span class="ident">visit_unary_op</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.operator.Operator" href="../../CAST2FN/model/cast/operator.html#skema.program_analysis.CAST2FN.model.cast.operator.Operator">Operator</a></span>
</code></dt>
<dd>
<div class="desc"><p>Unary Ops
OP operand
where operand is some kind of expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_unary_op(self, node: Node) -&gt; Operator:
    &#34;&#34;&#34;
        Unary Ops
        OP operand
        where operand is some kind of expression
    &#34;&#34;&#34;
    ref = self.node_helper.get_source_ref(node)
    op = get_op(self.node_helper.get_operator(node.children[0]))
    operand = node.children[1]
    
    if op == &#39;ast.Sub&#39;:
        op = &#39;ast.USub&#39;
    
    # For the operand we need the Name CAST node and
    # not the whole Var CAST node
    # in instances like -x
    operand_cast = get_name_node(self.visit(operand))
    
    if isinstance(operand_cast, Var):
        operand_cast = operand_cast.val

    return Operator(
        op=op, 
        operands=[operand_cast], 
        source_refs=[ref]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_while"><code class="name flex">
<span>def <span class="ident">visit_while</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.loop.Loop" href="../../CAST2FN/model/cast/loop.html#skema.program_analysis.CAST2FN.model.cast.loop.Loop">Loop</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_while(self, node: Node) -&gt; Loop:
    ref = self.node_helper.get_source_ref(node)
    
    # Push a variable context since a loop 
    # can create variables that only it can see
    self.variable_context.push_context()

    loop_cond_node = get_children_by_types(node, WHILE_COND_TYPES)[0]
    loop_body_node = get_children_by_types(node, [&#34;block&#34;])[0].children

    loop_cond = self.visit(loop_cond_node)

    loop_body = []
    for node in loop_body_node:
        cast = self.visit(node)
        if isinstance(cast, List):
            loop_body.extend(cast)
        elif isinstance(cast, AstNode):
            loop_body.append(cast)

    self.variable_context.pop_context()

    return Loop(
        pre=[],
        expr=loop_cond,
        body=loop_body,
        post=[],
        source_refs = ref
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_yield"><code class="name flex">
<span>def <span class="ident">visit_yield</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_yield(self, node):
    source_code_data_type = [&#34;Python&#34;, &#34;3.8&#34;, &#34;List&#34;]
    ref = self.node_helper.get_source_ref(node)
    return [
        CASTLiteralValue(
            StructureType.LIST,
            &#34;YieldNotImplemented&#34;,
            source_code_data_type,
            ref
        )   
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis.CAST.python" href="index.html">skema.program_analysis.CAST.python</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.get_func_name_node" href="#skema.program_analysis.CAST.python.ts2cast.get_func_name_node">get_func_name_node</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.get_name_node" href="#skema.program_analysis.CAST.python.ts2cast.get_name_node">get_name_node</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST">TS2CAST</a></code></h4>
<ul class="">
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.check_alias" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.check_alias">check_alias</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.construct_loop_construct" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.construct_loop_construct">construct_loop_construct</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.generate_cast" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.generate_cast">generate_cast</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.get_gromet_function_node" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.get_gromet_function_node">get_gromet_function_node</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_aliased_import" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_aliased_import">handle_aliased_import</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_dotted_name" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_dotted_name">handle_dotted_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_for_clause" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_for_clause">handle_for_clause</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_if_clause" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.handle_if_clause">handle_if_clause</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.run" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.run">run</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit">visit</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_assert" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_assert">visit_assert</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_assignment" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_assignment">visit_assignment</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_attribute" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_attribute">visit_attribute</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_binary_op" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_binary_op">visit_binary_op</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_call" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_call">visit_call</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_comparison_op" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_comparison_op">visit_comparison_op</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_dict_comprehension" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_dict_comprehension">visit_dict_comprehension</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_expression" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_expression">visit_expression</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_for" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_for">visit_for</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_function_def" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_function_def">visit_function_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_identifier" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_identifier">visit_identifier</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_if_statement" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_if_statement">visit_if_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_import" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_import">visit_import</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_import_from" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_import_from">visit_import_from</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_lambda" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_lambda">visit_lambda</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_list_comprehension" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_list_comprehension">visit_list_comprehension</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_literal" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_literal">visit_literal</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_module" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_module">visit_module</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_name" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_name">visit_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_pair" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_pair">visit_pair</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_pattern" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_pattern">visit_pattern</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_return" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_return">visit_return</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_unary_op" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_unary_op">visit_unary_op</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_while" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_while">visit_while</a></code></li>
<li><code><a title="skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_yield" href="#skema.program_analysis.CAST.python.ts2cast.TS2CAST.visit_yield">visit_yield</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>