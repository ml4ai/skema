<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.CAST.matlab.matlab_to_cast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.CAST.matlab.matlab_to_cast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os.path
import pprint
from pathlib import Path
from typing import Any, Dict, List, Union

from tree_sitter import Language, Parser, Node, Tree

from skema.program_analysis.CAST2FN.cast import CAST
from skema.program_analysis.CAST2FN.model.cast import (
    Module,
    SourceRef,
    Assignment,
    LiteralValue,
    Var,
    VarType,
    Name,
    Operator,
    AstNode,
    SourceCodeDataType,
    ModelImport,
    FunctionDef,
    Loop,
    Call,
    ModelReturn,
    ModelIf,
    RecordDef,
    Attribute,
)

from skema.program_analysis.CAST.matlab.matlab_tree_builder import MatlabTreeBuilder
from skema.program_analysis.CAST.matlab.variable_context import VariableContext
from skema.program_analysis.CAST.matlab.node_helper import (
    NodeHelper,
    get_children_by_types,
    get_first_child_by_type,
    get_control_children,
    get_non_control_children,
    get_first_child_index,
    get_last_child_index,
)
from skema.program_analysis.CAST.matlab.util import generate_dummy_source_refs
from skema.program_analysis.tree_sitter_parsers.build_parsers import INSTALLED_LANGUAGES_FILEPATH

MATLAB_VERSION=&#39;matlab_version_here&#39;

class MatlabToCast(object):
    def __init__(self, source_file_path: str):
        &#34;&#34;&#34;docstring&#34;&#34;&#34;
        
        # Read the MATLAB source file
        self.path = Path(source_file_path)
        self.source_file_name = self.path.name
        self.source = self.path.read_text()
        print(&#39;\nSOURCE:&#39;)
        print(self.source)

        # get a tree-sitter tree based on source input
        matlab_tree_builder = MatlabTreeBuilder()
        self.tree = matlab_tree_builder.get_tree(self.source)
        self.tree.root_node = matlab_tree_builder.clean_nodes(self.tree.root_node)

        print(&#39;\nSYNTAX TREE: &#39;)
        matlab_tree_builder.traverse_tree(self.tree)
        print(&#34;\n&#34;)

        # Walking data
        self.variable_context = VariableContext()
        self.node_helper = NodeHelper(self.source, self.source_file_name)

        # Create CAST object 
        self.out_cast = self.generate_cast()

        print(&#39;\nCAST objects:&#39;)
        for c in self.out_cast: 
            j = json.dumps(
                c.to_json_object(),
                sort_keys=True,
                indent=2,
            )
            print(j)
        print(&#39;CAST objects done\n\n&#39;)

    def generate_cast(self) -&gt; List[CAST]:
        &#34;&#34;&#34;Interface for generating CAST.&#34;&#34;&#34;
        print(&#34;generate_cast&#34;)
        modules = self.run(self.tree.root_node)
        print(&#39;\nMODULES:&#39;)
        for m in modules:
            print(m)
        print(&#34;MODULES done&#34;)

        return [CAST([generate_dummy_source_refs(module)], &#34;matlab&#34;) for module in modules]
        
    def run(self, root) -&gt; List[Module]:
        &#34;&#34;&#34;Annotated run routine.&#34;&#34;&#34;
        print(&#34;run start&#34;)
        print(&#34;\nTREE STRUCTURE ___________&#34;)
        # A MATLAB program has a body composed of n statements

        modules = []

        # Currently, we are supporting functions and subroutines defined outside of programs and modules
        # Other than comments, it is unclear if anything else is allowed.
        # TODO: Research the above
        print(&#34;\nNODE VISITS ___________&#34;)
        outer_body_nodes = get_children_by_types(root, [&#34;function&#34;, &#34;subroutine&#34;, &#34;assignment&#34;])
        if len(outer_body_nodes) &gt; 0:
            body = []
            for body_node in outer_body_nodes:
                child_cast = self.visit(body_node)
                if isinstance(child_cast, List):
                    body.extend(child_cast)
                elif isinstance(child_cast, AstNode):
                    body.append(child_cast)
            modules.append(Module(
                name=None,
                body=body,
                source_refs=[self.node_helper.get_source_ref(root)]
            ))
    
        return modules

    def visit(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#34;\nvisit&#34;)
        print(node.type)

        if node.type in [&#34;program&#34;, &#34;module&#34;, &#34;source_file&#34;] :
            return self.visit_module(node)
        elif node.type == &#34;internal_procedures&#34;:
            return self.visit_internal_procedures(node)
        elif node.type in [&#34;subroutine&#34;, &#34;function&#34;]:
            return self.visit_function_def(node)
        elif node.type in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
            return self.visit_function_call(node)
        elif node.type == &#34;use_statement&#34;:
            return self.visit_use_statement(node)
        elif node.type == &#34;variable_declaration&#34;:
            return self.visit_variable_declaration(node)
        elif node.type == &#34;assignment&#34;:
            return self.visit_assignment_statement(node)
        elif node.type == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node.type == &#34;name&#34;:
            return self.visit_name(node)
        elif node.type in [&#34;math_expression&#34;, &#34;relational_expression&#34;]:
            return self.visit_math_expression(node)
        elif node.type in [&#34;number&#34;, &#34;array&#34;, &#34;string&#34;, &#34;boolean&#34;]:
            return self.visit_literal(node)
        elif node.type == &#34;keyword_statement&#34;:
            return self.visit_keyword_statement(node)
        elif node.type == &#34;extent_specifier&#34;:
            return self.visit_extent_specifier(node)
        elif node.type == &#34;do_loop_statement&#34;:
            return self.visit_do_loop_statement(node)
        elif node.type == &#34;if_statement&#34;:
            return self.visit_if_statement(node)
        elif node.type == &#34;derived_type_definition&#34;:
            return self.visit_derived_type(node)
        elif node.type == &#34;derived_type_member_expression&#34;:
            return self.visit_derived_type_member_expression(node)
        else:
            return self._visit_passthrough(node)

    def visit_module(self, node: Node) -&gt; Module:
        &#34;&#34;&#34;Visitor for program and module statement. Returns a Module object&#34;&#34;&#34;
        print(&#39;visit_module&#39;)
        self.variable_context.push_context()
        
        program_body = []
        for child in node.children: 
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                program_body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                program_body.append(child_cast)
    
        self.variable_context.pop_context()
        
        return Module(
            name=None, #TODO: Fill out name field
            body=program_body,
            source_refs = [self.node_helper.get_source_ref(node)]
        )

    def visit_internal_procedures(self, node: Node) -&gt; List[FunctionDef]:
        &#34;&#34;&#34;Visitor for internal procedures. Returns list of FunctionDef&#34;&#34;&#34;
        print(&#39;visit_internal_procedures&#39;)
        internal_procedures = get_children_by_types(node, [&#34;function&#34;, &#34;subroutine&#34;])
        return [self.visit(procedure) for procedure in internal_procedures]

    def visit_name(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_name&#39;)
        # Node structure
        # (name)

        # First, we will check if this name is already defined, and if it is return the name node generated previously
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            return self.variable_context.get_node(identifier)

        return self.variable_context.add_variable(
            identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
        )

    def visit_function_def(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_function_def&#39;)
        # TODO: Refactor function def code to use new helper functions
        # Node structure
        # (subroutine)
        #   (subroutine_statement)
        #     (subroutine)
        #     (name)
        #     (parameters) - Optional
        #   (body_node) ...
        # (function)
        #   (function_statement)
        #     (function)
        #     (intrinsic_type) - Optional
        #     (name)
        #     (parameters) - Optional
        #     (function_result) - Optional
        #       (identifier)
        #  (body_node) ...

        # Create a new variable context
        self.variable_context.push_context()

        # Top level statement node
        statement_node = get_children_by_types(node, [&#34;subroutine_statement&#34;, &#34;function_statement&#34;])[0]
        name_node = get_first_child_by_type(statement_node, &#34;name&#34;)
        name = self.visit(
            name_node
        )  # Visit the name node to add it to the variable context

        # If this is a function, check for return type and return value
        intrinsic_type = None
        return_value = None
        if node.type == &#34;function&#34;:
            signature_qualifiers = get_children_by_types(
                statement_node, [&#34;intrinsic_type&#34;, &#34;function_result&#34;]
            )
            for qualifier in signature_qualifiers:
                if qualifier.type == &#34;intrinsic_type&#34;:
                    intrinsic_type = self.node_helper.get_identifier(qualifier)
                    self.variable_context.add_variable(
                        self.node_helper.get_identifier(name_node), intrinsic_type, None
                    )
                elif qualifier.type == &#34;function_result&#34;:
                    return_value = self.visit(
                        get_first_child_by_type(qualifier, &#34;identifier&#34;)
                    )  # TODO: UPDATE NODES
                    self.variable_context.add_return_value(return_value.val.name)

        # #TODO: What happens if function doesn&#39;t return anything?
        # If this is a function, and there is no explicit results variable, then we will assume the return value is the name of the function
        if not return_value:
            self.variable_context.add_return_value(
                self.node_helper.get_identifier(name_node)
            )

        # If funciton has both, then we also need to update the type of the return value in the variable context
        # It does not explicity have to be declared
        if return_value and intrinsic_type:
            self.variable_context.update_type(return_value.val.name, intrinsic_type)

        # Generating the function arguments by walking the parameters node
        func_args = []
        if parameters_node := get_first_child_by_type(statement_node, &#34;parameters&#34;):
            for parameter in get_non_control_children(parameters_node):
                # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
                # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
                self.variable_context.add_return_value(
                    self.node_helper.get_identifier(parameter)
                )
                func_args.append(self.visit(parameter))

        # The first child of function will be the function statement, the rest will be body nodes
        body = []
        for body_node in node.children[1:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # After creating the body, we can go back and update the var nodes we created for the arguments
        # We do this by looking for intent,in nodes
        for i, arg in enumerate(func_args):
            func_args[i].type = self.variable_context.get_type(arg.val.name)

        # TODO:
        # This logic can be made cleaner
        # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
        # If there is not, then we will create a dummy one
        return_found = False
        for child in body:
            if isinstance(child, ModelReturn):
                return_found = True
        if not return_found:
            body.append(self.visit_keyword_statement(node))

        # Pop variable context off of stack before leaving this scope
        self.variable_context.pop_context()

        return FunctionDef(
            name=name,
            func_args=func_args,
            body=body,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_function_call(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_function_call&#39;)
        # Pull relevent nodes
        if node.type == &#34;subroutine_call&#34;:
            function_node = node.children[1]
            arguments_node = node.children[2]
        elif node.type == &#34;call_expression&#34;:
            function_node = node.children[0]
            arguments_node = node.children[1]

        function_identifier = self.node_helper.get_identifier(function_node)

        # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
        # We will need to check if this is truly a function call or a subscript
        if self.variable_context.is_variable(function_identifier):
            if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
                return self._visit_get(
                    node
                )  # This overrides the visitor and forces us to visit another

        # TODO: What should get a name node? Instrincit functions? Imported functions?
        # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
        if self.variable_context.is_variable(function_identifier):
            func = self.variable_context.get_node(function_identifier)
        else:
            func = Name(function_identifier, -1)  # TODO: REFACTOR

        # Add arguments to arguments list
        arguments = []
        for argument in arguments_node.children:
            child_cast = self.visit(argument)
            if child_cast:
                arguments.append(child_cast)

        return Call(
            func=func,
            source_language=&#34;matlab&#34;,
            source_language_version=MATLAB_VERSION,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_keyword_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_keyword_statement&#39;)
        # Currently, the only keyword_identifier produced by tree-sitter is Return
        # However, there may be other instances

        # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
        # We keep track of values that need to be returned in the variable context
        return_values = self.variable_context.context_return_values[
            -1
        ]  # TODO: Make function for this

        if len(return_values) == 1:
            # TODO: Fix this case
            value = self.variable_context.get_node(list(return_values)[0])
        elif len(return_values) &gt; 1:
            value = LiteralValue(
                value_type=&#34;Tuple&#34;,
                value=[
                    Var(
                        val=self.variable_context.get_node(ret),
                        type=self.variable_context.get_type(ret),
                        default_value=None,
                        source_refs=None,
                    )
                    for ret in return_values
                ],
                source_code_data_type=None,  # TODO: REFACTOR
                source_refs=None,
            )
        else:
            value = LiteralValue(val=None, type=None, source_refs=None)

        return ModelReturn(
            value=value, source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_use_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_use_statement&#39;)
        # (use)
        #   (use)
        #   (module_name)

        ## Pull relevent child nodes
        module_name_node = get_first_child_by_type(node, &#34;module_name&#34;)
        module_name = self.node_helper.get_identifier(module_name_node)
        included_items_node = get_first_child_by_type(node, &#34;included_items&#34;)

        import_all = included_items_node is None
        import_alias = None  # TODO: Look into local-name and use-name fields

        # We need to check if this import is a full import of a module, i.e. use module
        # Or a partial import i.e. use module,only: sub1, sub2
        if import_all:
            return ModelImport(
                name=module_name,
                alias=import_alias,
                all=import_all,
                symbol=None,
                source_refs=None,
            )
        else:
            imports = []
            for symbol in get_non_control_children(included_items_node):
                symbol_identifier = self.node_helper.get_identifier(symbol)
                symbol_source_refs = [self.node_helper.get_source_ref(symbol)]
                imports.append(
                    ModelImport(
                        name=module_name,
                        alias=import_alias,
                        all=import_all,
                        symbol=symbol_identifier,
                        source_refs=symbol_source_refs,
                    )
                )

            return imports

    def visit_do_loop_statement(self, node) -&gt; Loop:
        &#34;&#34;&#34;Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
        The do while loop will be passed off to a seperate visitor. Returns a Loop object.
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do loop
        (do_loop_statement)
            (loop_control_expression)
                (...) ...
            (body) ...
        
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;

        print(&#39;visit_do_loop_statement&#39;)
        # First check for
        # TODO: Add do until Loop support
        while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)
        if while_statement_node:
            return self._visit_while(node)

        # The first body node will be the node after the loop_control_expression
        # NOTE: This code is for the creation of the main body. The do loop will still add some additional nodes at the end of this body.
        body = []
        body_start_index = 1 + get_first_child_index(node, &#34;loop_control_expression&#34;)
        for body_node in node.children[body_start_index:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop
        # PRE:
        # _next(_iter(range(start, stop, step)))
        loop_control_node = get_first_child_by_type(node, &#34;loop_control_expression&#34;)
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            iterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            iterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            iterator = None
            start = None
            stop = None
            step = None

        range_name_node = self.get_gromet_function_node(&#34;range&#34;)
        iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
        next_name_node = self.get_gromet_function_node(&#34;next&#34;)
        generated_iter_name_node = self.variable_context.generate_iterator()
        stop_condition_name_node = self.variable_context.generate_stop_condition()

        # generated_iter_0 = iter(range(start, stop, step))
        pre = []
        pre.append(
            Assignment(
                left=Var(generated_iter_name_node, &#34;Iterator&#34;),
                right=Call(
                    iter_name_node,
                    arguments=[Call(range_name_node, arguments=[start, stop, step])],
                ),
            )
        )

        # (i, generated_iter_0, sc_0) = next(generated_iter_0)
        pre.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        iterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # EXPR
        expr = []
        expr = Operator(
            op=&#34;!=&#34;,  # TODO: Should this be == or !=
            operands=[
                Var(stop_condition_name_node, &#34;Boolean&#34;),
                LiteralValue(&#34;Boolean&#34;, True),
            ],
        )

        # BODY
        # At this point, the body nodes have already been visited
        # We just need to append the iterator next call
        body.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        iterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # POST
        post = []
        post.append(
            Assignment(
                left=iterator,
                right=Operator(op=&#34;+&#34;, operands=[iterator, step]),
            )
        )

        return Loop(
            pre=pre,
            expr=expr,
            body=body,
            post=post,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_if_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_if_statement&#39;)
        # (if_statement)
        #  (if)
        #  (parenthesised_expression)
        #  (then)
        #  (body_nodes) ...
        #  (elseif_clauses) ..
        #  (else_clause)
        #  (end_if_statement)

        # First we need to identify if this is a componund conditional
        # We can do this by counting the number of control characters in a relational expression
        child_types = [child.type for child in node.children]

        try:
            elseif_index = child_types.index(&#34;elseif_clause&#34;)
        except ValueError:
            elseif_index = -1

        try:
            else_index = child_types.index(&#34;else_clause&#34;)
        except ValueError:
            else_index = -1

        if elseif_index != -1:
            body_stop_index = elseif_index
        else:
            body_stop_index = else_index

        prev = None
        orelse = None
        # If there are else_if statements, they need
        if elseif_index != -1:
            orelse = ModelIf()
            prev = orelse
            for condition in node.children[elseif_index:else_index]:
                elseif_expr = self.visit(condition.children[2])
                elseif_body = [self.visit(child) for child in condition.children[4:]]

                prev.orelse = ModelIf(elseif_expr, elseif_body, None)
                prev = prev.orelse

        if else_index != -1:
            else_body = [
                self.visit(child) for child in node.children[else_index].children[1:]
            ]
            if prev:
                prev.orelse = else_body
            else:
                orelse = else_body

        if isinstance(orelse, ModelIf):
            orelse = orelse.orelse

        return ModelIf(
            expr=self.visit(node.children[1]),
            body=[self.visit(child) for child in node.children[3:body_stop_index]],
            orelse=orelse,
        )

    def visit_assignment_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_assignment_statement&#39;)
        left, _, right = node.children

        return Assignment(
            left=self.visit(left),
            right=self.visit(right),
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_literal(self, node) -&gt; LiteralValue:
        &#34;&#34;&#34;Visitor for literals. Returns a LiteralValue&#34;&#34;&#34;
        print(&#39;visit_literal&#39;)
        literal_type = node.type
        literal_value = self.node_helper.get_identifier(node)
        literal_source_ref = self.node_helper.get_source_ref(node)

        if literal_type == &#34;number&#34;:
            # Check if this is a real value, or an Integer
            if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
                return LiteralValue(
                    value_type=&#34;AbstractFloat&#34;,  # TODO verify this value
                    value=literal_value,
                    source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;real&#34;],
                    source_refs=[literal_source_ref],
                )
            else:
                return LiteralValue(
                    value_type=&#34;Integer&#34;,
                    value=literal_value,
                    source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;integer&#34;],
                    source_refs=[literal_source_ref],
                )

        elif literal_type == &#34;string&#34;:
            return LiteralValue(
                value_type=&#34;Character&#34;,
                value=literal_value,
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;character&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;boolean&#34;:
            return LiteralValue(
                value_type=&#34;Boolean&#34;,
                value=literal_value,
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;logical&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;array_literal&#34;:
            # There are a multiple ways to create an array literal. This visitor is for the traditional explicit creation (/ 1,2,3 /)
            # For the do loop based version, we pass it off to another visitor
            implied_do_loop_expression_node = get_first_child_by_type(
                node, &#34;implied_do_loop_expression&#34;
            )
            if implied_do_loop_expression_node:
                return self._visit_implied_do_loop(implied_do_loop_expression_node)

            return LiteralValue(
                value_type=&#34;List&#34;,
                value=[
                    self.visit(element) for element in get_non_control_children(node)
                ],
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;dimension&#34;],
                source_refs=[literal_source_ref],
            )


    def visit_identifier(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_identifier&#39;)
        # By default, this is unknown, but can be updated by other visitors
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            var_type = self.variable_context.get_type(identifier)
        else:
            var_type = &#34;Unknown&#34;

        # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
        # Fortran does have optional arguments introduced in F90, but these do not specify a default
        default_value = None

        # This is another case where we need to override the visitor to explicitly visit another node
        value = self.visit_name(node)

        return Var(
            val=value,
            type=var_type,
            default_value=default_value,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_math_expression(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_math_expression&#39;)
        op = self.node_helper.get_identifier(
            get_control_children(node)[0]
        )  # The operator will be the first control character

        operands = []
        for operand in get_non_control_children(node):
            operands.append(self.visit(operand))

        return Operator(
            source_language=&#34;matlab&#34;,
            interpreter=None,
            version=None,
            op=op,
            operands=operands,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_variable_declaration(self, node) -&gt; List:
        &#34;&#34;&#34;Visitor for variable declaration. Will return a List of Var and Assignment nodes.&#34;&#34;&#34;
        &#34;&#34;&#34;
        # Node structure
        (variable_declaration)
            (intrinsic_type)
            (type_qualifier)
                (qualifier)
                (value)
            (identifier) ...
            (assignment_statement) ...

        (variable_declaration)
            (derived_type)
                (type_name)
        &#34;&#34;&#34;
        print(&#39;visit_variable_declaration&#39;)
        # A variable can be declared with an intrinsic_type if its built-in, or a derived_type if it is user defined.
        intrinsic_type_node = get_first_child_by_type(node, &#34;intrinsic_type&#34;)
        derived_type_node = get_first_child_by_type(node, &#34;derived_type&#34;)

        variable_type = &#34;&#34;
        variable_intent = &#34;&#34;

        if intrinsic_type_node:
            type_map = {
                &#34;integer&#34;: &#34;Integer&#34;,
                &#34;real&#34;: &#34;AbstractFloat&#34;,
                &#34;complex&#34;: None,
                &#34;logical&#34;: &#34;Boolean&#34;,
                &#34;character&#34;: &#34;String&#34;,
            }
            variable_type = type_map[self.node_helper.get_identifier(intrinsic_type_node)]
        elif derived_type_node:
            variable_type = self.node_helper.get_identifier(
                get_first_child_by_type(derived_type_node, &#34;type_name&#34;, recurse=True),
            )

        # There are multiple type qualifiers that change the way we generate a variable
        # For example, we need to determine if we are creating an array (dimension) or a single variable
        type_qualifiers = get_children_by_types(node, [&#34;type_qualifier&#34;])
        for qualifier in type_qualifiers:
            field = self.node_helper.get_identifier(qualifier.children[0])

            if field == &#34;dimension&#34;:
                variable_type = &#34;List&#34;
            elif field == &#34;intent&#34;:
                variable_intent = self.node_helper.get_identifier(qualifier.children[1])

        # You can declare multiple variables of the same type in a single statement, so we need to create a Var or Assignment node for each instance
        definied_variables = get_children_by_types(
            node,
            [
                &#34;identifier&#34;,  # Variable declaration
                &#34;assignment_statement&#34;,  # Variable assignment
                &#34;call_expression&#34;,  # Dimension without intent
            ],
        )
        vars = []
        for variable in definied_variables:
            if variable.type == &#34;assignment_statement&#34;:
                if variable.children[0].type == &#34;call_expression&#34;:
                    vars.append(
                        Assignment(
                            left=self.visit(
                                get_first_child_by_type(
                                    variable.children[0], &#34;identifier&#34;
                                )
                            ),
                            right=self.visit(variable.children[2]),
                            source_refs=[
                                self.node_helper.get_source_ref(variable)
                            ],
                        )
                    )
                    vars[-1].left.type = &#34;dimension&#34;
                    self.variable_context.update_type(
                        vars[-1].left.val.name, &#34;dimension&#34;
                    )
                else:
                    # If its a regular assignment, we can update the type normally
                    vars.append(self.visit(variable))
                    vars[-1].left.type = variable_type
                    self.variable_context.update_type(
                        vars[-1].left.val.name, variable_type
                    )

            elif variable.type == &#34;identifier&#34;:
                # A basic variable declaration, we visit the identifier and then update the type
                vars.append(self.visit(variable))
                vars[-1].type = variable_type
                self.variable_context.update_type(vars[-1].val.name, variable_type)
            elif variable.type == &#34;call_expression&#34;:
                # Declaring a dimension variable using the x(1:5) format. It will look like a call expression in tree-sitter.
                # We treat it like an identifier by visiting its identifier node. Then the type gets overridden by &#34;dimension&#34;
                vars.append(self.visit(get_first_child_by_type(variable, &#34;identifier&#34;)))
                vars[-1].type = &#34;dimension&#34;
                self.variable_context.update_type(vars[-1].val.name, &#34;dimension&#34;)

        # By default, all variables are added to a function&#39;s list of return values
        # If the intent is actually in, then we need to remove them from the list
        if variable_intent == &#34;in&#34;:
            for var in vars:
                self.variable_context.remove_return_value(var.val.name)

        return vars

    def visit_extent_specifier(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_extent_specifier&#39;)
        # Node structure
        # (extent_specifier)
        #   (identifier)
        #   (identifier)

        # The extent specifier is the same as a slice, it can have a start, stop, and step
        # We can determine these by looking at the number of control characters in this node.
        # Fortran uses the character &#39;:&#39; to differentiate these values
        argument_pointer = 0
        arguments = [
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
        ]
        for child in node.children:
            if child.type == &#34;:&#34;:
                argument_pointer += 1
            else:
                arguments[argument_pointer] = self.visit(child)

        return Call(
            func=self.get_gromet_function_node(&#34;slice&#34;),
            source_language=&#34;matlab&#34;,
            source_language_version=MATLAB_VERSION,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type(self, node: Node) -&gt; RecordDef:
        &#34;&#34;&#34;Visitor function for derived type definition. Will return a RecordDef&#34;&#34;&#34;
        &#34;&#34;&#34;Node Structure:
        (derived_type_definition)
            (derived_type_statement)
                (base)
                    (base_type_specifier)
                        (identifier)
                (type_name)
            (BODY_NODES)
            ...
        &#34;&#34;&#34;
        print(&#39;visit_derived_type&#39;)


        record_name = self.node_helper.get_identifier(
            get_first_child_by_type(node, &#34;type_name&#34;, recurse=True)
        )

        # There is no multiple inheritance in Fortran, so a type may only extend 1 other type
        bases = []
        derived_type_statement_node = get_first_child_by_type(
            node, &#34;derived_type_statement&#34;
        )
        base_node = get_first_child_by_type(
            derived_type_statement_node, &#34;identifier&#34;, recurse=True
        )
        if base_node:
            bases.append([self.node_helper.get_identifier(base_node)])

        # A derived type can contain symbols with the same name as those already in the main program body.
        # If we tell the variable context we are in a record definition, it will append the type name as a prefix to all defined variables.
        self.variable_context.enter_record_definition(record_name)

        # TODO: Full support for this requires handling the contains statement generally
        funcs = []
        derived_type_procedures_node = get_first_child_by_type(
            node, &#34;derived_type_procedures&#34;
        )
        if derived_type_procedures_node:
            for procedure_node in get_children_by_types(
                derived_type_procedures_node, [&#34;procedure_statement&#34;]
            ):
                funcs.append(
                    self.visit_name(
                        get_first_child_by_type(procedure_node, &#34;method_name&#34;)
                    )
                )

        # A derived type can only have variable declarations in its body.
        fields = []
        variable_declarations = [
            self.visit(variable_declaration)
            for variable_declaration in get_children_by_types(
                node, [&#34;variable_declaration&#34;]
            )
        ]
        for declaration in variable_declarations:
            # Variable declarations always returns a list of Var or Assignment, even when only one var is being created
            for var in declaration:
                if isinstance(var, Var):
                    fields.append(var)
                elif isinstance(var, Assignment):
                    # Since this is a record definition, an assignment is actually equivalent to setting the default value
                    var.left.default_value = var.right
                    fields.append(var.left)
                # TODO: Handle dimension type (Call type)
                elif isinstance(var, Call):
                    pass
        # Leaving the record definition sets the prefix back to an empty string
        self.variable_context.exit_record_definition()

        return RecordDef(
            name=record_name,
            bases=bases,
            funcs=funcs,
            fields=fields,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type_member_expression(self, node) -&gt; Attribute:
        &#34;&#34;&#34;Visitor function for derived type access. Returns an Attribute object&#34;&#34;&#34;
        &#34;&#34;&#34; Node Structure
        Scalar Access
        (derived_type_member_expression)
            (identifier)
            (type_member)

        Dimensional Access
        (derived_type_member_expression)
            (call_expression)
                (identifier)
                (argument_list)
            (type_member)
        &#34;&#34;&#34;
        print(&#39;visit_derived_type_member_expression&#39;)

        # If we are accessing an attribute of a scalar type, we can simply pull the name node from the variable context.
        # However, if this is a dimensional type, we must convert it to a call to _get.
        call_expression_node = get_first_child_by_type(node, &#34;call_expression&#34;)
        if call_expression_node:
            value = self._visit_get(call_expression_node)
        else:
            value = self.variable_context.get_node(
                self.node_helper.get_identifier(
                    get_first_child_by_type(node, &#34;identifier&#34;, recurse=True),
                )
            )

        attr = self.node_helper.get_identifier(
            get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)
        )

        return Attribute(
            value=value,
            attr=attr,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    # NOTE: This function starts with _ because it will never be dispatched to directly. There is not a get node in the tree-sitter parse tree.
    # From context, we will determine when we are accessing an element of a List, and call this function,
    def _visit_get(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;_visit_get&#39;)
        # Node structure
        # (call_expression)
        #  (identifier)
        #  (argument_list)

        identifier_node = node.children[0]
        argument_nodes = get_non_control_children(node.children[1])

        # First argument to get is the List itself. We can get this by passing the identifier to the identifier visitor
        arguments = []
        arguments.append(self.visit(identifier_node))

        # If there are more than one arguments, then this is a multi dimensional array and we need to use an extended slice
        if len(argument_nodes) &gt; 1:
            dimension_list = LiteralValue()
            dimension_list.value_type = &#34;List&#34;
            dimension_list.value = []
            for argument in argument_nodes:
                dimension_list.value.append(self.visit(argument))

            extslice_call = Call()
            extslice_call.func = self.get_gromet_function_node(&#34;ext_slice&#34;)
            extslice_call.arguments = []
            extslice_call.arguments.append(dimension_list)

            arguments.append(extslice_call)
        else:
            arguments.append(self.visit(argument_nodes[0]))

        return Call(
            func=self.get_gromet_function_node(&#34;get&#34;),
            source_language=&#34;matlab&#34;,
            source_language_version=MATLAB_VERSION,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_set(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;_visit_set&#39;)
        # Node structure
        # (assignment_statement)
        #  (call_expression)
        #  (right side)

        left, _, right = node.children

        # The left side is equivilent to a call gromet &#34;get&#34;, so we will first pass the left side to the get visitor
        # Then we can easily convert this to a &#34;set&#34; call by modifying the fields and then appending the right side to the function arguments
        cast_call = self._visit_get(left)
        cast_call.func = self.get_gromet_function_node(&#34;set&#34;)
        cast_call.arguments.append(self.visit(right))

        return cast_call

    def _visit_while(self, node) -&gt; Loop:
        &#34;&#34;&#34;Custom visitor for while loop. Returns a Loop object&#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;
        print(&#39;_visit_while&#39;)
        while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)

        # The first body node will be the node after the while_statement
        body = []
        body_start_index = 1 + get_first_child_index(node, &#34;while_statement&#34;)
        for body_node in node.children[body_start_index:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # We don&#39;t have explicit handling for parenthesized_expression, but the passthrough handler will make sure that we visit the expression correctly.
        expr = self.visit(
            get_first_child_by_type(while_statement_node, &#34;parenthesized_expression&#34;)
        )

        return Loop(
            pre=[],  # TODO: Should pre and post contain anything?
            expr=expr,
            body=body,
            post=[],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_implied_do_loop(self, node) -&gt; Call:
        &#34;&#34;&#34;Custom visitor for implied_do_loop array literal. This form gets converted to a call to range&#34;&#34;&#34;
        # TODO: This loop_control is the same as the do loop. Can we turn this into one visitor?
        print(&#39;_visit_implied_do_loop&#39;)
        loop_control_node = get_first_child_by_type(
            node, &#34;loop_control_expression&#34;, recurse=True
        )
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            iterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            iterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            iterator = None
            start = None
            stop = None
            step = None

        return Call(
            func=self.get_gromet_function_node(&#34;range&#34;),
            source_language=None,
            source_language_version=None,
            arguments=[start, stop, step],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_passthrough(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;_visit_passthrough&#39;)
        if len(node.children) == 0:
            return None

        for child in node.children:
            child_cast = self.visit(child)
            if child_cast:
                return child_cast

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;get_gromet_function_node&#39;)
        # Idealy, we would be able to create a dummy node and just call the name visitor.
        # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
        if self.variable_context.is_variable(func_name):
            return self.variable_context.get_node(func_name)

        return self.variable_context.add_variable(func_name, &#34;function&#34;, None)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast"><code class="flex name class">
<span>class <span class="ident">MatlabToCast</span></span>
<span>(</span><span>source_file_path:str)</span>
</code></dt>
<dd>
<div class="desc"><p>docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatlabToCast(object):
    def __init__(self, source_file_path: str):
        &#34;&#34;&#34;docstring&#34;&#34;&#34;
        
        # Read the MATLAB source file
        self.path = Path(source_file_path)
        self.source_file_name = self.path.name
        self.source = self.path.read_text()
        print(&#39;\nSOURCE:&#39;)
        print(self.source)

        # get a tree-sitter tree based on source input
        matlab_tree_builder = MatlabTreeBuilder()
        self.tree = matlab_tree_builder.get_tree(self.source)
        self.tree.root_node = matlab_tree_builder.clean_nodes(self.tree.root_node)

        print(&#39;\nSYNTAX TREE: &#39;)
        matlab_tree_builder.traverse_tree(self.tree)
        print(&#34;\n&#34;)

        # Walking data
        self.variable_context = VariableContext()
        self.node_helper = NodeHelper(self.source, self.source_file_name)

        # Create CAST object 
        self.out_cast = self.generate_cast()

        print(&#39;\nCAST objects:&#39;)
        for c in self.out_cast: 
            j = json.dumps(
                c.to_json_object(),
                sort_keys=True,
                indent=2,
            )
            print(j)
        print(&#39;CAST objects done\n\n&#39;)

    def generate_cast(self) -&gt; List[CAST]:
        &#34;&#34;&#34;Interface for generating CAST.&#34;&#34;&#34;
        print(&#34;generate_cast&#34;)
        modules = self.run(self.tree.root_node)
        print(&#39;\nMODULES:&#39;)
        for m in modules:
            print(m)
        print(&#34;MODULES done&#34;)

        return [CAST([generate_dummy_source_refs(module)], &#34;matlab&#34;) for module in modules]
        
    def run(self, root) -&gt; List[Module]:
        &#34;&#34;&#34;Annotated run routine.&#34;&#34;&#34;
        print(&#34;run start&#34;)
        print(&#34;\nTREE STRUCTURE ___________&#34;)
        # A MATLAB program has a body composed of n statements

        modules = []

        # Currently, we are supporting functions and subroutines defined outside of programs and modules
        # Other than comments, it is unclear if anything else is allowed.
        # TODO: Research the above
        print(&#34;\nNODE VISITS ___________&#34;)
        outer_body_nodes = get_children_by_types(root, [&#34;function&#34;, &#34;subroutine&#34;, &#34;assignment&#34;])
        if len(outer_body_nodes) &gt; 0:
            body = []
            for body_node in outer_body_nodes:
                child_cast = self.visit(body_node)
                if isinstance(child_cast, List):
                    body.extend(child_cast)
                elif isinstance(child_cast, AstNode):
                    body.append(child_cast)
            modules.append(Module(
                name=None,
                body=body,
                source_refs=[self.node_helper.get_source_ref(root)]
            ))
    
        return modules

    def visit(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#34;\nvisit&#34;)
        print(node.type)

        if node.type in [&#34;program&#34;, &#34;module&#34;, &#34;source_file&#34;] :
            return self.visit_module(node)
        elif node.type == &#34;internal_procedures&#34;:
            return self.visit_internal_procedures(node)
        elif node.type in [&#34;subroutine&#34;, &#34;function&#34;]:
            return self.visit_function_def(node)
        elif node.type in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
            return self.visit_function_call(node)
        elif node.type == &#34;use_statement&#34;:
            return self.visit_use_statement(node)
        elif node.type == &#34;variable_declaration&#34;:
            return self.visit_variable_declaration(node)
        elif node.type == &#34;assignment&#34;:
            return self.visit_assignment_statement(node)
        elif node.type == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node.type == &#34;name&#34;:
            return self.visit_name(node)
        elif node.type in [&#34;math_expression&#34;, &#34;relational_expression&#34;]:
            return self.visit_math_expression(node)
        elif node.type in [&#34;number&#34;, &#34;array&#34;, &#34;string&#34;, &#34;boolean&#34;]:
            return self.visit_literal(node)
        elif node.type == &#34;keyword_statement&#34;:
            return self.visit_keyword_statement(node)
        elif node.type == &#34;extent_specifier&#34;:
            return self.visit_extent_specifier(node)
        elif node.type == &#34;do_loop_statement&#34;:
            return self.visit_do_loop_statement(node)
        elif node.type == &#34;if_statement&#34;:
            return self.visit_if_statement(node)
        elif node.type == &#34;derived_type_definition&#34;:
            return self.visit_derived_type(node)
        elif node.type == &#34;derived_type_member_expression&#34;:
            return self.visit_derived_type_member_expression(node)
        else:
            return self._visit_passthrough(node)

    def visit_module(self, node: Node) -&gt; Module:
        &#34;&#34;&#34;Visitor for program and module statement. Returns a Module object&#34;&#34;&#34;
        print(&#39;visit_module&#39;)
        self.variable_context.push_context()
        
        program_body = []
        for child in node.children: 
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                program_body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                program_body.append(child_cast)
    
        self.variable_context.pop_context()
        
        return Module(
            name=None, #TODO: Fill out name field
            body=program_body,
            source_refs = [self.node_helper.get_source_ref(node)]
        )

    def visit_internal_procedures(self, node: Node) -&gt; List[FunctionDef]:
        &#34;&#34;&#34;Visitor for internal procedures. Returns list of FunctionDef&#34;&#34;&#34;
        print(&#39;visit_internal_procedures&#39;)
        internal_procedures = get_children_by_types(node, [&#34;function&#34;, &#34;subroutine&#34;])
        return [self.visit(procedure) for procedure in internal_procedures]

    def visit_name(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_name&#39;)
        # Node structure
        # (name)

        # First, we will check if this name is already defined, and if it is return the name node generated previously
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            return self.variable_context.get_node(identifier)

        return self.variable_context.add_variable(
            identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
        )

    def visit_function_def(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_function_def&#39;)
        # TODO: Refactor function def code to use new helper functions
        # Node structure
        # (subroutine)
        #   (subroutine_statement)
        #     (subroutine)
        #     (name)
        #     (parameters) - Optional
        #   (body_node) ...
        # (function)
        #   (function_statement)
        #     (function)
        #     (intrinsic_type) - Optional
        #     (name)
        #     (parameters) - Optional
        #     (function_result) - Optional
        #       (identifier)
        #  (body_node) ...

        # Create a new variable context
        self.variable_context.push_context()

        # Top level statement node
        statement_node = get_children_by_types(node, [&#34;subroutine_statement&#34;, &#34;function_statement&#34;])[0]
        name_node = get_first_child_by_type(statement_node, &#34;name&#34;)
        name = self.visit(
            name_node
        )  # Visit the name node to add it to the variable context

        # If this is a function, check for return type and return value
        intrinsic_type = None
        return_value = None
        if node.type == &#34;function&#34;:
            signature_qualifiers = get_children_by_types(
                statement_node, [&#34;intrinsic_type&#34;, &#34;function_result&#34;]
            )
            for qualifier in signature_qualifiers:
                if qualifier.type == &#34;intrinsic_type&#34;:
                    intrinsic_type = self.node_helper.get_identifier(qualifier)
                    self.variable_context.add_variable(
                        self.node_helper.get_identifier(name_node), intrinsic_type, None
                    )
                elif qualifier.type == &#34;function_result&#34;:
                    return_value = self.visit(
                        get_first_child_by_type(qualifier, &#34;identifier&#34;)
                    )  # TODO: UPDATE NODES
                    self.variable_context.add_return_value(return_value.val.name)

        # #TODO: What happens if function doesn&#39;t return anything?
        # If this is a function, and there is no explicit results variable, then we will assume the return value is the name of the function
        if not return_value:
            self.variable_context.add_return_value(
                self.node_helper.get_identifier(name_node)
            )

        # If funciton has both, then we also need to update the type of the return value in the variable context
        # It does not explicity have to be declared
        if return_value and intrinsic_type:
            self.variable_context.update_type(return_value.val.name, intrinsic_type)

        # Generating the function arguments by walking the parameters node
        func_args = []
        if parameters_node := get_first_child_by_type(statement_node, &#34;parameters&#34;):
            for parameter in get_non_control_children(parameters_node):
                # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
                # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
                self.variable_context.add_return_value(
                    self.node_helper.get_identifier(parameter)
                )
                func_args.append(self.visit(parameter))

        # The first child of function will be the function statement, the rest will be body nodes
        body = []
        for body_node in node.children[1:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # After creating the body, we can go back and update the var nodes we created for the arguments
        # We do this by looking for intent,in nodes
        for i, arg in enumerate(func_args):
            func_args[i].type = self.variable_context.get_type(arg.val.name)

        # TODO:
        # This logic can be made cleaner
        # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
        # If there is not, then we will create a dummy one
        return_found = False
        for child in body:
            if isinstance(child, ModelReturn):
                return_found = True
        if not return_found:
            body.append(self.visit_keyword_statement(node))

        # Pop variable context off of stack before leaving this scope
        self.variable_context.pop_context()

        return FunctionDef(
            name=name,
            func_args=func_args,
            body=body,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_function_call(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_function_call&#39;)
        # Pull relevent nodes
        if node.type == &#34;subroutine_call&#34;:
            function_node = node.children[1]
            arguments_node = node.children[2]
        elif node.type == &#34;call_expression&#34;:
            function_node = node.children[0]
            arguments_node = node.children[1]

        function_identifier = self.node_helper.get_identifier(function_node)

        # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
        # We will need to check if this is truly a function call or a subscript
        if self.variable_context.is_variable(function_identifier):
            if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
                return self._visit_get(
                    node
                )  # This overrides the visitor and forces us to visit another

        # TODO: What should get a name node? Instrincit functions? Imported functions?
        # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
        if self.variable_context.is_variable(function_identifier):
            func = self.variable_context.get_node(function_identifier)
        else:
            func = Name(function_identifier, -1)  # TODO: REFACTOR

        # Add arguments to arguments list
        arguments = []
        for argument in arguments_node.children:
            child_cast = self.visit(argument)
            if child_cast:
                arguments.append(child_cast)

        return Call(
            func=func,
            source_language=&#34;matlab&#34;,
            source_language_version=MATLAB_VERSION,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_keyword_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_keyword_statement&#39;)
        # Currently, the only keyword_identifier produced by tree-sitter is Return
        # However, there may be other instances

        # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
        # We keep track of values that need to be returned in the variable context
        return_values = self.variable_context.context_return_values[
            -1
        ]  # TODO: Make function for this

        if len(return_values) == 1:
            # TODO: Fix this case
            value = self.variable_context.get_node(list(return_values)[0])
        elif len(return_values) &gt; 1:
            value = LiteralValue(
                value_type=&#34;Tuple&#34;,
                value=[
                    Var(
                        val=self.variable_context.get_node(ret),
                        type=self.variable_context.get_type(ret),
                        default_value=None,
                        source_refs=None,
                    )
                    for ret in return_values
                ],
                source_code_data_type=None,  # TODO: REFACTOR
                source_refs=None,
            )
        else:
            value = LiteralValue(val=None, type=None, source_refs=None)

        return ModelReturn(
            value=value, source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_use_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_use_statement&#39;)
        # (use)
        #   (use)
        #   (module_name)

        ## Pull relevent child nodes
        module_name_node = get_first_child_by_type(node, &#34;module_name&#34;)
        module_name = self.node_helper.get_identifier(module_name_node)
        included_items_node = get_first_child_by_type(node, &#34;included_items&#34;)

        import_all = included_items_node is None
        import_alias = None  # TODO: Look into local-name and use-name fields

        # We need to check if this import is a full import of a module, i.e. use module
        # Or a partial import i.e. use module,only: sub1, sub2
        if import_all:
            return ModelImport(
                name=module_name,
                alias=import_alias,
                all=import_all,
                symbol=None,
                source_refs=None,
            )
        else:
            imports = []
            for symbol in get_non_control_children(included_items_node):
                symbol_identifier = self.node_helper.get_identifier(symbol)
                symbol_source_refs = [self.node_helper.get_source_ref(symbol)]
                imports.append(
                    ModelImport(
                        name=module_name,
                        alias=import_alias,
                        all=import_all,
                        symbol=symbol_identifier,
                        source_refs=symbol_source_refs,
                    )
                )

            return imports

    def visit_do_loop_statement(self, node) -&gt; Loop:
        &#34;&#34;&#34;Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
        The do while loop will be passed off to a seperate visitor. Returns a Loop object.
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do loop
        (do_loop_statement)
            (loop_control_expression)
                (...) ...
            (body) ...
        
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;

        print(&#39;visit_do_loop_statement&#39;)
        # First check for
        # TODO: Add do until Loop support
        while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)
        if while_statement_node:
            return self._visit_while(node)

        # The first body node will be the node after the loop_control_expression
        # NOTE: This code is for the creation of the main body. The do loop will still add some additional nodes at the end of this body.
        body = []
        body_start_index = 1 + get_first_child_index(node, &#34;loop_control_expression&#34;)
        for body_node in node.children[body_start_index:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop
        # PRE:
        # _next(_iter(range(start, stop, step)))
        loop_control_node = get_first_child_by_type(node, &#34;loop_control_expression&#34;)
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            iterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            iterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            iterator = None
            start = None
            stop = None
            step = None

        range_name_node = self.get_gromet_function_node(&#34;range&#34;)
        iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
        next_name_node = self.get_gromet_function_node(&#34;next&#34;)
        generated_iter_name_node = self.variable_context.generate_iterator()
        stop_condition_name_node = self.variable_context.generate_stop_condition()

        # generated_iter_0 = iter(range(start, stop, step))
        pre = []
        pre.append(
            Assignment(
                left=Var(generated_iter_name_node, &#34;Iterator&#34;),
                right=Call(
                    iter_name_node,
                    arguments=[Call(range_name_node, arguments=[start, stop, step])],
                ),
            )
        )

        # (i, generated_iter_0, sc_0) = next(generated_iter_0)
        pre.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        iterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # EXPR
        expr = []
        expr = Operator(
            op=&#34;!=&#34;,  # TODO: Should this be == or !=
            operands=[
                Var(stop_condition_name_node, &#34;Boolean&#34;),
                LiteralValue(&#34;Boolean&#34;, True),
            ],
        )

        # BODY
        # At this point, the body nodes have already been visited
        # We just need to append the iterator next call
        body.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        iterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # POST
        post = []
        post.append(
            Assignment(
                left=iterator,
                right=Operator(op=&#34;+&#34;, operands=[iterator, step]),
            )
        )

        return Loop(
            pre=pre,
            expr=expr,
            body=body,
            post=post,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_if_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_if_statement&#39;)
        # (if_statement)
        #  (if)
        #  (parenthesised_expression)
        #  (then)
        #  (body_nodes) ...
        #  (elseif_clauses) ..
        #  (else_clause)
        #  (end_if_statement)

        # First we need to identify if this is a componund conditional
        # We can do this by counting the number of control characters in a relational expression
        child_types = [child.type for child in node.children]

        try:
            elseif_index = child_types.index(&#34;elseif_clause&#34;)
        except ValueError:
            elseif_index = -1

        try:
            else_index = child_types.index(&#34;else_clause&#34;)
        except ValueError:
            else_index = -1

        if elseif_index != -1:
            body_stop_index = elseif_index
        else:
            body_stop_index = else_index

        prev = None
        orelse = None
        # If there are else_if statements, they need
        if elseif_index != -1:
            orelse = ModelIf()
            prev = orelse
            for condition in node.children[elseif_index:else_index]:
                elseif_expr = self.visit(condition.children[2])
                elseif_body = [self.visit(child) for child in condition.children[4:]]

                prev.orelse = ModelIf(elseif_expr, elseif_body, None)
                prev = prev.orelse

        if else_index != -1:
            else_body = [
                self.visit(child) for child in node.children[else_index].children[1:]
            ]
            if prev:
                prev.orelse = else_body
            else:
                orelse = else_body

        if isinstance(orelse, ModelIf):
            orelse = orelse.orelse

        return ModelIf(
            expr=self.visit(node.children[1]),
            body=[self.visit(child) for child in node.children[3:body_stop_index]],
            orelse=orelse,
        )

    def visit_assignment_statement(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_assignment_statement&#39;)
        left, _, right = node.children

        return Assignment(
            left=self.visit(left),
            right=self.visit(right),
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_literal(self, node) -&gt; LiteralValue:
        &#34;&#34;&#34;Visitor for literals. Returns a LiteralValue&#34;&#34;&#34;
        print(&#39;visit_literal&#39;)
        literal_type = node.type
        literal_value = self.node_helper.get_identifier(node)
        literal_source_ref = self.node_helper.get_source_ref(node)

        if literal_type == &#34;number&#34;:
            # Check if this is a real value, or an Integer
            if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
                return LiteralValue(
                    value_type=&#34;AbstractFloat&#34;,  # TODO verify this value
                    value=literal_value,
                    source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;real&#34;],
                    source_refs=[literal_source_ref],
                )
            else:
                return LiteralValue(
                    value_type=&#34;Integer&#34;,
                    value=literal_value,
                    source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;integer&#34;],
                    source_refs=[literal_source_ref],
                )

        elif literal_type == &#34;string&#34;:
            return LiteralValue(
                value_type=&#34;Character&#34;,
                value=literal_value,
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;character&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;boolean&#34;:
            return LiteralValue(
                value_type=&#34;Boolean&#34;,
                value=literal_value,
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;logical&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;array_literal&#34;:
            # There are a multiple ways to create an array literal. This visitor is for the traditional explicit creation (/ 1,2,3 /)
            # For the do loop based version, we pass it off to another visitor
            implied_do_loop_expression_node = get_first_child_by_type(
                node, &#34;implied_do_loop_expression&#34;
            )
            if implied_do_loop_expression_node:
                return self._visit_implied_do_loop(implied_do_loop_expression_node)

            return LiteralValue(
                value_type=&#34;List&#34;,
                value=[
                    self.visit(element) for element in get_non_control_children(node)
                ],
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;dimension&#34;],
                source_refs=[literal_source_ref],
            )


    def visit_identifier(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_identifier&#39;)
        # By default, this is unknown, but can be updated by other visitors
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            var_type = self.variable_context.get_type(identifier)
        else:
            var_type = &#34;Unknown&#34;

        # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
        # Fortran does have optional arguments introduced in F90, but these do not specify a default
        default_value = None

        # This is another case where we need to override the visitor to explicitly visit another node
        value = self.visit_name(node)

        return Var(
            val=value,
            type=var_type,
            default_value=default_value,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_math_expression(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_math_expression&#39;)
        op = self.node_helper.get_identifier(
            get_control_children(node)[0]
        )  # The operator will be the first control character

        operands = []
        for operand in get_non_control_children(node):
            operands.append(self.visit(operand))

        return Operator(
            source_language=&#34;matlab&#34;,
            interpreter=None,
            version=None,
            op=op,
            operands=operands,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_variable_declaration(self, node) -&gt; List:
        &#34;&#34;&#34;Visitor for variable declaration. Will return a List of Var and Assignment nodes.&#34;&#34;&#34;
        &#34;&#34;&#34;
        # Node structure
        (variable_declaration)
            (intrinsic_type)
            (type_qualifier)
                (qualifier)
                (value)
            (identifier) ...
            (assignment_statement) ...

        (variable_declaration)
            (derived_type)
                (type_name)
        &#34;&#34;&#34;
        print(&#39;visit_variable_declaration&#39;)
        # A variable can be declared with an intrinsic_type if its built-in, or a derived_type if it is user defined.
        intrinsic_type_node = get_first_child_by_type(node, &#34;intrinsic_type&#34;)
        derived_type_node = get_first_child_by_type(node, &#34;derived_type&#34;)

        variable_type = &#34;&#34;
        variable_intent = &#34;&#34;

        if intrinsic_type_node:
            type_map = {
                &#34;integer&#34;: &#34;Integer&#34;,
                &#34;real&#34;: &#34;AbstractFloat&#34;,
                &#34;complex&#34;: None,
                &#34;logical&#34;: &#34;Boolean&#34;,
                &#34;character&#34;: &#34;String&#34;,
            }
            variable_type = type_map[self.node_helper.get_identifier(intrinsic_type_node)]
        elif derived_type_node:
            variable_type = self.node_helper.get_identifier(
                get_first_child_by_type(derived_type_node, &#34;type_name&#34;, recurse=True),
            )

        # There are multiple type qualifiers that change the way we generate a variable
        # For example, we need to determine if we are creating an array (dimension) or a single variable
        type_qualifiers = get_children_by_types(node, [&#34;type_qualifier&#34;])
        for qualifier in type_qualifiers:
            field = self.node_helper.get_identifier(qualifier.children[0])

            if field == &#34;dimension&#34;:
                variable_type = &#34;List&#34;
            elif field == &#34;intent&#34;:
                variable_intent = self.node_helper.get_identifier(qualifier.children[1])

        # You can declare multiple variables of the same type in a single statement, so we need to create a Var or Assignment node for each instance
        definied_variables = get_children_by_types(
            node,
            [
                &#34;identifier&#34;,  # Variable declaration
                &#34;assignment_statement&#34;,  # Variable assignment
                &#34;call_expression&#34;,  # Dimension without intent
            ],
        )
        vars = []
        for variable in definied_variables:
            if variable.type == &#34;assignment_statement&#34;:
                if variable.children[0].type == &#34;call_expression&#34;:
                    vars.append(
                        Assignment(
                            left=self.visit(
                                get_first_child_by_type(
                                    variable.children[0], &#34;identifier&#34;
                                )
                            ),
                            right=self.visit(variable.children[2]),
                            source_refs=[
                                self.node_helper.get_source_ref(variable)
                            ],
                        )
                    )
                    vars[-1].left.type = &#34;dimension&#34;
                    self.variable_context.update_type(
                        vars[-1].left.val.name, &#34;dimension&#34;
                    )
                else:
                    # If its a regular assignment, we can update the type normally
                    vars.append(self.visit(variable))
                    vars[-1].left.type = variable_type
                    self.variable_context.update_type(
                        vars[-1].left.val.name, variable_type
                    )

            elif variable.type == &#34;identifier&#34;:
                # A basic variable declaration, we visit the identifier and then update the type
                vars.append(self.visit(variable))
                vars[-1].type = variable_type
                self.variable_context.update_type(vars[-1].val.name, variable_type)
            elif variable.type == &#34;call_expression&#34;:
                # Declaring a dimension variable using the x(1:5) format. It will look like a call expression in tree-sitter.
                # We treat it like an identifier by visiting its identifier node. Then the type gets overridden by &#34;dimension&#34;
                vars.append(self.visit(get_first_child_by_type(variable, &#34;identifier&#34;)))
                vars[-1].type = &#34;dimension&#34;
                self.variable_context.update_type(vars[-1].val.name, &#34;dimension&#34;)

        # By default, all variables are added to a function&#39;s list of return values
        # If the intent is actually in, then we need to remove them from the list
        if variable_intent == &#34;in&#34;:
            for var in vars:
                self.variable_context.remove_return_value(var.val.name)

        return vars

    def visit_extent_specifier(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;visit_extent_specifier&#39;)
        # Node structure
        # (extent_specifier)
        #   (identifier)
        #   (identifier)

        # The extent specifier is the same as a slice, it can have a start, stop, and step
        # We can determine these by looking at the number of control characters in this node.
        # Fortran uses the character &#39;:&#39; to differentiate these values
        argument_pointer = 0
        arguments = [
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
        ]
        for child in node.children:
            if child.type == &#34;:&#34;:
                argument_pointer += 1
            else:
                arguments[argument_pointer] = self.visit(child)

        return Call(
            func=self.get_gromet_function_node(&#34;slice&#34;),
            source_language=&#34;matlab&#34;,
            source_language_version=MATLAB_VERSION,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type(self, node: Node) -&gt; RecordDef:
        &#34;&#34;&#34;Visitor function for derived type definition. Will return a RecordDef&#34;&#34;&#34;
        &#34;&#34;&#34;Node Structure:
        (derived_type_definition)
            (derived_type_statement)
                (base)
                    (base_type_specifier)
                        (identifier)
                (type_name)
            (BODY_NODES)
            ...
        &#34;&#34;&#34;
        print(&#39;visit_derived_type&#39;)


        record_name = self.node_helper.get_identifier(
            get_first_child_by_type(node, &#34;type_name&#34;, recurse=True)
        )

        # There is no multiple inheritance in Fortran, so a type may only extend 1 other type
        bases = []
        derived_type_statement_node = get_first_child_by_type(
            node, &#34;derived_type_statement&#34;
        )
        base_node = get_first_child_by_type(
            derived_type_statement_node, &#34;identifier&#34;, recurse=True
        )
        if base_node:
            bases.append([self.node_helper.get_identifier(base_node)])

        # A derived type can contain symbols with the same name as those already in the main program body.
        # If we tell the variable context we are in a record definition, it will append the type name as a prefix to all defined variables.
        self.variable_context.enter_record_definition(record_name)

        # TODO: Full support for this requires handling the contains statement generally
        funcs = []
        derived_type_procedures_node = get_first_child_by_type(
            node, &#34;derived_type_procedures&#34;
        )
        if derived_type_procedures_node:
            for procedure_node in get_children_by_types(
                derived_type_procedures_node, [&#34;procedure_statement&#34;]
            ):
                funcs.append(
                    self.visit_name(
                        get_first_child_by_type(procedure_node, &#34;method_name&#34;)
                    )
                )

        # A derived type can only have variable declarations in its body.
        fields = []
        variable_declarations = [
            self.visit(variable_declaration)
            for variable_declaration in get_children_by_types(
                node, [&#34;variable_declaration&#34;]
            )
        ]
        for declaration in variable_declarations:
            # Variable declarations always returns a list of Var or Assignment, even when only one var is being created
            for var in declaration:
                if isinstance(var, Var):
                    fields.append(var)
                elif isinstance(var, Assignment):
                    # Since this is a record definition, an assignment is actually equivalent to setting the default value
                    var.left.default_value = var.right
                    fields.append(var.left)
                # TODO: Handle dimension type (Call type)
                elif isinstance(var, Call):
                    pass
        # Leaving the record definition sets the prefix back to an empty string
        self.variable_context.exit_record_definition()

        return RecordDef(
            name=record_name,
            bases=bases,
            funcs=funcs,
            fields=fields,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type_member_expression(self, node) -&gt; Attribute:
        &#34;&#34;&#34;Visitor function for derived type access. Returns an Attribute object&#34;&#34;&#34;
        &#34;&#34;&#34; Node Structure
        Scalar Access
        (derived_type_member_expression)
            (identifier)
            (type_member)

        Dimensional Access
        (derived_type_member_expression)
            (call_expression)
                (identifier)
                (argument_list)
            (type_member)
        &#34;&#34;&#34;
        print(&#39;visit_derived_type_member_expression&#39;)

        # If we are accessing an attribute of a scalar type, we can simply pull the name node from the variable context.
        # However, if this is a dimensional type, we must convert it to a call to _get.
        call_expression_node = get_first_child_by_type(node, &#34;call_expression&#34;)
        if call_expression_node:
            value = self._visit_get(call_expression_node)
        else:
            value = self.variable_context.get_node(
                self.node_helper.get_identifier(
                    get_first_child_by_type(node, &#34;identifier&#34;, recurse=True),
                )
            )

        attr = self.node_helper.get_identifier(
            get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)
        )

        return Attribute(
            value=value,
            attr=attr,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    # NOTE: This function starts with _ because it will never be dispatched to directly. There is not a get node in the tree-sitter parse tree.
    # From context, we will determine when we are accessing an element of a List, and call this function,
    def _visit_get(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;_visit_get&#39;)
        # Node structure
        # (call_expression)
        #  (identifier)
        #  (argument_list)

        identifier_node = node.children[0]
        argument_nodes = get_non_control_children(node.children[1])

        # First argument to get is the List itself. We can get this by passing the identifier to the identifier visitor
        arguments = []
        arguments.append(self.visit(identifier_node))

        # If there are more than one arguments, then this is a multi dimensional array and we need to use an extended slice
        if len(argument_nodes) &gt; 1:
            dimension_list = LiteralValue()
            dimension_list.value_type = &#34;List&#34;
            dimension_list.value = []
            for argument in argument_nodes:
                dimension_list.value.append(self.visit(argument))

            extslice_call = Call()
            extslice_call.func = self.get_gromet_function_node(&#34;ext_slice&#34;)
            extslice_call.arguments = []
            extslice_call.arguments.append(dimension_list)

            arguments.append(extslice_call)
        else:
            arguments.append(self.visit(argument_nodes[0]))

        return Call(
            func=self.get_gromet_function_node(&#34;get&#34;),
            source_language=&#34;matlab&#34;,
            source_language_version=MATLAB_VERSION,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_set(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;_visit_set&#39;)
        # Node structure
        # (assignment_statement)
        #  (call_expression)
        #  (right side)

        left, _, right = node.children

        # The left side is equivilent to a call gromet &#34;get&#34;, so we will first pass the left side to the get visitor
        # Then we can easily convert this to a &#34;set&#34; call by modifying the fields and then appending the right side to the function arguments
        cast_call = self._visit_get(left)
        cast_call.func = self.get_gromet_function_node(&#34;set&#34;)
        cast_call.arguments.append(self.visit(right))

        return cast_call

    def _visit_while(self, node) -&gt; Loop:
        &#34;&#34;&#34;Custom visitor for while loop. Returns a Loop object&#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;
        print(&#39;_visit_while&#39;)
        while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)

        # The first body node will be the node after the while_statement
        body = []
        body_start_index = 1 + get_first_child_index(node, &#34;while_statement&#34;)
        for body_node in node.children[body_start_index:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # We don&#39;t have explicit handling for parenthesized_expression, but the passthrough handler will make sure that we visit the expression correctly.
        expr = self.visit(
            get_first_child_by_type(while_statement_node, &#34;parenthesized_expression&#34;)
        )

        return Loop(
            pre=[],  # TODO: Should pre and post contain anything?
            expr=expr,
            body=body,
            post=[],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_implied_do_loop(self, node) -&gt; Call:
        &#34;&#34;&#34;Custom visitor for implied_do_loop array literal. This form gets converted to a call to range&#34;&#34;&#34;
        # TODO: This loop_control is the same as the do loop. Can we turn this into one visitor?
        print(&#39;_visit_implied_do_loop&#39;)
        loop_control_node = get_first_child_by_type(
            node, &#34;loop_control_expression&#34;, recurse=True
        )
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            iterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            iterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            iterator = None
            start = None
            stop = None
            step = None

        return Call(
            func=self.get_gromet_function_node(&#34;range&#34;),
            source_language=None,
            source_language_version=None,
            arguments=[start, stop, step],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_passthrough(self, node):
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;_visit_passthrough&#39;)
        if len(node.children) == 0:
            return None

        for child in node.children:
            child_cast = self.visit(child)
            if child_cast:
                return child_cast

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        &#34;&#34;&#34;Docstring&#34;&#34;&#34;
        print(&#39;get_gromet_function_node&#39;)
        # Idealy, we would be able to create a dummy node and just call the name visitor.
        # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
        if self.variable_context.is_variable(func_name):
            return self.variable_context.get_node(func_name)

        return self.variable_context.add_variable(func_name, &#34;function&#34;, None)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.generate_cast"><code class="name flex">
<span>def <span class="ident">generate_cast</span></span>(<span>self) >List[<a title="skema.program_analysis.CAST2FN.cast.CAST" href="../../CAST2FN/cast.html#skema.program_analysis.CAST2FN.cast.CAST">CAST</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Interface for generating CAST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_cast(self) -&gt; List[CAST]:
    &#34;&#34;&#34;Interface for generating CAST.&#34;&#34;&#34;
    print(&#34;generate_cast&#34;)
    modules = self.run(self.tree.root_node)
    print(&#39;\nMODULES:&#39;)
    for m in modules:
        print(m)
    print(&#34;MODULES done&#34;)

    return [CAST([generate_dummy_source_refs(module)], &#34;matlab&#34;) for module in modules]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.get_gromet_function_node"><code class="name flex">
<span>def <span class="ident">get_gromet_function_node</span></span>(<span>self, func_name:str) ><a title="skema.program_analysis.CAST2FN.model.cast.name.Name" href="../../CAST2FN/model/cast/name.html#skema.program_analysis.CAST2FN.model.cast.name.Name">Name</a></span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gromet_function_node(self, func_name: str) -&gt; Name:
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;get_gromet_function_node&#39;)
    # Idealy, we would be able to create a dummy node and just call the name visitor.
    # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
    if self.variable_context.is_variable(func_name):
        return self.variable_context.get_node(func_name)

    return self.variable_context.add_variable(func_name, &#34;function&#34;, None)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, root) >List[<a title="skema.program_analysis.CAST2FN.model.cast.module.Module" href="../../CAST2FN/model/cast/module.html#skema.program_analysis.CAST2FN.model.cast.module.Module">Module</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Annotated run routine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, root) -&gt; List[Module]:
    &#34;&#34;&#34;Annotated run routine.&#34;&#34;&#34;
    print(&#34;run start&#34;)
    print(&#34;\nTREE STRUCTURE ___________&#34;)
    # A MATLAB program has a body composed of n statements

    modules = []

    # Currently, we are supporting functions and subroutines defined outside of programs and modules
    # Other than comments, it is unclear if anything else is allowed.
    # TODO: Research the above
    print(&#34;\nNODE VISITS ___________&#34;)
    outer_body_nodes = get_children_by_types(root, [&#34;function&#34;, &#34;subroutine&#34;, &#34;assignment&#34;])
    if len(outer_body_nodes) &gt; 0:
        body = []
        for body_node in outer_body_nodes:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)
        modules.append(Module(
            name=None,
            body=body,
            source_refs=[self.node_helper.get_source_ref(root)]
        ))

    return modules</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#34;\nvisit&#34;)
    print(node.type)

    if node.type in [&#34;program&#34;, &#34;module&#34;, &#34;source_file&#34;] :
        return self.visit_module(node)
    elif node.type == &#34;internal_procedures&#34;:
        return self.visit_internal_procedures(node)
    elif node.type in [&#34;subroutine&#34;, &#34;function&#34;]:
        return self.visit_function_def(node)
    elif node.type in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
        return self.visit_function_call(node)
    elif node.type == &#34;use_statement&#34;:
        return self.visit_use_statement(node)
    elif node.type == &#34;variable_declaration&#34;:
        return self.visit_variable_declaration(node)
    elif node.type == &#34;assignment&#34;:
        return self.visit_assignment_statement(node)
    elif node.type == &#34;identifier&#34;:
        return self.visit_identifier(node)
    elif node.type == &#34;name&#34;:
        return self.visit_name(node)
    elif node.type in [&#34;math_expression&#34;, &#34;relational_expression&#34;]:
        return self.visit_math_expression(node)
    elif node.type in [&#34;number&#34;, &#34;array&#34;, &#34;string&#34;, &#34;boolean&#34;]:
        return self.visit_literal(node)
    elif node.type == &#34;keyword_statement&#34;:
        return self.visit_keyword_statement(node)
    elif node.type == &#34;extent_specifier&#34;:
        return self.visit_extent_specifier(node)
    elif node.type == &#34;do_loop_statement&#34;:
        return self.visit_do_loop_statement(node)
    elif node.type == &#34;if_statement&#34;:
        return self.visit_if_statement(node)
    elif node.type == &#34;derived_type_definition&#34;:
        return self.visit_derived_type(node)
    elif node.type == &#34;derived_type_member_expression&#34;:
        return self.visit_derived_type_member_expression(node)
    else:
        return self._visit_passthrough(node)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_assignment_statement"><code class="name flex">
<span>def <span class="ident">visit_assignment_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_assignment_statement(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_assignment_statement&#39;)
    left, _, right = node.children

    return Assignment(
        left=self.visit(left),
        right=self.visit(right),
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_derived_type"><code class="name flex">
<span>def <span class="ident">visit_derived_type</span></span>(<span>self, node:tree_sitter.Node) ><a title="skema.program_analysis.CAST2FN.model.cast.record_def.RecordDef" href="../../CAST2FN/model/cast/record_def.html#skema.program_analysis.CAST2FN.model.cast.record_def.RecordDef">RecordDef</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor function for derived type definition. Will return a RecordDef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_derived_type(self, node: Node) -&gt; RecordDef:
    &#34;&#34;&#34;Visitor function for derived type definition. Will return a RecordDef&#34;&#34;&#34;
    &#34;&#34;&#34;Node Structure:
    (derived_type_definition)
        (derived_type_statement)
            (base)
                (base_type_specifier)
                    (identifier)
            (type_name)
        (BODY_NODES)
        ...
    &#34;&#34;&#34;
    print(&#39;visit_derived_type&#39;)


    record_name = self.node_helper.get_identifier(
        get_first_child_by_type(node, &#34;type_name&#34;, recurse=True)
    )

    # There is no multiple inheritance in Fortran, so a type may only extend 1 other type
    bases = []
    derived_type_statement_node = get_first_child_by_type(
        node, &#34;derived_type_statement&#34;
    )
    base_node = get_first_child_by_type(
        derived_type_statement_node, &#34;identifier&#34;, recurse=True
    )
    if base_node:
        bases.append([self.node_helper.get_identifier(base_node)])

    # A derived type can contain symbols with the same name as those already in the main program body.
    # If we tell the variable context we are in a record definition, it will append the type name as a prefix to all defined variables.
    self.variable_context.enter_record_definition(record_name)

    # TODO: Full support for this requires handling the contains statement generally
    funcs = []
    derived_type_procedures_node = get_first_child_by_type(
        node, &#34;derived_type_procedures&#34;
    )
    if derived_type_procedures_node:
        for procedure_node in get_children_by_types(
            derived_type_procedures_node, [&#34;procedure_statement&#34;]
        ):
            funcs.append(
                self.visit_name(
                    get_first_child_by_type(procedure_node, &#34;method_name&#34;)
                )
            )

    # A derived type can only have variable declarations in its body.
    fields = []
    variable_declarations = [
        self.visit(variable_declaration)
        for variable_declaration in get_children_by_types(
            node, [&#34;variable_declaration&#34;]
        )
    ]
    for declaration in variable_declarations:
        # Variable declarations always returns a list of Var or Assignment, even when only one var is being created
        for var in declaration:
            if isinstance(var, Var):
                fields.append(var)
            elif isinstance(var, Assignment):
                # Since this is a record definition, an assignment is actually equivalent to setting the default value
                var.left.default_value = var.right
                fields.append(var.left)
            # TODO: Handle dimension type (Call type)
            elif isinstance(var, Call):
                pass
    # Leaving the record definition sets the prefix back to an empty string
    self.variable_context.exit_record_definition()

    return RecordDef(
        name=record_name,
        bases=bases,
        funcs=funcs,
        fields=fields,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_derived_type_member_expression"><code class="name flex">
<span>def <span class="ident">visit_derived_type_member_expression</span></span>(<span>self, node) ><a title="skema.program_analysis.CAST2FN.model.cast.attribute.Attribute" href="../../CAST2FN/model/cast/attribute.html#skema.program_analysis.CAST2FN.model.cast.attribute.Attribute">Attribute</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor function for derived type access. Returns an Attribute object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_derived_type_member_expression(self, node) -&gt; Attribute:
    &#34;&#34;&#34;Visitor function for derived type access. Returns an Attribute object&#34;&#34;&#34;
    &#34;&#34;&#34; Node Structure
    Scalar Access
    (derived_type_member_expression)
        (identifier)
        (type_member)

    Dimensional Access
    (derived_type_member_expression)
        (call_expression)
            (identifier)
            (argument_list)
        (type_member)
    &#34;&#34;&#34;
    print(&#39;visit_derived_type_member_expression&#39;)

    # If we are accessing an attribute of a scalar type, we can simply pull the name node from the variable context.
    # However, if this is a dimensional type, we must convert it to a call to _get.
    call_expression_node = get_first_child_by_type(node, &#34;call_expression&#34;)
    if call_expression_node:
        value = self._visit_get(call_expression_node)
    else:
        value = self.variable_context.get_node(
            self.node_helper.get_identifier(
                get_first_child_by_type(node, &#34;identifier&#34;, recurse=True),
            )
        )

    attr = self.node_helper.get_identifier(
        get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)
    )

    return Attribute(
        value=value,
        attr=attr,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_do_loop_statement"><code class="name flex">
<span>def <span class="ident">visit_do_loop_statement</span></span>(<span>self, node) ><a title="skema.program_analysis.CAST2FN.model.cast.loop.Loop" href="../../CAST2FN/model/cast/loop.html#skema.program_analysis.CAST2FN.model.cast.loop.Loop">Loop</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
The do while loop will be passed off to a seperate visitor. Returns a Loop object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_do_loop_statement(self, node) -&gt; Loop:
    &#34;&#34;&#34;Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
    The do while loop will be passed off to a seperate visitor. Returns a Loop object.
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    Node structure
    Do loop
    (do_loop_statement)
        (loop_control_expression)
            (...) ...
        (body) ...
    
    Do while
    (do_loop_statement)
        (while_statement)
            (parenthesized_expression)
                (...) ...
        (body) ...
    &#34;&#34;&#34;

    print(&#39;visit_do_loop_statement&#39;)
    # First check for
    # TODO: Add do until Loop support
    while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)
    if while_statement_node:
        return self._visit_while(node)

    # The first body node will be the node after the loop_control_expression
    # NOTE: This code is for the creation of the main body. The do loop will still add some additional nodes at the end of this body.
    body = []
    body_start_index = 1 + get_first_child_index(node, &#34;loop_control_expression&#34;)
    for body_node in node.children[body_start_index:]:
        child_cast = self.visit(body_node)
        if isinstance(child_cast, List):
            body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            body.append(child_cast)

    # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop
    # PRE:
    # _next(_iter(range(start, stop, step)))
    loop_control_node = get_first_child_by_type(node, &#34;loop_control_expression&#34;)
    loop_control_children = get_non_control_children(loop_control_node)
    if len(loop_control_children) == 3:
        iterator, start, stop = [
            self.visit(child) for child in loop_control_children
        ]
        step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
    elif len(loop_control_children) == 4:
        iterator, start, stop, step = [
            self.visit(child) for child in loop_control_children
        ]
    else:
        iterator = None
        start = None
        stop = None
        step = None

    range_name_node = self.get_gromet_function_node(&#34;range&#34;)
    iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
    next_name_node = self.get_gromet_function_node(&#34;next&#34;)
    generated_iter_name_node = self.variable_context.generate_iterator()
    stop_condition_name_node = self.variable_context.generate_stop_condition()

    # generated_iter_0 = iter(range(start, stop, step))
    pre = []
    pre.append(
        Assignment(
            left=Var(generated_iter_name_node, &#34;Iterator&#34;),
            right=Call(
                iter_name_node,
                arguments=[Call(range_name_node, arguments=[start, stop, step])],
            ),
        )
    )

    # (i, generated_iter_0, sc_0) = next(generated_iter_0)
    pre.append(
        Assignment(
            left=LiteralValue(
                &#34;Tuple&#34;,
                [
                    iterator,
                    Var(generated_iter_name_node, &#34;Iterator&#34;),
                    Var(stop_condition_name_node, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_name_node,
                arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
            ),
        )
    )

    # EXPR
    expr = []
    expr = Operator(
        op=&#34;!=&#34;,  # TODO: Should this be == or !=
        operands=[
            Var(stop_condition_name_node, &#34;Boolean&#34;),
            LiteralValue(&#34;Boolean&#34;, True),
        ],
    )

    # BODY
    # At this point, the body nodes have already been visited
    # We just need to append the iterator next call
    body.append(
        Assignment(
            left=LiteralValue(
                &#34;Tuple&#34;,
                [
                    iterator,
                    Var(generated_iter_name_node, &#34;Iterator&#34;),
                    Var(stop_condition_name_node, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_name_node,
                arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
            ),
        )
    )

    # POST
    post = []
    post.append(
        Assignment(
            left=iterator,
            right=Operator(op=&#34;+&#34;, operands=[iterator, step]),
        )
    )

    return Loop(
        pre=pre,
        expr=expr,
        body=body,
        post=post,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_extent_specifier"><code class="name flex">
<span>def <span class="ident">visit_extent_specifier</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_extent_specifier(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_extent_specifier&#39;)
    # Node structure
    # (extent_specifier)
    #   (identifier)
    #   (identifier)

    # The extent specifier is the same as a slice, it can have a start, stop, and step
    # We can determine these by looking at the number of control characters in this node.
    # Fortran uses the character &#39;:&#39; to differentiate these values
    argument_pointer = 0
    arguments = [
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
    ]
    for child in node.children:
        if child.type == &#34;:&#34;:
            argument_pointer += 1
        else:
            arguments[argument_pointer] = self.visit(child)

    return Call(
        func=self.get_gromet_function_node(&#34;slice&#34;),
        source_language=&#34;matlab&#34;,
        source_language_version=MATLAB_VERSION,
        arguments=arguments,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_function_call"><code class="name flex">
<span>def <span class="ident">visit_function_call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_call(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_function_call&#39;)
    # Pull relevent nodes
    if node.type == &#34;subroutine_call&#34;:
        function_node = node.children[1]
        arguments_node = node.children[2]
    elif node.type == &#34;call_expression&#34;:
        function_node = node.children[0]
        arguments_node = node.children[1]

    function_identifier = self.node_helper.get_identifier(function_node)

    # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
    # We will need to check if this is truly a function call or a subscript
    if self.variable_context.is_variable(function_identifier):
        if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
            return self._visit_get(
                node
            )  # This overrides the visitor and forces us to visit another

    # TODO: What should get a name node? Instrincit functions? Imported functions?
    # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
    if self.variable_context.is_variable(function_identifier):
        func = self.variable_context.get_node(function_identifier)
    else:
        func = Name(function_identifier, -1)  # TODO: REFACTOR

    # Add arguments to arguments list
    arguments = []
    for argument in arguments_node.children:
        child_cast = self.visit(argument)
        if child_cast:
            arguments.append(child_cast)

    return Call(
        func=func,
        source_language=&#34;matlab&#34;,
        source_language_version=MATLAB_VERSION,
        arguments=arguments,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_function_def"><code class="name flex">
<span>def <span class="ident">visit_function_def</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_def(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_function_def&#39;)
    # TODO: Refactor function def code to use new helper functions
    # Node structure
    # (subroutine)
    #   (subroutine_statement)
    #     (subroutine)
    #     (name)
    #     (parameters) - Optional
    #   (body_node) ...
    # (function)
    #   (function_statement)
    #     (function)
    #     (intrinsic_type) - Optional
    #     (name)
    #     (parameters) - Optional
    #     (function_result) - Optional
    #       (identifier)
    #  (body_node) ...

    # Create a new variable context
    self.variable_context.push_context()

    # Top level statement node
    statement_node = get_children_by_types(node, [&#34;subroutine_statement&#34;, &#34;function_statement&#34;])[0]
    name_node = get_first_child_by_type(statement_node, &#34;name&#34;)
    name = self.visit(
        name_node
    )  # Visit the name node to add it to the variable context

    # If this is a function, check for return type and return value
    intrinsic_type = None
    return_value = None
    if node.type == &#34;function&#34;:
        signature_qualifiers = get_children_by_types(
            statement_node, [&#34;intrinsic_type&#34;, &#34;function_result&#34;]
        )
        for qualifier in signature_qualifiers:
            if qualifier.type == &#34;intrinsic_type&#34;:
                intrinsic_type = self.node_helper.get_identifier(qualifier)
                self.variable_context.add_variable(
                    self.node_helper.get_identifier(name_node), intrinsic_type, None
                )
            elif qualifier.type == &#34;function_result&#34;:
                return_value = self.visit(
                    get_first_child_by_type(qualifier, &#34;identifier&#34;)
                )  # TODO: UPDATE NODES
                self.variable_context.add_return_value(return_value.val.name)

    # #TODO: What happens if function doesn&#39;t return anything?
    # If this is a function, and there is no explicit results variable, then we will assume the return value is the name of the function
    if not return_value:
        self.variable_context.add_return_value(
            self.node_helper.get_identifier(name_node)
        )

    # If funciton has both, then we also need to update the type of the return value in the variable context
    # It does not explicity have to be declared
    if return_value and intrinsic_type:
        self.variable_context.update_type(return_value.val.name, intrinsic_type)

    # Generating the function arguments by walking the parameters node
    func_args = []
    if parameters_node := get_first_child_by_type(statement_node, &#34;parameters&#34;):
        for parameter in get_non_control_children(parameters_node):
            # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
            # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
            self.variable_context.add_return_value(
                self.node_helper.get_identifier(parameter)
            )
            func_args.append(self.visit(parameter))

    # The first child of function will be the function statement, the rest will be body nodes
    body = []
    for body_node in node.children[1:]:
        child_cast = self.visit(body_node)
        if isinstance(child_cast, List):
            body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            body.append(child_cast)

    # After creating the body, we can go back and update the var nodes we created for the arguments
    # We do this by looking for intent,in nodes
    for i, arg in enumerate(func_args):
        func_args[i].type = self.variable_context.get_type(arg.val.name)

    # TODO:
    # This logic can be made cleaner
    # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
    # If there is not, then we will create a dummy one
    return_found = False
    for child in body:
        if isinstance(child, ModelReturn):
            return_found = True
    if not return_found:
        body.append(self.visit_keyword_statement(node))

    # Pop variable context off of stack before leaving this scope
    self.variable_context.pop_context()

    return FunctionDef(
        name=name,
        func_args=func_args,
        body=body,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_identifier"><code class="name flex">
<span>def <span class="ident">visit_identifier</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_identifier(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_identifier&#39;)
    # By default, this is unknown, but can be updated by other visitors
    identifier = self.node_helper.get_identifier(node)
    if self.variable_context.is_variable(identifier):
        var_type = self.variable_context.get_type(identifier)
    else:
        var_type = &#34;Unknown&#34;

    # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
    # Fortran does have optional arguments introduced in F90, but these do not specify a default
    default_value = None

    # This is another case where we need to override the visitor to explicitly visit another node
    value = self.visit_name(node)

    return Var(
        val=value,
        type=var_type,
        default_value=default_value,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_if_statement"><code class="name flex">
<span>def <span class="ident">visit_if_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_if_statement(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_if_statement&#39;)
    # (if_statement)
    #  (if)
    #  (parenthesised_expression)
    #  (then)
    #  (body_nodes) ...
    #  (elseif_clauses) ..
    #  (else_clause)
    #  (end_if_statement)

    # First we need to identify if this is a componund conditional
    # We can do this by counting the number of control characters in a relational expression
    child_types = [child.type for child in node.children]

    try:
        elseif_index = child_types.index(&#34;elseif_clause&#34;)
    except ValueError:
        elseif_index = -1

    try:
        else_index = child_types.index(&#34;else_clause&#34;)
    except ValueError:
        else_index = -1

    if elseif_index != -1:
        body_stop_index = elseif_index
    else:
        body_stop_index = else_index

    prev = None
    orelse = None
    # If there are else_if statements, they need
    if elseif_index != -1:
        orelse = ModelIf()
        prev = orelse
        for condition in node.children[elseif_index:else_index]:
            elseif_expr = self.visit(condition.children[2])
            elseif_body = [self.visit(child) for child in condition.children[4:]]

            prev.orelse = ModelIf(elseif_expr, elseif_body, None)
            prev = prev.orelse

    if else_index != -1:
        else_body = [
            self.visit(child) for child in node.children[else_index].children[1:]
        ]
        if prev:
            prev.orelse = else_body
        else:
            orelse = else_body

    if isinstance(orelse, ModelIf):
        orelse = orelse.orelse

    return ModelIf(
        expr=self.visit(node.children[1]),
        body=[self.visit(child) for child in node.children[3:body_stop_index]],
        orelse=orelse,
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_internal_procedures"><code class="name flex">
<span>def <span class="ident">visit_internal_procedures</span></span>(<span>self, node:tree_sitter.Node) >List[<a title="skema.program_analysis.CAST2FN.model.cast.function_def.FunctionDef" href="../../CAST2FN/model/cast/function_def.html#skema.program_analysis.CAST2FN.model.cast.function_def.FunctionDef">FunctionDef</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for internal procedures. Returns list of FunctionDef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_internal_procedures(self, node: Node) -&gt; List[FunctionDef]:
    &#34;&#34;&#34;Visitor for internal procedures. Returns list of FunctionDef&#34;&#34;&#34;
    print(&#39;visit_internal_procedures&#39;)
    internal_procedures = get_children_by_types(node, [&#34;function&#34;, &#34;subroutine&#34;])
    return [self.visit(procedure) for procedure in internal_procedures]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_keyword_statement"><code class="name flex">
<span>def <span class="ident">visit_keyword_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_keyword_statement(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_keyword_statement&#39;)
    # Currently, the only keyword_identifier produced by tree-sitter is Return
    # However, there may be other instances

    # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
    # We keep track of values that need to be returned in the variable context
    return_values = self.variable_context.context_return_values[
        -1
    ]  # TODO: Make function for this

    if len(return_values) == 1:
        # TODO: Fix this case
        value = self.variable_context.get_node(list(return_values)[0])
    elif len(return_values) &gt; 1:
        value = LiteralValue(
            value_type=&#34;Tuple&#34;,
            value=[
                Var(
                    val=self.variable_context.get_node(ret),
                    type=self.variable_context.get_type(ret),
                    default_value=None,
                    source_refs=None,
                )
                for ret in return_values
            ],
            source_code_data_type=None,  # TODO: REFACTOR
            source_refs=None,
        )
    else:
        value = LiteralValue(val=None, type=None, source_refs=None)

    return ModelReturn(
        value=value, source_refs=[self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_literal"><code class="name flex">
<span>def <span class="ident">visit_literal</span></span>(<span>self, node) ><a title="skema.program_analysis.CAST2FN.model.cast.literal_value.LiteralValue" href="../../CAST2FN/model/cast/literal_value.html#skema.program_analysis.CAST2FN.model.cast.literal_value.LiteralValue">LiteralValue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for literals. Returns a LiteralValue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_literal(self, node) -&gt; LiteralValue:
    &#34;&#34;&#34;Visitor for literals. Returns a LiteralValue&#34;&#34;&#34;
    print(&#39;visit_literal&#39;)
    literal_type = node.type
    literal_value = self.node_helper.get_identifier(node)
    literal_source_ref = self.node_helper.get_source_ref(node)

    if literal_type == &#34;number&#34;:
        # Check if this is a real value, or an Integer
        if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
            return LiteralValue(
                value_type=&#34;AbstractFloat&#34;,  # TODO verify this value
                value=literal_value,
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;real&#34;],
                source_refs=[literal_source_ref],
            )
        else:
            return LiteralValue(
                value_type=&#34;Integer&#34;,
                value=literal_value,
                source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;integer&#34;],
                source_refs=[literal_source_ref],
            )

    elif literal_type == &#34;string&#34;:
        return LiteralValue(
            value_type=&#34;Character&#34;,
            value=literal_value,
            source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;character&#34;],
            source_refs=[literal_source_ref],
        )

    elif literal_type == &#34;boolean&#34;:
        return LiteralValue(
            value_type=&#34;Boolean&#34;,
            value=literal_value,
            source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;logical&#34;],
            source_refs=[literal_source_ref],
        )

    elif literal_type == &#34;array_literal&#34;:
        # There are a multiple ways to create an array literal. This visitor is for the traditional explicit creation (/ 1,2,3 /)
        # For the do loop based version, we pass it off to another visitor
        implied_do_loop_expression_node = get_first_child_by_type(
            node, &#34;implied_do_loop_expression&#34;
        )
        if implied_do_loop_expression_node:
            return self._visit_implied_do_loop(implied_do_loop_expression_node)

        return LiteralValue(
            value_type=&#34;List&#34;,
            value=[
                self.visit(element) for element in get_non_control_children(node)
            ],
            source_code_data_type=[&#34;matlab&#34;, MATLAB_VERSION, &#34;dimension&#34;],
            source_refs=[literal_source_ref],
        )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_math_expression"><code class="name flex">
<span>def <span class="ident">visit_math_expression</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_math_expression(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_math_expression&#39;)
    op = self.node_helper.get_identifier(
        get_control_children(node)[0]
    )  # The operator will be the first control character

    operands = []
    for operand in get_non_control_children(node):
        operands.append(self.visit(operand))

    return Operator(
        source_language=&#34;matlab&#34;,
        interpreter=None,
        version=None,
        op=op,
        operands=operands,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_module"><code class="name flex">
<span>def <span class="ident">visit_module</span></span>(<span>self, node:tree_sitter.Node) ><a title="skema.program_analysis.CAST2FN.model.cast.module.Module" href="../../CAST2FN/model/cast/module.html#skema.program_analysis.CAST2FN.model.cast.module.Module">Module</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for program and module statement. Returns a Module object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_module(self, node: Node) -&gt; Module:
    &#34;&#34;&#34;Visitor for program and module statement. Returns a Module object&#34;&#34;&#34;
    print(&#39;visit_module&#39;)
    self.variable_context.push_context()
    
    program_body = []
    for child in node.children: 
        child_cast = self.visit(child)
        if isinstance(child_cast, List):
            program_body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            program_body.append(child_cast)

    self.variable_context.pop_context()
    
    return Module(
        name=None, #TODO: Fill out name field
        body=program_body,
        source_refs = [self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_name"><code class="name flex">
<span>def <span class="ident">visit_name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_name(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_name&#39;)
    # Node structure
    # (name)

    # First, we will check if this name is already defined, and if it is return the name node generated previously
    identifier = self.node_helper.get_identifier(node)
    if self.variable_context.is_variable(identifier):
        return self.variable_context.get_node(identifier)

    return self.variable_context.add_variable(
        identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_use_statement"><code class="name flex">
<span>def <span class="ident">visit_use_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Docstring</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_use_statement(self, node):
    &#34;&#34;&#34;Docstring&#34;&#34;&#34;
    print(&#39;visit_use_statement&#39;)
    # (use)
    #   (use)
    #   (module_name)

    ## Pull relevent child nodes
    module_name_node = get_first_child_by_type(node, &#34;module_name&#34;)
    module_name = self.node_helper.get_identifier(module_name_node)
    included_items_node = get_first_child_by_type(node, &#34;included_items&#34;)

    import_all = included_items_node is None
    import_alias = None  # TODO: Look into local-name and use-name fields

    # We need to check if this import is a full import of a module, i.e. use module
    # Or a partial import i.e. use module,only: sub1, sub2
    if import_all:
        return ModelImport(
            name=module_name,
            alias=import_alias,
            all=import_all,
            symbol=None,
            source_refs=None,
        )
    else:
        imports = []
        for symbol in get_non_control_children(included_items_node):
            symbol_identifier = self.node_helper.get_identifier(symbol)
            symbol_source_refs = [self.node_helper.get_source_ref(symbol)]
            imports.append(
                ModelImport(
                    name=module_name,
                    alias=import_alias,
                    all=import_all,
                    symbol=symbol_identifier,
                    source_refs=symbol_source_refs,
                )
            )

        return imports</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_variable_declaration"><code class="name flex">
<span>def <span class="ident">visit_variable_declaration</span></span>(<span>self, node) >List[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for variable declaration. Will return a List of Var and Assignment nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_variable_declaration(self, node) -&gt; List:
    &#34;&#34;&#34;Visitor for variable declaration. Will return a List of Var and Assignment nodes.&#34;&#34;&#34;
    &#34;&#34;&#34;
    # Node structure
    (variable_declaration)
        (intrinsic_type)
        (type_qualifier)
            (qualifier)
            (value)
        (identifier) ...
        (assignment_statement) ...

    (variable_declaration)
        (derived_type)
            (type_name)
    &#34;&#34;&#34;
    print(&#39;visit_variable_declaration&#39;)
    # A variable can be declared with an intrinsic_type if its built-in, or a derived_type if it is user defined.
    intrinsic_type_node = get_first_child_by_type(node, &#34;intrinsic_type&#34;)
    derived_type_node = get_first_child_by_type(node, &#34;derived_type&#34;)

    variable_type = &#34;&#34;
    variable_intent = &#34;&#34;

    if intrinsic_type_node:
        type_map = {
            &#34;integer&#34;: &#34;Integer&#34;,
            &#34;real&#34;: &#34;AbstractFloat&#34;,
            &#34;complex&#34;: None,
            &#34;logical&#34;: &#34;Boolean&#34;,
            &#34;character&#34;: &#34;String&#34;,
        }
        variable_type = type_map[self.node_helper.get_identifier(intrinsic_type_node)]
    elif derived_type_node:
        variable_type = self.node_helper.get_identifier(
            get_first_child_by_type(derived_type_node, &#34;type_name&#34;, recurse=True),
        )

    # There are multiple type qualifiers that change the way we generate a variable
    # For example, we need to determine if we are creating an array (dimension) or a single variable
    type_qualifiers = get_children_by_types(node, [&#34;type_qualifier&#34;])
    for qualifier in type_qualifiers:
        field = self.node_helper.get_identifier(qualifier.children[0])

        if field == &#34;dimension&#34;:
            variable_type = &#34;List&#34;
        elif field == &#34;intent&#34;:
            variable_intent = self.node_helper.get_identifier(qualifier.children[1])

    # You can declare multiple variables of the same type in a single statement, so we need to create a Var or Assignment node for each instance
    definied_variables = get_children_by_types(
        node,
        [
            &#34;identifier&#34;,  # Variable declaration
            &#34;assignment_statement&#34;,  # Variable assignment
            &#34;call_expression&#34;,  # Dimension without intent
        ],
    )
    vars = []
    for variable in definied_variables:
        if variable.type == &#34;assignment_statement&#34;:
            if variable.children[0].type == &#34;call_expression&#34;:
                vars.append(
                    Assignment(
                        left=self.visit(
                            get_first_child_by_type(
                                variable.children[0], &#34;identifier&#34;
                            )
                        ),
                        right=self.visit(variable.children[2]),
                        source_refs=[
                            self.node_helper.get_source_ref(variable)
                        ],
                    )
                )
                vars[-1].left.type = &#34;dimension&#34;
                self.variable_context.update_type(
                    vars[-1].left.val.name, &#34;dimension&#34;
                )
            else:
                # If its a regular assignment, we can update the type normally
                vars.append(self.visit(variable))
                vars[-1].left.type = variable_type
                self.variable_context.update_type(
                    vars[-1].left.val.name, variable_type
                )

        elif variable.type == &#34;identifier&#34;:
            # A basic variable declaration, we visit the identifier and then update the type
            vars.append(self.visit(variable))
            vars[-1].type = variable_type
            self.variable_context.update_type(vars[-1].val.name, variable_type)
        elif variable.type == &#34;call_expression&#34;:
            # Declaring a dimension variable using the x(1:5) format. It will look like a call expression in tree-sitter.
            # We treat it like an identifier by visiting its identifier node. Then the type gets overridden by &#34;dimension&#34;
            vars.append(self.visit(get_first_child_by_type(variable, &#34;identifier&#34;)))
            vars[-1].type = &#34;dimension&#34;
            self.variable_context.update_type(vars[-1].val.name, &#34;dimension&#34;)

    # By default, all variables are added to a function&#39;s list of return values
    # If the intent is actually in, then we need to remove them from the list
    if variable_intent == &#34;in&#34;:
        for var in vars:
            self.variable_context.remove_return_value(var.val.name)

    return vars</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis.CAST.matlab" href="index.html">skema.program_analysis.CAST.matlab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast">MatlabToCast</a></code></h4>
<ul class="">
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.generate_cast" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.generate_cast">generate_cast</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.get_gromet_function_node" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.get_gromet_function_node">get_gromet_function_node</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.run" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.run">run</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit">visit</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_assignment_statement" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_assignment_statement">visit_assignment_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_derived_type" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_derived_type">visit_derived_type</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_derived_type_member_expression" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_derived_type_member_expression">visit_derived_type_member_expression</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_do_loop_statement" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_do_loop_statement">visit_do_loop_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_extent_specifier" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_extent_specifier">visit_extent_specifier</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_function_call" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_function_call">visit_function_call</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_function_def" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_function_def">visit_function_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_identifier" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_identifier">visit_identifier</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_if_statement" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_if_statement">visit_if_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_internal_procedures" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_internal_procedures">visit_internal_procedures</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_keyword_statement" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_keyword_statement">visit_keyword_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_literal" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_literal">visit_literal</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_math_expression" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_math_expression">visit_math_expression</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_module" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_module">visit_module</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_name" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_name">visit_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_use_statement" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_use_statement">visit_use_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_variable_declaration" href="#skema.program_analysis.CAST.matlab.matlab_to_cast.MatlabToCast.visit_variable_declaration">visit_variable_declaration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>