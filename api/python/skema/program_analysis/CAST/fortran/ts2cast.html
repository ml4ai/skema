<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.CAST.fortran.ts2cast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.CAST.fortran.ts2cast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os.path
import time
from pathlib import Path
from typing import Any, Dict, List, Union

from tree_sitter import Language, Parser, Node

from skema.program_analysis.CAST2FN.cast import CAST
from skema.program_analysis.CAST2FN.model.cast import (
    Module,
    SourceRef,
    ModelBreak,
    Assignment,
    LiteralValue,
    Var,
    VarType,
    Name,
    Operator,
    AstNode,
    SourceCodeDataType,
    ModelImport,
    FunctionDef,
    Loop,
    Call,
    ModelReturn,
    ModelIf,
    RecordDef,
    Attribute,
)

from skema.program_analysis.CAST.fortran.variable_context import VariableContext
from skema.program_analysis.CAST.fortran.node_helper import (
    NodeHelper,
    remove_comments,
    get_children_by_types,
    get_children_except_types,
    get_first_child_by_type,
    get_control_children,
    get_non_control_children,
    get_first_child_index,
    get_last_child_index,
)
from skema.program_analysis.CAST.fortran.util import generate_dummy_source_refs

from skema.program_analysis.CAST.fortran.preprocessor.preprocess import preprocess
from skema.program_analysis.tree_sitter_parsers.build_parsers import (
    INSTALLED_LANGUAGES_FILEPATH,
)

builtin_statements = set(
    [
        &#34;read_statement&#34;,
        &#34;write_statement&#34;,
        &#34;rewind_statement&#34;,
        &#34;open_statement&#34;,
        &#34;print_statement&#34;,
    ]
)


class TS2CAST(object):
    def __init__(self, source_file_path: str):
        # Prepare source with preprocessor
        self.path = Path(source_file_path)
        self.source_file_name = self.path.name
        self.source = preprocess(self.path)

        # Run tree-sitter on preprocessor output to generate parse tree
        parser = Parser()
        parser.set_language(Language(INSTALLED_LANGUAGES_FILEPATH, &#34;fortran&#34;))
        self.tree = parser.parse(bytes(self.source, &#34;utf8&#34;))
        self.root_node = remove_comments(self.tree.root_node)

        # Walking data
        self.variable_context = VariableContext()
        self.node_helper = NodeHelper(self.source, self.source_file_name)

        # Start visiting
        self.out_cast = self.generate_cast()
        # print(self.out_cast[0].to_json_str())

    def generate_cast(self) -&gt; List[CAST]:
        &#34;&#34;&#34;Interface for generating CAST.&#34;&#34;&#34;
        modules = self.run(self.root_node)
        return [
            CAST([generate_dummy_source_refs(module)], &#34;Fortran&#34;) for module in modules
        ]

    def run(self, root) -&gt; List[Module]:
        &#34;&#34;&#34;Top level visitor function. Will return between 1-3 Module objects.&#34;&#34;&#34;
        # A program can have between 1-3 modules
        # 1. A module body
        # 2. A program body
        # 3. Everything else (defined functions)
        modules = []
        contexts = get_children_by_types(root, [&#34;module&#34;, &#34;program&#34;])
        for context in contexts:
            modules.append(self.visit(context))

        # Currently, we are supporting functions and subroutines defined outside of programs and modules
        # Other than comments, it is unclear if anything else is allowed.
        # TODO: Research the above
        outer_body_nodes = get_children_by_types(root, [&#34;function&#34;, &#34;subroutine&#34;])
        if len(outer_body_nodes) &gt; 0:
            body = []
            for body_node in outer_body_nodes:
                child_cast = self.visit(body_node)
                if isinstance(child_cast, List):
                    body.extend(child_cast)
                elif isinstance(child_cast, AstNode):
                    body.append(child_cast)
            modules.append(
                Module(
                    name=None,
                    body=body,
                    source_refs=[self.node_helper.get_source_ref(root)],
                )
            )

        return modules

    def visit(self, node: Node):
        if node.type in [&#34;program&#34;, &#34;module&#34;]:
            return self.visit_module(node)
        elif node.type == &#34;internal_procedures&#34;:
            return self.visit_internal_procedures(node)
        elif node.type in [&#34;subroutine&#34;, &#34;function&#34;]:
            return self.visit_function_def(node)
        elif node.type in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
            return self.visit_function_call(node)
        elif node.type == &#34;use_statement&#34;:
            return self.visit_use_statement(node)
        elif node.type == &#34;variable_declaration&#34;:
            return self.visit_variable_declaration(node)
        elif node.type == &#34;assignment_statement&#34;:
            return self.visit_assignment_statement(node)
        elif node.type == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node.type == &#34;name&#34;:
            return self.visit_name(node)
        elif node.type in [
            &#34;unary_expression&#34;,
            &#34;math_expression&#34;,
            &#34;relational_expression&#34;,
        ]:
            return self.visit_math_expression(node)
        elif node.type in [
            &#34;number_literal&#34;,
            &#34;array_literal&#34;,
            &#34;string_literal&#34;,
            &#34;boolean_literal&#34;,
        ]:
            return self.visit_literal(node)
        elif node.type == &#34;keyword_statement&#34;:
            return self.visit_keyword_statement(node)
        elif node.type in builtin_statements:
            return self.visit_fortran_builtin_statement(node)
        elif node.type == &#34;extent_specifier&#34;:
            return self.visit_extent_specifier(node)
        elif node.type in [&#34;do_loop_statement&#34;]:
            return self.visit_do_loop_statement(node)
        elif node.type in [&#34;if_statement&#34;, &#34;else_if_clause&#34;, &#34;else_clause&#34;]:
            return self.visit_if_statement(node)
        elif node.type == &#34;logical_expression&#34;:
            return self.visit_logical_expression(node)
        elif node.type == &#34;derived_type_definition&#34;:
            return self.visit_derived_type(node)
        elif node.type == &#34;derived_type_member_expression&#34;:
            return self.visit_derived_type_member_expression(node)
        else:
            return self._visit_passthrough(node)

    def visit_module(self, node: Node) -&gt; Module:
        &#34;&#34;&#34;Visitor for program and module statement. Returns a Module object&#34;&#34;&#34;
        self.variable_context.push_context()

        program_body = []
        for child in node.children[1:-1]:  # Ignore the start and end program statement
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                program_body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                program_body.append(child_cast)

        self.variable_context.pop_context()

        return Module(
            name=None,  # TODO: Fill out name field
            body=program_body,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_internal_procedures(self, node: Node) -&gt; List[FunctionDef]:
        &#34;&#34;&#34;Visitor for internal procedures. Returns list of FunctionDef&#34;&#34;&#34;
        internal_procedures = get_children_by_types(node, [&#34;function&#34;, &#34;subroutine&#34;])
        return [self.visit(procedure) for procedure in internal_procedures]

    def visit_name(self, node):
        # Node structure
        # (name)

        # First, we will check if this name is already defined, and if it is return the name node generated previously
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            return self.variable_context.get_node(identifier)

        return self.variable_context.add_variable(
            identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
        )

    def visit_function_def(self, node):
        # TODO: Refactor function def code to use new helper functions
        # Node structure
        # (subroutine)
        #   (subroutine_statement)
        #     (subroutine)
        #     (name)
        #     (parameters) - Optional
        #   (body_node) ...
        # (function)
        #   (function_statement)
        #     (function)
        #     (intrinsic_type) - Optional
        #     (name)
        #     (parameters) - Optional
        #     (function_result) - Optional
        #       (identifier)
        #  (body_node) ...

        # Create a new variable context
        self.variable_context.push_context()

        # Top level statement node

        statement_node = get_children_by_types(
            node, [&#34;subroutine_statement&#34;, &#34;function_statement&#34;]
        )[0]

        name_node = get_first_child_by_type(statement_node, &#34;name&#34;)
        name = self.visit(
            name_node
        )  # Visit the name node to add it to the variable context

        # If this is a function, check for return type and return value
        if node.type == &#34;function&#34;:
            intrinsic_type = None
            return_value = None
            signature_qualifiers = get_children_by_types(
                statement_node, [&#34;intrinsic_type&#34;, &#34;function_result&#34;]
            )
            for qualifier in signature_qualifiers:
                if qualifier.type == &#34;intrinsic_type&#34;:
                    intrinsic_type = self.node_helper.get_identifier(qualifier)
                    self.variable_context.add_variable(
                        self.node_helper.get_identifier(name_node), intrinsic_type, None
                    )
                elif qualifier.type == &#34;function_result&#34;:
                    return_value = self.visit(
                        get_first_child_by_type(qualifier, &#34;identifier&#34;)
                    ).val
                    self.variable_context.add_return_value(return_value.name)

            # NOTE: In the case of a function specifically, if there is no explicit return value, the return value will be the name of the function
            # TODO: Should this be a node instead
            if not return_value:
                self.variable_context.add_return_value(
                    self.node_helper.get_identifier(name_node)
                )
                return_value = self.visit(name_node)

            # If funciton has both an explicit intrinsic type, then we also need to update the type of the return value in the variable context
            if intrinsic_type:
                self.variable_context.update_type(return_value.name, intrinsic_type)

        # Generating the function arguments by walking the parameters node
        func_args = []
        if parameters_node := get_first_child_by_type(statement_node, &#34;parameters&#34;):
            for parameter in get_non_control_children(parameters_node):
                # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
                # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
                self.variable_context.add_return_value(
                    self.node_helper.get_identifier(parameter)
                )
                func_args.append(self.visit(parameter))

        # The first child of function will be the function statement, the rest will be body nodes
        body = []
        for body_node in node.children[1:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # After creating the body, we can go back and update the var nodes we created for the arguments
        # We do this by looking for intent,in nodes
        for i, arg in enumerate(func_args):
            func_args[i].type = self.variable_context.get_type(arg.val.name)

        # TODO:
        # This logic can be made cleaner
        # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
        # If there is not, then we will create a dummy one
        return_found = False
        for child in body:
            if isinstance(child, ModelReturn):
                return_found = True
        if not return_found:
            body.append(self.visit_keyword_statement(node))

        # Pop variable context off of stack before leaving this scope
        self.variable_context.pop_context()

        return FunctionDef(
            name=name,
            func_args=func_args,
            body=body,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_function_call(self, node):
        # Pull relevent nodes
        # A subroutine and function won&#39;t neccessarily have an arguments node.
        # So we should be careful about trying to access it.

        function_node = get_children_by_types(
            node,
            [
                &#34;unary_expression&#34;,
                &#34;subroutine&#34;,
                &#34;identifier&#34;,
                &#34;derived_type_member_expression&#34;,
            ],
        )[0]
        if function_node.type == &#34;derived_type_member_expression&#34;:
            return self.visit_derived_type_member_expression(function_node)

        arguments_node = get_first_child_by_type(node, &#34;argument_list&#34;)

        # If this is a unary expression (+foo()) the identifier will be nested.
        # TODO: If this is a non &#39;+&#39; unary expression, how do we add it to the CAST?
        if function_node.type == &#34;unary_expression&#34;:
            function_node = get_first_child_by_type(node, &#34;identifier&#34;, recurse=True)

        function_identifier = self.node_helper.get_identifier(function_node)

        # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
        # We will need to check if this is truly a function call or a subscript
        if self.variable_context.is_variable(function_identifier):
            if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
                return self._visit_get(
                    node
                )  # This overrides the visitor and forces us to visit another

        # TODO: What should get a name node? Instrincit functions? Imported functions?
        # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
        if self.variable_context.is_variable(function_identifier):
            func = self.variable_context.get_node(function_identifier)
        else:
            func = Name(function_identifier, -1)  # TODO: REFACTOR

        # Add arguments to arguments list
        arguments = []
        if arguments_node:
            for argument in arguments_node.children:
                child_cast = self.visit(argument)
                if child_cast:
                    arguments.append(child_cast)

        return Call(
            func=func,
            source_language=&#34;Fortran&#34;,
            source_language_version=&#34;2008&#34;,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_keyword_statement(self, node):
        # NOTE: RETURN is not the only Fortran keyword. GO TO and CONTINUE are also considered keywords.
        # TODO: Handle GO TO and CONTINUE
        identifier = self.node_helper.get_identifier(node).lower()
        if node.type == &#34;keyword_statement&#34;:
            if &#34;continue&#34; in identifier or &#34;go to&#34; in identifier:
                return self._visit_no_op(node)
            if &#34;exit&#34; in identifier:
                return ModelBreak(source_refs=[self.node_helper.get_source_ref(node)])

        # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
        # We keep track of values that need to be returned in the variable context
        return_values = self.variable_context.context_return_values[
            -1
        ]  # TODO: Make function for this

        if len(return_values) == 1:
            value = self.variable_context.get_node(list(return_values)[0])
        elif len(return_values) &gt; 1:
            value = LiteralValue(
                value_type=&#34;Tuple&#34;,
                value=[self.variable_context.get_node(ret) for ret in return_values],
                source_code_data_type=None,
                source_refs=None,
            )
        else:
            value = LiteralValue(value=None, value_type=None, source_refs=None)

        return ModelReturn(
            value=value, source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_fortran_builtin_statement(self, node):
        &#34;&#34;&#34;Visitor for Fortran keywords that are not classified as keyword_statement by tree-sitter&#34;&#34;&#34;
        # All of the node types that fall into this category end with _statment.
        # So the function name will be the node type with _statement removed (write, read, open, ...)
        func = self.get_gromet_function_node(node.type.replace(&#34;_statement&#34;, &#34;&#34;))

        arguments = []

        return Call(
            func=func,
            arguments=arguments,
            source_language=&#34;Fortran&#34;,
            source_language_version=None,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_print_statement(self, node):
        func = self.get_gromet_function_node(&#34;print&#34;)

        arguments = []

        return Call(
            func=func,
            arguments=arguments,
            source_language=None,
            source_language_version=None,
        )

    def visit_use_statement(self, node):
        # (use)
        #   (use)
        #   (module_name)

        ## Pull relevent child nodes
        module_name_node = get_first_child_by_type(node, &#34;module_name&#34;)
        module_name = self.node_helper.get_identifier(module_name_node)
        included_items_node = get_first_child_by_type(node, &#34;included_items&#34;)

        import_all = included_items_node is None
        import_alias = None  # TODO: Look into local-name and use-name fields

        # We need to check if this import is a full import of a module, i.e. use module
        # Or a partial import i.e. use module,only: sub1, sub2
        if import_all:
            return ModelImport(
                name=module_name,
                alias=import_alias,
                all=import_all,
                symbol=None,
                source_refs=[self.node_helper.get_source_ref(node)],
            )
        else:
            imports = []
            for symbol in get_non_control_children(included_items_node):
                symbol_identifier = self.node_helper.get_identifier(symbol)
                symbol_source_refs = [self.node_helper.get_source_ref(symbol)]
                imports.append(
                    ModelImport(
                        name=module_name,
                        alias=import_alias,
                        all=import_all,
                        symbol=symbol_identifier,
                        source_refs=symbol_source_refs,
                    )
                )
            return imports

    def visit_do_loop_statement(self, node) -&gt; Loop:
        &#34;&#34;&#34;Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
        The do while loop will be passed off to a seperate visitor. Returns a Loop object.
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do loop
        (do_loop_statement)
            (loop_control_expression)
                (...) ...
            (body) ...
        
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;

        loop_control_node = get_first_child_by_type(node, &#34;loop_contrel_expression&#34;)
        if not loop_control_node:
            return self._visit_while(node)

        # If there is a loop control expression, the first body node will be the node after the loop_control_expression
        # It is valid Fortran to have a single itteration do loop as well.
        # NOTE: This code is for the creation of the main body. The do loop will still add some additional nodes at the end of this body.
        body_start_index = 1 + get_first_child_index(node, &#34;loop_control_expression&#34;)
        body = self.generate_cast_body(node.children[body_start_index:])

        # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop
        # PRE:
        # _next(_iter(range(start, stop, step)))
        loop_control_node = get_first_child_by_type(node, &#34;loop_control_expression&#34;)
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            itterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            itterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            itterator = None
            start = None
            stop = None
            step = None

        range_name_node = self.get_gromet_function_node(&#34;range&#34;)
        iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
        next_name_node = self.get_gromet_function_node(&#34;next&#34;)
        generated_iter_name_node = self.variable_context.generate_iterator()
        stop_condition_name_node = self.variable_context.generate_stop_condition()

        # generated_iter_0 = iter(range(start, stop, step))
        pre = []
        pre.append(
            Assignment(
                left=Var(generated_iter_name_node, &#34;Iterator&#34;),
                right=Call(
                    iter_name_node,
                    arguments=[Call(range_name_node, arguments=[start, stop, step])],
                ),
            )
        )

        # (i, generated_iter_0, sc_0) = next(generated_iter_0)
        pre.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # EXPR
        expr = []
        expr = Operator(
            op=&#34;!=&#34;,  # TODO: Should this be == or !=
            operands=[
                Var(stop_condition_name_node, &#34;Boolean&#34;),
                LiteralValue(&#34;Boolean&#34;, True),
            ],
        )

        # BODY
        # At this point, the body nodes have already been visited
        # We just need to append the iterator next call
        body.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # POST
        post = []
        post.append(
            Assignment(
                left=itterator,
                right=Operator(op=&#34;+&#34;, operands=[itterator, step]),
            )
        )

        return Loop(
            pre=pre,
            expr=expr,
            body=body,
            post=post,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_if_statement(self, node):
        # (if_statement)
        #  (if)
        #  (parenthesised_expression)
        #  (then)
        #  (body_nodes) ...
        #  (elseif_clauses) ..
        #  (else_clause)
        #  (end_if_statement)

        # TODO: Can you have a parenthesized expression as a body node
        body_nodes = get_children_except_types(
            node,
            [
                &#34;if&#34;,
                &#34;elseif&#34;,
                &#34;else&#34;,
                &#34;then&#34;,
                &#34;parenthesized_expression&#34;,
                &#34;elseif_clause&#34;,
                &#34;else_clause&#34;,
                &#34;end_if_statement&#34;,
            ],
        )
        body = self.generate_cast_body(body_nodes)

        expr_node = get_first_child_by_type(node, &#34;parenthesized_expression&#34;)
        expr = None
        if expr_node:
            expr = self.visit(expr_node)

        elseif_nodes = get_children_by_types(node, [&#34;elseif_clause&#34;])
        elseif_cast = [self.visit(elseif_clause) for elseif_clause in elseif_nodes]
        for i in range(len(elseif_cast) - 1):
            elseif_cast[i].orelse = [elseif_cast[i + 1]]

        else_node = get_first_child_by_type(node, &#34;else_clause&#34;)
        else_cast = None
        if else_node:
            else_cast = self.visit(else_node)

        orelse = []
        if len(elseif_cast) &gt; 0:
            orelse = [elseif_cast[0]]
        elif else_cast:
            orelse = else_cast.body

        return ModelIf(expr=expr, body=body, orelse=orelse)

    def visit_logical_expression(self, node):
        &#34;&#34;&#34;Visitior for logical expression (i.e. true and false) which is used in compound conditional&#34;&#34;&#34;
        # If this is a .not. operator, we need to pass it on to the math_expression visitor
        if len(node.children) &lt; 3:
            return self.visit_math_expression(node)

        literal_value_false = LiteralValue(&#34;Boolean&#34;, False)
        literal_value_true = LiteralValue(&#34;Boolean&#34;, True)

        # AND: Right side goes in body if, left side in condition
        # OR: Right side goes in body else, left side in condition
        left, operator, right = node.children

        # First we need to check if this is logical and or a logical or
        # The tehcnical types for these are \.or\. and \.and\. so to simplify things we can use the in keyword
        is_or = &#34;or&#34; in operator.type

        top_if = ModelIf()
        top_if_expr = self.visit(left)
        top_if.expr = top_if_expr

        bottom_if_expr = self.visit(right)
        if is_or:
            top_if.orelse = [bottom_if_expr]
            top_if.body = [literal_value_true]
        else:
            top_if.orelse = [literal_value_false]
            top_if.body = [bottom_if_expr]

        return top_if

    def visit_assignment_statement(self, node):
        left, _, right = node.children

        # We need to check if the left side is a multidimensional array,
        # Since tree-sitter incorrectly shows this assignment as a call_expression
        if left.type == &#34;call_expression&#34;:
            return self._visit_set(node)

        return Assignment(
            left=self.visit(left),
            right=self.visit(right),
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_literal(self, node) -&gt; LiteralValue:
        &#34;&#34;&#34;Visitor for literals. Returns a LiteralValue&#34;&#34;&#34;
        literal_type = node.type
        literal_value = self.node_helper.get_identifier(node)
        literal_source_ref = self.node_helper.get_source_ref(node)

        if literal_type == &#34;number_literal&#34;:
            # Check if this is a real value, or an Integer
            if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
                return LiteralValue(
                    value_type=&#34;AbstractFloat&#34;,
                    value=literal_value,
                    source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;real&#34;],
                    source_refs=[literal_source_ref],
                )
            else:
                return LiteralValue(
                    value_type=&#34;Integer&#34;,
                    value=literal_value,
                    source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;integer&#34;],
                    source_refs=[literal_source_ref],
                )

        elif literal_type == &#34;string_literal&#34;:
            return LiteralValue(
                value_type=&#34;Character&#34;,
                value=literal_value,
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;character&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;boolean_literal&#34;:
            return LiteralValue(
                value_type=&#34;Boolean&#34;,
                value=literal_value,
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;logical&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;array_literal&#34;:
            # There are a multiple ways to create an array literal. This visitor is for the traditional explicit creation (/ 1,2,3 /)
            # For the do loop based version, we pass it off to another visitor
            implied_do_loop_expression_node = get_first_child_by_type(
                node, &#34;implied_do_loop_expression&#34;
            )
            if implied_do_loop_expression_node:
                return self._visit_implied_do_loop(implied_do_loop_expression_node)

            return LiteralValue(
                value_type=&#34;List&#34;,
                value=[
                    self.visit(element) for element in get_non_control_children(node)
                ],
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;dimension&#34;],
                source_refs=[literal_source_ref],
            )

    def visit_identifier(self, node):
        # By default, this is unknown, but can be updated by other visitors
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            var_type = self.variable_context.get_type(identifier)
        else:
            var_type = &#34;Unknown&#34;

        # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
        # Fortran does have optional arguments introduced in F90, but these do not specify a default
        default_value = None

        # This is another case where we need to override the visitor to explicitly visit another node
        value = self.visit_name(node)

        return Var(
            val=value,
            type=var_type,
            default_value=default_value,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_math_expression(self, node):
        op = self.node_helper.get_identifier(
            get_control_children(node)[0]
        )  # The operator will be the first control character
        operands = []
        for operand in get_non_control_children(node):
            operands.append(self.visit(operand))

            # For operators, we will only need the name node since we are not allocating space
            if operand.type == &#34;identifier&#34;:
                operands[-1] = operands[-1].val

        return Operator(
            source_language=&#34;Fortran&#34;,
            interpreter=None,
            version=None,
            op=op,
            operands=operands,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_variable_declaration(self, node) -&gt; List:
        &#34;&#34;&#34;Visitor for variable declaration. Will return a List of Var and Assignment nodes.&#34;&#34;&#34;
        &#34;&#34;&#34;
        # Node structure
        (variable_declaration)
            (intrinsic_type)
            (type_qualifier)
                (qualifier)
                (value)
            (identifier) ...
            (assignment_statement) ...

        (variable_declaration)
            (derived_type)
                (type_name)
        &#34;&#34;&#34;
        # A variable can be declared with an intrinsic_type if its built-in, or a derived_type if it is user defined.
        intrinsic_type_node = get_first_child_by_type(node, &#34;intrinsic_type&#34;)
        derived_type_node = get_first_child_by_type(node, &#34;derived_type&#34;)

        variable_type = &#34;&#34;
        variable_intent = &#34;&#34;

        if intrinsic_type_node:
            type_map = {
                &#34;integer&#34;: &#34;Integer&#34;,
                &#34;real&#34;: &#34;AbstractFloat&#34;,
                &#34;double precision&#34;: &#34;AbstractFloat&#34;,
                &#34;complex&#34;: &#34;Tuple&#34;,  # Complex is a Tuple (rational,irrational),
                &#34;logical&#34;: &#34;Boolean&#34;,
                &#34;character&#34;: &#34;String&#34;,
            }
            # NOTE: Identifiers are case sensitive, so we always need to make sure we are comparing to the lower() version
            variable_type = type_map[
                self.node_helper.get_identifier(intrinsic_type_node).lower()
            ]
        elif derived_type_node:
            variable_type = self.node_helper.get_identifier(
                get_first_child_by_type(derived_type_node, &#34;type_name&#34;, recurse=True),
            )

        # There are multiple type qualifiers that change the way we generate a variable
        # For example, we need to determine if we are creating an array (dimension) or a single variable
        type_qualifiers = get_children_by_types(node, [&#34;type_qualifier&#34;])
        for qualifier in type_qualifiers:
            field = self.node_helper.get_identifier(qualifier.children[0])

            if field == &#34;dimension&#34;:
                variable_type = &#34;List&#34;
            elif field == &#34;intent&#34;:
                variable_intent = self.node_helper.get_identifier(qualifier.children[1])

        # You can declare multiple variables of the same type in a single statement, so we need to create a Var or Assignment node for each instance
        definied_variables = get_children_by_types(
            node,
            [
                &#34;identifier&#34;,  # Variable declaration
                &#34;assignment_statement&#34;,  # Variable assignment
                &#34;call_expression&#34;,  # Dimension without intent
            ],
        )
        vars = []
        for variable in definied_variables:
            if variable.type == &#34;assignment_statement&#34;:
                if variable.children[0].type == &#34;call_expression&#34;:
                    vars.append(
                        Assignment(
                            left=self.visit(
                                get_first_child_by_type(
                                    variable.children[0], &#34;identifier&#34;
                                )
                            ),
                            right=self.visit(variable.children[2]),
                            source_refs=[self.node_helper.get_source_ref(variable)],
                        )
                    )
                    vars[-1].left.type = &#34;List&#34;
                    self.variable_context.update_type(vars[-1].left.val.name, &#34;List&#34;)
                else:
                    # If its a regular assignment, we can update the type normally
                    vars.append(self.visit(variable))
                    vars[-1].left.type = variable_type
                    self.variable_context.update_type(
                        vars[-1].left.val.name, variable_type
                    )

            elif variable.type == &#34;identifier&#34;:
                # A basic variable declaration, we visit the identifier and then update the type
                vars.append(self.visit(variable))
                vars[-1].type = variable_type
                self.variable_context.update_type(vars[-1].val.name, variable_type)
            elif variable.type == &#34;call_expression&#34;:
                # Declaring a dimension variable using the x(1:5) format. It will look like a call expression in tree-sitter.
                # We treat it like an identifier by visiting its identifier node. Then the type gets overridden by &#34;dimension&#34;
                vars.append(self.visit(get_first_child_by_type(variable, &#34;identifier&#34;)))
                vars[-1].type = &#34;List&#34;
                self.variable_context.update_type(vars[-1].val.name, &#34;List&#34;)

        # By default, all variables are added to a function&#39;s list of return values
        # If the intent is actually in, then we need to remove them from the list
        if variable_intent == &#34;in&#34;:
            for var in vars:
                self.variable_context.remove_return_value(var.val.name)

        return vars

    def visit_extent_specifier(self, node):
        # Node structure
        # (extent_specifier)
        #   (identifier)
        #   (identifier)

        # The extent specifier is the same as a slice, it can have a start, stop, and step
        # We can determine these by looking at the number of control characters in this node.
        # Fortran uses the character &#39;:&#39; to differentiate these values
        argument_pointer = 0
        arguments = [
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
        ]
        for child in node.children:
            if child.type == &#34;:&#34;:
                argument_pointer += 1
            else:
                arguments[argument_pointer] = self.visit(child)

        return Call(
            func=self.get_gromet_function_node(&#34;slice&#34;),
            source_language=&#34;Fortran&#34;,
            source_language_version=&#34;Fortran95&#34;,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type(self, node: Node) -&gt; RecordDef:
        &#34;&#34;&#34;Visitor function for derived type definition. Will return a RecordDef&#34;&#34;&#34;
        &#34;&#34;&#34;Node Structure:
        (derived_type_definition)
            (derived_type_statement)
                (base)
                    (base_type_specifier)
                        (identifier)
                (type_name)
            (BODY_NODES)
            ...
        &#34;&#34;&#34;

        record_name = self.node_helper.get_identifier(
            get_first_child_by_type(node, &#34;type_name&#34;, recurse=True)
        )

        # There is no multiple inheritance in Fortran, so a type may only extend 1 other type
        bases = []
        derived_type_statement_node = get_first_child_by_type(
            node, &#34;derived_type_statement&#34;
        )
        base_node = get_first_child_by_type(
            derived_type_statement_node, &#34;identifier&#34;, recurse=True
        )
        if base_node:
            bases.append([self.node_helper.get_identifier(base_node)])

        # A derived type can contain symbols with the same name as those already in the main program body.
        # If we tell the variable context we are in a record definition, it will append the type name as a prefix to all defined variables.
        self.variable_context.enter_record_definition(record_name)

        # Note:
        funcs = []
        derived_type_procedures_node = get_first_child_by_type(
            node, &#34;derived_type_procedures&#34;
        )
        if derived_type_procedures_node:
            for procedure_node in get_children_by_types(
                derived_type_procedures_node, [&#34;procedure_statement&#34;]
            ):
                funcs.append(
                    self.visit_name(
                        get_first_child_by_type(procedure_node, &#34;method_name&#34;)
                    )
                )

        # A derived type can only have variable declarations in its body.
        fields = []
        variable_declarations = [
            self.visit(variable_declaration)
            for variable_declaration in get_children_by_types(
                node, [&#34;variable_declaration&#34;]
            )
        ]
        for declaration in variable_declarations:
            # Variable declarations always returns a list of Var or Assignment, even when only one var is being created
            for var in declaration:
                if isinstance(var, Var):
                    fields.append(var)
                elif isinstance(var, Assignment):
                    # Since this is a record definition, an assignment is actually equivalent to setting the default value
                    var.left.default_value = var.right
                    fields.append(var.left)
                # TODO: Handle dimension type (Call type)
                elif isinstance(var, Call):
                    pass
        # Leaving the record definition sets the prefix back to an empty string
        self.variable_context.exit_record_definition()

        return RecordDef(
            name=record_name,
            bases=bases,
            funcs=funcs,
            fields=fields,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type_member_expression(self, node) -&gt; Attribute:
        &#34;&#34;&#34;Visitor function for derived type access. Returns an Attribute object&#34;&#34;&#34;
        &#34;&#34;&#34; Node Structure
        Scalar Access
        (derived_type_member_expression)
            (identifier)
            (type_member)

        Dimensional Access
        (derived_type_member_expression)
            (call_expression)
                (identifier)
                (argument_list)
            (type_member)
        &#34;&#34;&#34;

        # If we are accessing an attribute of a scalar type, we can simply pull the name node from the variable context.
        # However, if this is a dimensional type, we must convert it to a call to _get.
        call_expression_node = get_first_child_by_type(node, &#34;call_expression&#34;)
        if call_expression_node:
            value = self._visit_get(call_expression_node)
        else:
            # We shouldn&#39;t be accessing get_node directly, since it may not exist in the case of an import.
            # Instead, we should visit the identifier node which will add it to the variable context automatically if it doesn&#39;t exist.
            value = self.visit(
                get_first_child_by_type(node, &#34;identifier&#34;, recurse=True)
            )

        # NOTE: Attribue should be a Name node, NOT a string or Var node
        # attr = self.node_helper.get_identifier(
        #    get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)
        # )
        # print(self.node_helper.get_identifier(get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)))
        attr = self.visit_name(get_first_child_by_type(node, &#34;type_member&#34;))

        return Attribute(
            value=value,
            attr=attr,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    # NOTE: This function starts with _ because it will never be dispatched to directly. There is not a get node in the tree-sitter parse tree.
    # From context, we will determine when we are accessing an element of a List, and call this function,
    def _visit_get(self, node):
        # Node structure
        # (call_expression)
        #  (identifier)
        #  (argument_list)

        identifier_node = node.children[0]
        argument_nodes = get_non_control_children(node.children[1])

        # First argument to get is the List itself. We can get this by passing the identifier to the identifier visitor
        arguments = []
        arguments.append(self.visit(identifier_node))

        # If there are more than one arguments, then this is a multi dimensional array and we need to use an extended slice
        if len(argument_nodes) &gt; 1:
            dimension_list = LiteralValue()
            dimension_list.value_type = &#34;List&#34;
            dimension_list.value = []
            for argument in argument_nodes:
                dimension_list.value.append(self.visit(argument))

            extslice_call = Call()
            extslice_call.func = self.get_gromet_function_node(&#34;ext_slice&#34;)
            extslice_call.arguments = []
            extslice_call.arguments.append(dimension_list)

            arguments.append(extslice_call)
        else:
            arguments.append(self.visit(argument_nodes[0]))

        return Call(
            func=self.get_gromet_function_node(&#34;get&#34;),
            source_language=&#34;Fortran&#34;,
            source_language_version=&#34;Fortran95&#34;,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_set(self, node):
        # Node structure
        # (assignment_statement)
        #  (call_expression)
        #  (right side)

        left, _, right = node.children

        # The left side is equivilent to a call gromet &#34;get&#34;, so we will first pass the left side to the get visitor
        # Then we can easily convert this to a &#34;set&#34; call by modifying the fields and then appending the right side to the function arguments
        cast_call = self._visit_get(left)
        cast_call.func = self.get_gromet_function_node(&#34;set&#34;)
        cast_call.arguments.append(self.visit(right))

        return cast_call

    def _visit_while(self, node) -&gt; Loop:
        &#34;&#34;&#34;Custom visitor for while loop. Returns a Loop object&#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;
        while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)

        # Fortran has certain while(True) constructs that won&#39;t contain a while_statement node
        if not while_statement_node:
            body_start_index = 0
            expr = LiteralValue(
                value_type=&#34;Boolean&#34;,
                value=&#34;True&#34;,
            )
        else:
            body_start_index = 1 + get_first_child_index(node, &#34;while_statement&#34;)
            # We don&#39;t have explicit handling for parenthesized_expression, but the passthrough handler will make sure that we visit the expression correctly.
            expr = self.visit(
                get_first_child_by_type(
                    while_statement_node, &#34;parenthesized_expression&#34;
                )
            )

        # The first body node will be the node after the while_statement
        body = self.generate_cast_body(node.children[body_start_index:])

        return Loop(
            pre=[],
            expr=expr,
            body=body,
            post=[],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_implied_do_loop(self, node) -&gt; Call:
        &#34;&#34;&#34;Custom visitor for implied_do_loop array literal. This form gets converted to a call to range&#34;&#34;&#34;
        # TODO: This loop_control is the same as the do loop. Can we turn this into one visitor?
        loop_control_node = get_first_child_by_type(
            node, &#34;loop_control_expression&#34;, recurse=True
        )
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            itterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            itterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            itterator = None
            start = None
            stop = None
            step = None

        return Call(
            func=self.get_gromet_function_node(&#34;range&#34;),
            source_language=None,
            source_language_version=None,
            arguments=[start, stop, step],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_passthrough(self, node):
        if len(node.children) == 0:
            return None

        for child in node.children:
            child_cast = self.visit(child)
            if child_cast:
                return child_cast

    def _visit_no_op(self, node):
        &#34;&#34;&#34;For unsupported idioms, we can generate a no op instruction so that the body is not empty&#34;&#34;&#34;
        return Call(
            func=self.get_gromet_function_node(&#34;no_op&#34;),
            source_language=None,
            source_language_version=None,
            arguments=[],
        )

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        # Idealy, we would be able to create a dummy node and just call the name visitor.
        # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
        if self.variable_context.is_variable(func_name):
            return self.variable_context.get_node(func_name)

        return self.variable_context.add_variable(func_name, &#34;function&#34;, None)

    def generate_cast_body(self, body_nodes: List):
        body = []
        for node in body_nodes:
            cast = self.visit(node)
            if isinstance(cast, AstNode):
                body.append(cast)
            elif isinstance(cast, List):
                body.extend(cast)

        # Gromet doesn&#39;t support empty bodies, so we should create a no_op instead
        if len(body) == 0:
            body.append(self._visit_no_op(None))

        # TODO: How to add more support for source references
        return body</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST"><code class="flex name class">
<span>class <span class="ident">TS2CAST</span></span>
<span>(</span><span>source_file_path: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TS2CAST(object):
    def __init__(self, source_file_path: str):
        # Prepare source with preprocessor
        self.path = Path(source_file_path)
        self.source_file_name = self.path.name
        self.source = preprocess(self.path)

        # Run tree-sitter on preprocessor output to generate parse tree
        parser = Parser()
        parser.set_language(Language(INSTALLED_LANGUAGES_FILEPATH, &#34;fortran&#34;))
        self.tree = parser.parse(bytes(self.source, &#34;utf8&#34;))
        self.root_node = remove_comments(self.tree.root_node)

        # Walking data
        self.variable_context = VariableContext()
        self.node_helper = NodeHelper(self.source, self.source_file_name)

        # Start visiting
        self.out_cast = self.generate_cast()
        # print(self.out_cast[0].to_json_str())

    def generate_cast(self) -&gt; List[CAST]:
        &#34;&#34;&#34;Interface for generating CAST.&#34;&#34;&#34;
        modules = self.run(self.root_node)
        return [
            CAST([generate_dummy_source_refs(module)], &#34;Fortran&#34;) for module in modules
        ]

    def run(self, root) -&gt; List[Module]:
        &#34;&#34;&#34;Top level visitor function. Will return between 1-3 Module objects.&#34;&#34;&#34;
        # A program can have between 1-3 modules
        # 1. A module body
        # 2. A program body
        # 3. Everything else (defined functions)
        modules = []
        contexts = get_children_by_types(root, [&#34;module&#34;, &#34;program&#34;])
        for context in contexts:
            modules.append(self.visit(context))

        # Currently, we are supporting functions and subroutines defined outside of programs and modules
        # Other than comments, it is unclear if anything else is allowed.
        # TODO: Research the above
        outer_body_nodes = get_children_by_types(root, [&#34;function&#34;, &#34;subroutine&#34;])
        if len(outer_body_nodes) &gt; 0:
            body = []
            for body_node in outer_body_nodes:
                child_cast = self.visit(body_node)
                if isinstance(child_cast, List):
                    body.extend(child_cast)
                elif isinstance(child_cast, AstNode):
                    body.append(child_cast)
            modules.append(
                Module(
                    name=None,
                    body=body,
                    source_refs=[self.node_helper.get_source_ref(root)],
                )
            )

        return modules

    def visit(self, node: Node):
        if node.type in [&#34;program&#34;, &#34;module&#34;]:
            return self.visit_module(node)
        elif node.type == &#34;internal_procedures&#34;:
            return self.visit_internal_procedures(node)
        elif node.type in [&#34;subroutine&#34;, &#34;function&#34;]:
            return self.visit_function_def(node)
        elif node.type in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
            return self.visit_function_call(node)
        elif node.type == &#34;use_statement&#34;:
            return self.visit_use_statement(node)
        elif node.type == &#34;variable_declaration&#34;:
            return self.visit_variable_declaration(node)
        elif node.type == &#34;assignment_statement&#34;:
            return self.visit_assignment_statement(node)
        elif node.type == &#34;identifier&#34;:
            return self.visit_identifier(node)
        elif node.type == &#34;name&#34;:
            return self.visit_name(node)
        elif node.type in [
            &#34;unary_expression&#34;,
            &#34;math_expression&#34;,
            &#34;relational_expression&#34;,
        ]:
            return self.visit_math_expression(node)
        elif node.type in [
            &#34;number_literal&#34;,
            &#34;array_literal&#34;,
            &#34;string_literal&#34;,
            &#34;boolean_literal&#34;,
        ]:
            return self.visit_literal(node)
        elif node.type == &#34;keyword_statement&#34;:
            return self.visit_keyword_statement(node)
        elif node.type in builtin_statements:
            return self.visit_fortran_builtin_statement(node)
        elif node.type == &#34;extent_specifier&#34;:
            return self.visit_extent_specifier(node)
        elif node.type in [&#34;do_loop_statement&#34;]:
            return self.visit_do_loop_statement(node)
        elif node.type in [&#34;if_statement&#34;, &#34;else_if_clause&#34;, &#34;else_clause&#34;]:
            return self.visit_if_statement(node)
        elif node.type == &#34;logical_expression&#34;:
            return self.visit_logical_expression(node)
        elif node.type == &#34;derived_type_definition&#34;:
            return self.visit_derived_type(node)
        elif node.type == &#34;derived_type_member_expression&#34;:
            return self.visit_derived_type_member_expression(node)
        else:
            return self._visit_passthrough(node)

    def visit_module(self, node: Node) -&gt; Module:
        &#34;&#34;&#34;Visitor for program and module statement. Returns a Module object&#34;&#34;&#34;
        self.variable_context.push_context()

        program_body = []
        for child in node.children[1:-1]:  # Ignore the start and end program statement
            child_cast = self.visit(child)
            if isinstance(child_cast, List):
                program_body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                program_body.append(child_cast)

        self.variable_context.pop_context()

        return Module(
            name=None,  # TODO: Fill out name field
            body=program_body,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_internal_procedures(self, node: Node) -&gt; List[FunctionDef]:
        &#34;&#34;&#34;Visitor for internal procedures. Returns list of FunctionDef&#34;&#34;&#34;
        internal_procedures = get_children_by_types(node, [&#34;function&#34;, &#34;subroutine&#34;])
        return [self.visit(procedure) for procedure in internal_procedures]

    def visit_name(self, node):
        # Node structure
        # (name)

        # First, we will check if this name is already defined, and if it is return the name node generated previously
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            return self.variable_context.get_node(identifier)

        return self.variable_context.add_variable(
            identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
        )

    def visit_function_def(self, node):
        # TODO: Refactor function def code to use new helper functions
        # Node structure
        # (subroutine)
        #   (subroutine_statement)
        #     (subroutine)
        #     (name)
        #     (parameters) - Optional
        #   (body_node) ...
        # (function)
        #   (function_statement)
        #     (function)
        #     (intrinsic_type) - Optional
        #     (name)
        #     (parameters) - Optional
        #     (function_result) - Optional
        #       (identifier)
        #  (body_node) ...

        # Create a new variable context
        self.variable_context.push_context()

        # Top level statement node

        statement_node = get_children_by_types(
            node, [&#34;subroutine_statement&#34;, &#34;function_statement&#34;]
        )[0]

        name_node = get_first_child_by_type(statement_node, &#34;name&#34;)
        name = self.visit(
            name_node
        )  # Visit the name node to add it to the variable context

        # If this is a function, check for return type and return value
        if node.type == &#34;function&#34;:
            intrinsic_type = None
            return_value = None
            signature_qualifiers = get_children_by_types(
                statement_node, [&#34;intrinsic_type&#34;, &#34;function_result&#34;]
            )
            for qualifier in signature_qualifiers:
                if qualifier.type == &#34;intrinsic_type&#34;:
                    intrinsic_type = self.node_helper.get_identifier(qualifier)
                    self.variable_context.add_variable(
                        self.node_helper.get_identifier(name_node), intrinsic_type, None
                    )
                elif qualifier.type == &#34;function_result&#34;:
                    return_value = self.visit(
                        get_first_child_by_type(qualifier, &#34;identifier&#34;)
                    ).val
                    self.variable_context.add_return_value(return_value.name)

            # NOTE: In the case of a function specifically, if there is no explicit return value, the return value will be the name of the function
            # TODO: Should this be a node instead
            if not return_value:
                self.variable_context.add_return_value(
                    self.node_helper.get_identifier(name_node)
                )
                return_value = self.visit(name_node)

            # If funciton has both an explicit intrinsic type, then we also need to update the type of the return value in the variable context
            if intrinsic_type:
                self.variable_context.update_type(return_value.name, intrinsic_type)

        # Generating the function arguments by walking the parameters node
        func_args = []
        if parameters_node := get_first_child_by_type(statement_node, &#34;parameters&#34;):
            for parameter in get_non_control_children(parameters_node):
                # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
                # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
                self.variable_context.add_return_value(
                    self.node_helper.get_identifier(parameter)
                )
                func_args.append(self.visit(parameter))

        # The first child of function will be the function statement, the rest will be body nodes
        body = []
        for body_node in node.children[1:]:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)

        # After creating the body, we can go back and update the var nodes we created for the arguments
        # We do this by looking for intent,in nodes
        for i, arg in enumerate(func_args):
            func_args[i].type = self.variable_context.get_type(arg.val.name)

        # TODO:
        # This logic can be made cleaner
        # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
        # If there is not, then we will create a dummy one
        return_found = False
        for child in body:
            if isinstance(child, ModelReturn):
                return_found = True
        if not return_found:
            body.append(self.visit_keyword_statement(node))

        # Pop variable context off of stack before leaving this scope
        self.variable_context.pop_context()

        return FunctionDef(
            name=name,
            func_args=func_args,
            body=body,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_function_call(self, node):
        # Pull relevent nodes
        # A subroutine and function won&#39;t neccessarily have an arguments node.
        # So we should be careful about trying to access it.

        function_node = get_children_by_types(
            node,
            [
                &#34;unary_expression&#34;,
                &#34;subroutine&#34;,
                &#34;identifier&#34;,
                &#34;derived_type_member_expression&#34;,
            ],
        )[0]
        if function_node.type == &#34;derived_type_member_expression&#34;:
            return self.visit_derived_type_member_expression(function_node)

        arguments_node = get_first_child_by_type(node, &#34;argument_list&#34;)

        # If this is a unary expression (+foo()) the identifier will be nested.
        # TODO: If this is a non &#39;+&#39; unary expression, how do we add it to the CAST?
        if function_node.type == &#34;unary_expression&#34;:
            function_node = get_first_child_by_type(node, &#34;identifier&#34;, recurse=True)

        function_identifier = self.node_helper.get_identifier(function_node)

        # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
        # We will need to check if this is truly a function call or a subscript
        if self.variable_context.is_variable(function_identifier):
            if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
                return self._visit_get(
                    node
                )  # This overrides the visitor and forces us to visit another

        # TODO: What should get a name node? Instrincit functions? Imported functions?
        # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
        if self.variable_context.is_variable(function_identifier):
            func = self.variable_context.get_node(function_identifier)
        else:
            func = Name(function_identifier, -1)  # TODO: REFACTOR

        # Add arguments to arguments list
        arguments = []
        if arguments_node:
            for argument in arguments_node.children:
                child_cast = self.visit(argument)
                if child_cast:
                    arguments.append(child_cast)

        return Call(
            func=func,
            source_language=&#34;Fortran&#34;,
            source_language_version=&#34;2008&#34;,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_keyword_statement(self, node):
        # NOTE: RETURN is not the only Fortran keyword. GO TO and CONTINUE are also considered keywords.
        # TODO: Handle GO TO and CONTINUE
        identifier = self.node_helper.get_identifier(node).lower()
        if node.type == &#34;keyword_statement&#34;:
            if &#34;continue&#34; in identifier or &#34;go to&#34; in identifier:
                return self._visit_no_op(node)
            if &#34;exit&#34; in identifier:
                return ModelBreak(source_refs=[self.node_helper.get_source_ref(node)])

        # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
        # We keep track of values that need to be returned in the variable context
        return_values = self.variable_context.context_return_values[
            -1
        ]  # TODO: Make function for this

        if len(return_values) == 1:
            value = self.variable_context.get_node(list(return_values)[0])
        elif len(return_values) &gt; 1:
            value = LiteralValue(
                value_type=&#34;Tuple&#34;,
                value=[self.variable_context.get_node(ret) for ret in return_values],
                source_code_data_type=None,
                source_refs=None,
            )
        else:
            value = LiteralValue(value=None, value_type=None, source_refs=None)

        return ModelReturn(
            value=value, source_refs=[self.node_helper.get_source_ref(node)]
        )

    def visit_fortran_builtin_statement(self, node):
        &#34;&#34;&#34;Visitor for Fortran keywords that are not classified as keyword_statement by tree-sitter&#34;&#34;&#34;
        # All of the node types that fall into this category end with _statment.
        # So the function name will be the node type with _statement removed (write, read, open, ...)
        func = self.get_gromet_function_node(node.type.replace(&#34;_statement&#34;, &#34;&#34;))

        arguments = []

        return Call(
            func=func,
            arguments=arguments,
            source_language=&#34;Fortran&#34;,
            source_language_version=None,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_print_statement(self, node):
        func = self.get_gromet_function_node(&#34;print&#34;)

        arguments = []

        return Call(
            func=func,
            arguments=arguments,
            source_language=None,
            source_language_version=None,
        )

    def visit_use_statement(self, node):
        # (use)
        #   (use)
        #   (module_name)

        ## Pull relevent child nodes
        module_name_node = get_first_child_by_type(node, &#34;module_name&#34;)
        module_name = self.node_helper.get_identifier(module_name_node)
        included_items_node = get_first_child_by_type(node, &#34;included_items&#34;)

        import_all = included_items_node is None
        import_alias = None  # TODO: Look into local-name and use-name fields

        # We need to check if this import is a full import of a module, i.e. use module
        # Or a partial import i.e. use module,only: sub1, sub2
        if import_all:
            return ModelImport(
                name=module_name,
                alias=import_alias,
                all=import_all,
                symbol=None,
                source_refs=[self.node_helper.get_source_ref(node)],
            )
        else:
            imports = []
            for symbol in get_non_control_children(included_items_node):
                symbol_identifier = self.node_helper.get_identifier(symbol)
                symbol_source_refs = [self.node_helper.get_source_ref(symbol)]
                imports.append(
                    ModelImport(
                        name=module_name,
                        alias=import_alias,
                        all=import_all,
                        symbol=symbol_identifier,
                        source_refs=symbol_source_refs,
                    )
                )
            return imports

    def visit_do_loop_statement(self, node) -&gt; Loop:
        &#34;&#34;&#34;Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
        The do while loop will be passed off to a seperate visitor. Returns a Loop object.
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do loop
        (do_loop_statement)
            (loop_control_expression)
                (...) ...
            (body) ...
        
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;

        loop_control_node = get_first_child_by_type(node, &#34;loop_contrel_expression&#34;)
        if not loop_control_node:
            return self._visit_while(node)

        # If there is a loop control expression, the first body node will be the node after the loop_control_expression
        # It is valid Fortran to have a single itteration do loop as well.
        # NOTE: This code is for the creation of the main body. The do loop will still add some additional nodes at the end of this body.
        body_start_index = 1 + get_first_child_index(node, &#34;loop_control_expression&#34;)
        body = self.generate_cast_body(node.children[body_start_index:])

        # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop
        # PRE:
        # _next(_iter(range(start, stop, step)))
        loop_control_node = get_first_child_by_type(node, &#34;loop_control_expression&#34;)
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            itterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            itterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            itterator = None
            start = None
            stop = None
            step = None

        range_name_node = self.get_gromet_function_node(&#34;range&#34;)
        iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
        next_name_node = self.get_gromet_function_node(&#34;next&#34;)
        generated_iter_name_node = self.variable_context.generate_iterator()
        stop_condition_name_node = self.variable_context.generate_stop_condition()

        # generated_iter_0 = iter(range(start, stop, step))
        pre = []
        pre.append(
            Assignment(
                left=Var(generated_iter_name_node, &#34;Iterator&#34;),
                right=Call(
                    iter_name_node,
                    arguments=[Call(range_name_node, arguments=[start, stop, step])],
                ),
            )
        )

        # (i, generated_iter_0, sc_0) = next(generated_iter_0)
        pre.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # EXPR
        expr = []
        expr = Operator(
            op=&#34;!=&#34;,  # TODO: Should this be == or !=
            operands=[
                Var(stop_condition_name_node, &#34;Boolean&#34;),
                LiteralValue(&#34;Boolean&#34;, True),
            ],
        )

        # BODY
        # At this point, the body nodes have already been visited
        # We just need to append the iterator next call
        body.append(
            Assignment(
                left=LiteralValue(
                    &#34;Tuple&#34;,
                    [
                        itterator,
                        Var(generated_iter_name_node, &#34;Iterator&#34;),
                        Var(stop_condition_name_node, &#34;Boolean&#34;),
                    ],
                ),
                right=Call(
                    next_name_node,
                    arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
                ),
            )
        )

        # POST
        post = []
        post.append(
            Assignment(
                left=itterator,
                right=Operator(op=&#34;+&#34;, operands=[itterator, step]),
            )
        )

        return Loop(
            pre=pre,
            expr=expr,
            body=body,
            post=post,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_if_statement(self, node):
        # (if_statement)
        #  (if)
        #  (parenthesised_expression)
        #  (then)
        #  (body_nodes) ...
        #  (elseif_clauses) ..
        #  (else_clause)
        #  (end_if_statement)

        # TODO: Can you have a parenthesized expression as a body node
        body_nodes = get_children_except_types(
            node,
            [
                &#34;if&#34;,
                &#34;elseif&#34;,
                &#34;else&#34;,
                &#34;then&#34;,
                &#34;parenthesized_expression&#34;,
                &#34;elseif_clause&#34;,
                &#34;else_clause&#34;,
                &#34;end_if_statement&#34;,
            ],
        )
        body = self.generate_cast_body(body_nodes)

        expr_node = get_first_child_by_type(node, &#34;parenthesized_expression&#34;)
        expr = None
        if expr_node:
            expr = self.visit(expr_node)

        elseif_nodes = get_children_by_types(node, [&#34;elseif_clause&#34;])
        elseif_cast = [self.visit(elseif_clause) for elseif_clause in elseif_nodes]
        for i in range(len(elseif_cast) - 1):
            elseif_cast[i].orelse = [elseif_cast[i + 1]]

        else_node = get_first_child_by_type(node, &#34;else_clause&#34;)
        else_cast = None
        if else_node:
            else_cast = self.visit(else_node)

        orelse = []
        if len(elseif_cast) &gt; 0:
            orelse = [elseif_cast[0]]
        elif else_cast:
            orelse = else_cast.body

        return ModelIf(expr=expr, body=body, orelse=orelse)

    def visit_logical_expression(self, node):
        &#34;&#34;&#34;Visitior for logical expression (i.e. true and false) which is used in compound conditional&#34;&#34;&#34;
        # If this is a .not. operator, we need to pass it on to the math_expression visitor
        if len(node.children) &lt; 3:
            return self.visit_math_expression(node)

        literal_value_false = LiteralValue(&#34;Boolean&#34;, False)
        literal_value_true = LiteralValue(&#34;Boolean&#34;, True)

        # AND: Right side goes in body if, left side in condition
        # OR: Right side goes in body else, left side in condition
        left, operator, right = node.children

        # First we need to check if this is logical and or a logical or
        # The tehcnical types for these are \.or\. and \.and\. so to simplify things we can use the in keyword
        is_or = &#34;or&#34; in operator.type

        top_if = ModelIf()
        top_if_expr = self.visit(left)
        top_if.expr = top_if_expr

        bottom_if_expr = self.visit(right)
        if is_or:
            top_if.orelse = [bottom_if_expr]
            top_if.body = [literal_value_true]
        else:
            top_if.orelse = [literal_value_false]
            top_if.body = [bottom_if_expr]

        return top_if

    def visit_assignment_statement(self, node):
        left, _, right = node.children

        # We need to check if the left side is a multidimensional array,
        # Since tree-sitter incorrectly shows this assignment as a call_expression
        if left.type == &#34;call_expression&#34;:
            return self._visit_set(node)

        return Assignment(
            left=self.visit(left),
            right=self.visit(right),
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_literal(self, node) -&gt; LiteralValue:
        &#34;&#34;&#34;Visitor for literals. Returns a LiteralValue&#34;&#34;&#34;
        literal_type = node.type
        literal_value = self.node_helper.get_identifier(node)
        literal_source_ref = self.node_helper.get_source_ref(node)

        if literal_type == &#34;number_literal&#34;:
            # Check if this is a real value, or an Integer
            if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
                return LiteralValue(
                    value_type=&#34;AbstractFloat&#34;,
                    value=literal_value,
                    source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;real&#34;],
                    source_refs=[literal_source_ref],
                )
            else:
                return LiteralValue(
                    value_type=&#34;Integer&#34;,
                    value=literal_value,
                    source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;integer&#34;],
                    source_refs=[literal_source_ref],
                )

        elif literal_type == &#34;string_literal&#34;:
            return LiteralValue(
                value_type=&#34;Character&#34;,
                value=literal_value,
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;character&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;boolean_literal&#34;:
            return LiteralValue(
                value_type=&#34;Boolean&#34;,
                value=literal_value,
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;logical&#34;],
                source_refs=[literal_source_ref],
            )

        elif literal_type == &#34;array_literal&#34;:
            # There are a multiple ways to create an array literal. This visitor is for the traditional explicit creation (/ 1,2,3 /)
            # For the do loop based version, we pass it off to another visitor
            implied_do_loop_expression_node = get_first_child_by_type(
                node, &#34;implied_do_loop_expression&#34;
            )
            if implied_do_loop_expression_node:
                return self._visit_implied_do_loop(implied_do_loop_expression_node)

            return LiteralValue(
                value_type=&#34;List&#34;,
                value=[
                    self.visit(element) for element in get_non_control_children(node)
                ],
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;dimension&#34;],
                source_refs=[literal_source_ref],
            )

    def visit_identifier(self, node):
        # By default, this is unknown, but can be updated by other visitors
        identifier = self.node_helper.get_identifier(node)
        if self.variable_context.is_variable(identifier):
            var_type = self.variable_context.get_type(identifier)
        else:
            var_type = &#34;Unknown&#34;

        # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
        # Fortran does have optional arguments introduced in F90, but these do not specify a default
        default_value = None

        # This is another case where we need to override the visitor to explicitly visit another node
        value = self.visit_name(node)

        return Var(
            val=value,
            type=var_type,
            default_value=default_value,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_math_expression(self, node):
        op = self.node_helper.get_identifier(
            get_control_children(node)[0]
        )  # The operator will be the first control character
        operands = []
        for operand in get_non_control_children(node):
            operands.append(self.visit(operand))

            # For operators, we will only need the name node since we are not allocating space
            if operand.type == &#34;identifier&#34;:
                operands[-1] = operands[-1].val

        return Operator(
            source_language=&#34;Fortran&#34;,
            interpreter=None,
            version=None,
            op=op,
            operands=operands,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_variable_declaration(self, node) -&gt; List:
        &#34;&#34;&#34;Visitor for variable declaration. Will return a List of Var and Assignment nodes.&#34;&#34;&#34;
        &#34;&#34;&#34;
        # Node structure
        (variable_declaration)
            (intrinsic_type)
            (type_qualifier)
                (qualifier)
                (value)
            (identifier) ...
            (assignment_statement) ...

        (variable_declaration)
            (derived_type)
                (type_name)
        &#34;&#34;&#34;
        # A variable can be declared with an intrinsic_type if its built-in, or a derived_type if it is user defined.
        intrinsic_type_node = get_first_child_by_type(node, &#34;intrinsic_type&#34;)
        derived_type_node = get_first_child_by_type(node, &#34;derived_type&#34;)

        variable_type = &#34;&#34;
        variable_intent = &#34;&#34;

        if intrinsic_type_node:
            type_map = {
                &#34;integer&#34;: &#34;Integer&#34;,
                &#34;real&#34;: &#34;AbstractFloat&#34;,
                &#34;double precision&#34;: &#34;AbstractFloat&#34;,
                &#34;complex&#34;: &#34;Tuple&#34;,  # Complex is a Tuple (rational,irrational),
                &#34;logical&#34;: &#34;Boolean&#34;,
                &#34;character&#34;: &#34;String&#34;,
            }
            # NOTE: Identifiers are case sensitive, so we always need to make sure we are comparing to the lower() version
            variable_type = type_map[
                self.node_helper.get_identifier(intrinsic_type_node).lower()
            ]
        elif derived_type_node:
            variable_type = self.node_helper.get_identifier(
                get_first_child_by_type(derived_type_node, &#34;type_name&#34;, recurse=True),
            )

        # There are multiple type qualifiers that change the way we generate a variable
        # For example, we need to determine if we are creating an array (dimension) or a single variable
        type_qualifiers = get_children_by_types(node, [&#34;type_qualifier&#34;])
        for qualifier in type_qualifiers:
            field = self.node_helper.get_identifier(qualifier.children[0])

            if field == &#34;dimension&#34;:
                variable_type = &#34;List&#34;
            elif field == &#34;intent&#34;:
                variable_intent = self.node_helper.get_identifier(qualifier.children[1])

        # You can declare multiple variables of the same type in a single statement, so we need to create a Var or Assignment node for each instance
        definied_variables = get_children_by_types(
            node,
            [
                &#34;identifier&#34;,  # Variable declaration
                &#34;assignment_statement&#34;,  # Variable assignment
                &#34;call_expression&#34;,  # Dimension without intent
            ],
        )
        vars = []
        for variable in definied_variables:
            if variable.type == &#34;assignment_statement&#34;:
                if variable.children[0].type == &#34;call_expression&#34;:
                    vars.append(
                        Assignment(
                            left=self.visit(
                                get_first_child_by_type(
                                    variable.children[0], &#34;identifier&#34;
                                )
                            ),
                            right=self.visit(variable.children[2]),
                            source_refs=[self.node_helper.get_source_ref(variable)],
                        )
                    )
                    vars[-1].left.type = &#34;List&#34;
                    self.variable_context.update_type(vars[-1].left.val.name, &#34;List&#34;)
                else:
                    # If its a regular assignment, we can update the type normally
                    vars.append(self.visit(variable))
                    vars[-1].left.type = variable_type
                    self.variable_context.update_type(
                        vars[-1].left.val.name, variable_type
                    )

            elif variable.type == &#34;identifier&#34;:
                # A basic variable declaration, we visit the identifier and then update the type
                vars.append(self.visit(variable))
                vars[-1].type = variable_type
                self.variable_context.update_type(vars[-1].val.name, variable_type)
            elif variable.type == &#34;call_expression&#34;:
                # Declaring a dimension variable using the x(1:5) format. It will look like a call expression in tree-sitter.
                # We treat it like an identifier by visiting its identifier node. Then the type gets overridden by &#34;dimension&#34;
                vars.append(self.visit(get_first_child_by_type(variable, &#34;identifier&#34;)))
                vars[-1].type = &#34;List&#34;
                self.variable_context.update_type(vars[-1].val.name, &#34;List&#34;)

        # By default, all variables are added to a function&#39;s list of return values
        # If the intent is actually in, then we need to remove them from the list
        if variable_intent == &#34;in&#34;:
            for var in vars:
                self.variable_context.remove_return_value(var.val.name)

        return vars

    def visit_extent_specifier(self, node):
        # Node structure
        # (extent_specifier)
        #   (identifier)
        #   (identifier)

        # The extent specifier is the same as a slice, it can have a start, stop, and step
        # We can determine these by looking at the number of control characters in this node.
        # Fortran uses the character &#39;:&#39; to differentiate these values
        argument_pointer = 0
        arguments = [
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
            LiteralValue(&#34;None&#34;, &#34;None&#34;),
        ]
        for child in node.children:
            if child.type == &#34;:&#34;:
                argument_pointer += 1
            else:
                arguments[argument_pointer] = self.visit(child)

        return Call(
            func=self.get_gromet_function_node(&#34;slice&#34;),
            source_language=&#34;Fortran&#34;,
            source_language_version=&#34;Fortran95&#34;,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type(self, node: Node) -&gt; RecordDef:
        &#34;&#34;&#34;Visitor function for derived type definition. Will return a RecordDef&#34;&#34;&#34;
        &#34;&#34;&#34;Node Structure:
        (derived_type_definition)
            (derived_type_statement)
                (base)
                    (base_type_specifier)
                        (identifier)
                (type_name)
            (BODY_NODES)
            ...
        &#34;&#34;&#34;

        record_name = self.node_helper.get_identifier(
            get_first_child_by_type(node, &#34;type_name&#34;, recurse=True)
        )

        # There is no multiple inheritance in Fortran, so a type may only extend 1 other type
        bases = []
        derived_type_statement_node = get_first_child_by_type(
            node, &#34;derived_type_statement&#34;
        )
        base_node = get_first_child_by_type(
            derived_type_statement_node, &#34;identifier&#34;, recurse=True
        )
        if base_node:
            bases.append([self.node_helper.get_identifier(base_node)])

        # A derived type can contain symbols with the same name as those already in the main program body.
        # If we tell the variable context we are in a record definition, it will append the type name as a prefix to all defined variables.
        self.variable_context.enter_record_definition(record_name)

        # Note:
        funcs = []
        derived_type_procedures_node = get_first_child_by_type(
            node, &#34;derived_type_procedures&#34;
        )
        if derived_type_procedures_node:
            for procedure_node in get_children_by_types(
                derived_type_procedures_node, [&#34;procedure_statement&#34;]
            ):
                funcs.append(
                    self.visit_name(
                        get_first_child_by_type(procedure_node, &#34;method_name&#34;)
                    )
                )

        # A derived type can only have variable declarations in its body.
        fields = []
        variable_declarations = [
            self.visit(variable_declaration)
            for variable_declaration in get_children_by_types(
                node, [&#34;variable_declaration&#34;]
            )
        ]
        for declaration in variable_declarations:
            # Variable declarations always returns a list of Var or Assignment, even when only one var is being created
            for var in declaration:
                if isinstance(var, Var):
                    fields.append(var)
                elif isinstance(var, Assignment):
                    # Since this is a record definition, an assignment is actually equivalent to setting the default value
                    var.left.default_value = var.right
                    fields.append(var.left)
                # TODO: Handle dimension type (Call type)
                elif isinstance(var, Call):
                    pass
        # Leaving the record definition sets the prefix back to an empty string
        self.variable_context.exit_record_definition()

        return RecordDef(
            name=record_name,
            bases=bases,
            funcs=funcs,
            fields=fields,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def visit_derived_type_member_expression(self, node) -&gt; Attribute:
        &#34;&#34;&#34;Visitor function for derived type access. Returns an Attribute object&#34;&#34;&#34;
        &#34;&#34;&#34; Node Structure
        Scalar Access
        (derived_type_member_expression)
            (identifier)
            (type_member)

        Dimensional Access
        (derived_type_member_expression)
            (call_expression)
                (identifier)
                (argument_list)
            (type_member)
        &#34;&#34;&#34;

        # If we are accessing an attribute of a scalar type, we can simply pull the name node from the variable context.
        # However, if this is a dimensional type, we must convert it to a call to _get.
        call_expression_node = get_first_child_by_type(node, &#34;call_expression&#34;)
        if call_expression_node:
            value = self._visit_get(call_expression_node)
        else:
            # We shouldn&#39;t be accessing get_node directly, since it may not exist in the case of an import.
            # Instead, we should visit the identifier node which will add it to the variable context automatically if it doesn&#39;t exist.
            value = self.visit(
                get_first_child_by_type(node, &#34;identifier&#34;, recurse=True)
            )

        # NOTE: Attribue should be a Name node, NOT a string or Var node
        # attr = self.node_helper.get_identifier(
        #    get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)
        # )
        # print(self.node_helper.get_identifier(get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)))
        attr = self.visit_name(get_first_child_by_type(node, &#34;type_member&#34;))

        return Attribute(
            value=value,
            attr=attr,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    # NOTE: This function starts with _ because it will never be dispatched to directly. There is not a get node in the tree-sitter parse tree.
    # From context, we will determine when we are accessing an element of a List, and call this function,
    def _visit_get(self, node):
        # Node structure
        # (call_expression)
        #  (identifier)
        #  (argument_list)

        identifier_node = node.children[0]
        argument_nodes = get_non_control_children(node.children[1])

        # First argument to get is the List itself. We can get this by passing the identifier to the identifier visitor
        arguments = []
        arguments.append(self.visit(identifier_node))

        # If there are more than one arguments, then this is a multi dimensional array and we need to use an extended slice
        if len(argument_nodes) &gt; 1:
            dimension_list = LiteralValue()
            dimension_list.value_type = &#34;List&#34;
            dimension_list.value = []
            for argument in argument_nodes:
                dimension_list.value.append(self.visit(argument))

            extslice_call = Call()
            extslice_call.func = self.get_gromet_function_node(&#34;ext_slice&#34;)
            extslice_call.arguments = []
            extslice_call.arguments.append(dimension_list)

            arguments.append(extslice_call)
        else:
            arguments.append(self.visit(argument_nodes[0]))

        return Call(
            func=self.get_gromet_function_node(&#34;get&#34;),
            source_language=&#34;Fortran&#34;,
            source_language_version=&#34;Fortran95&#34;,
            arguments=arguments,
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_set(self, node):
        # Node structure
        # (assignment_statement)
        #  (call_expression)
        #  (right side)

        left, _, right = node.children

        # The left side is equivilent to a call gromet &#34;get&#34;, so we will first pass the left side to the get visitor
        # Then we can easily convert this to a &#34;set&#34; call by modifying the fields and then appending the right side to the function arguments
        cast_call = self._visit_get(left)
        cast_call.func = self.get_gromet_function_node(&#34;set&#34;)
        cast_call.arguments.append(self.visit(right))

        return cast_call

    def _visit_while(self, node) -&gt; Loop:
        &#34;&#34;&#34;Custom visitor for while loop. Returns a Loop object&#34;&#34;&#34;
        &#34;&#34;&#34;
        Node structure
        Do while
        (do_loop_statement)
            (while_statement)
                (parenthesized_expression)
                    (...) ...
            (body) ...
        &#34;&#34;&#34;
        while_statement_node = get_first_child_by_type(node, &#34;while_statement&#34;)

        # Fortran has certain while(True) constructs that won&#39;t contain a while_statement node
        if not while_statement_node:
            body_start_index = 0
            expr = LiteralValue(
                value_type=&#34;Boolean&#34;,
                value=&#34;True&#34;,
            )
        else:
            body_start_index = 1 + get_first_child_index(node, &#34;while_statement&#34;)
            # We don&#39;t have explicit handling for parenthesized_expression, but the passthrough handler will make sure that we visit the expression correctly.
            expr = self.visit(
                get_first_child_by_type(
                    while_statement_node, &#34;parenthesized_expression&#34;
                )
            )

        # The first body node will be the node after the while_statement
        body = self.generate_cast_body(node.children[body_start_index:])

        return Loop(
            pre=[],
            expr=expr,
            body=body,
            post=[],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_implied_do_loop(self, node) -&gt; Call:
        &#34;&#34;&#34;Custom visitor for implied_do_loop array literal. This form gets converted to a call to range&#34;&#34;&#34;
        # TODO: This loop_control is the same as the do loop. Can we turn this into one visitor?
        loop_control_node = get_first_child_by_type(
            node, &#34;loop_control_expression&#34;, recurse=True
        )
        loop_control_children = get_non_control_children(loop_control_node)
        if len(loop_control_children) == 3:
            itterator, start, stop = [
                self.visit(child) for child in loop_control_children
            ]
            step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
        elif len(loop_control_children) == 4:
            itterator, start, stop, step = [
                self.visit(child) for child in loop_control_children
            ]
        else:
            itterator = None
            start = None
            stop = None
            step = None

        return Call(
            func=self.get_gromet_function_node(&#34;range&#34;),
            source_language=None,
            source_language_version=None,
            arguments=[start, stop, step],
            source_refs=[self.node_helper.get_source_ref(node)],
        )

    def _visit_passthrough(self, node):
        if len(node.children) == 0:
            return None

        for child in node.children:
            child_cast = self.visit(child)
            if child_cast:
                return child_cast

    def _visit_no_op(self, node):
        &#34;&#34;&#34;For unsupported idioms, we can generate a no op instruction so that the body is not empty&#34;&#34;&#34;
        return Call(
            func=self.get_gromet_function_node(&#34;no_op&#34;),
            source_language=None,
            source_language_version=None,
            arguments=[],
        )

    def get_gromet_function_node(self, func_name: str) -&gt; Name:
        # Idealy, we would be able to create a dummy node and just call the name visitor.
        # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
        if self.variable_context.is_variable(func_name):
            return self.variable_context.get_node(func_name)

        return self.variable_context.add_variable(func_name, &#34;function&#34;, None)

    def generate_cast_body(self, body_nodes: List):
        body = []
        for node in body_nodes:
            cast = self.visit(node)
            if isinstance(cast, AstNode):
                body.append(cast)
            elif isinstance(cast, List):
                body.extend(cast)

        # Gromet doesn&#39;t support empty bodies, so we should create a no_op instead
        if len(body) == 0:
            body.append(self._visit_no_op(None))

        # TODO: How to add more support for source references
        return body</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.generate_cast"><code class="name flex">
<span>def <span class="ident">generate_cast</span></span>(<span>self) ‑> List[<a title="skema.program_analysis.CAST2FN.cast.CAST" href="../../CAST2FN/cast.html#skema.program_analysis.CAST2FN.cast.CAST">CAST</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Interface for generating CAST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_cast(self) -&gt; List[CAST]:
    &#34;&#34;&#34;Interface for generating CAST.&#34;&#34;&#34;
    modules = self.run(self.root_node)
    return [
        CAST([generate_dummy_source_refs(module)], &#34;Fortran&#34;) for module in modules
    ]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.generate_cast_body"><code class="name flex">
<span>def <span class="ident">generate_cast_body</span></span>(<span>self, body_nodes: List[~T])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_cast_body(self, body_nodes: List):
    body = []
    for node in body_nodes:
        cast = self.visit(node)
        if isinstance(cast, AstNode):
            body.append(cast)
        elif isinstance(cast, List):
            body.extend(cast)

    # Gromet doesn&#39;t support empty bodies, so we should create a no_op instead
    if len(body) == 0:
        body.append(self._visit_no_op(None))

    # TODO: How to add more support for source references
    return body</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.get_gromet_function_node"><code class="name flex">
<span>def <span class="ident">get_gromet_function_node</span></span>(<span>self, func_name: str) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.name.Name" href="../../CAST2FN/model/cast/name.html#skema.program_analysis.CAST2FN.model.cast.name.Name">Name</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gromet_function_node(self, func_name: str) -&gt; Name:
    # Idealy, we would be able to create a dummy node and just call the name visitor.
    # However, tree-sitter does not allow you to create or modify nodes, so we have to recreate the logic here.
    if self.variable_context.is_variable(func_name):
        return self.variable_context.get_node(func_name)

    return self.variable_context.add_variable(func_name, &#34;function&#34;, None)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, root) ‑> List[<a title="skema.program_analysis.CAST2FN.model.cast.module.Module" href="../../CAST2FN/model/cast/module.html#skema.program_analysis.CAST2FN.model.cast.module.Module">Module</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Top level visitor function. Will return between 1-3 Module objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, root) -&gt; List[Module]:
    &#34;&#34;&#34;Top level visitor function. Will return between 1-3 Module objects.&#34;&#34;&#34;
    # A program can have between 1-3 modules
    # 1. A module body
    # 2. A program body
    # 3. Everything else (defined functions)
    modules = []
    contexts = get_children_by_types(root, [&#34;module&#34;, &#34;program&#34;])
    for context in contexts:
        modules.append(self.visit(context))

    # Currently, we are supporting functions and subroutines defined outside of programs and modules
    # Other than comments, it is unclear if anything else is allowed.
    # TODO: Research the above
    outer_body_nodes = get_children_by_types(root, [&#34;function&#34;, &#34;subroutine&#34;])
    if len(outer_body_nodes) &gt; 0:
        body = []
        for body_node in outer_body_nodes:
            child_cast = self.visit(body_node)
            if isinstance(child_cast, List):
                body.extend(child_cast)
            elif isinstance(child_cast, AstNode):
                body.append(child_cast)
        modules.append(
            Module(
                name=None,
                body=body,
                source_refs=[self.node_helper.get_source_ref(root)],
            )
        )

    return modules</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node: tree_sitter.Node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node: Node):
    if node.type in [&#34;program&#34;, &#34;module&#34;]:
        return self.visit_module(node)
    elif node.type == &#34;internal_procedures&#34;:
        return self.visit_internal_procedures(node)
    elif node.type in [&#34;subroutine&#34;, &#34;function&#34;]:
        return self.visit_function_def(node)
    elif node.type in [&#34;subroutine_call&#34;, &#34;call_expression&#34;]:
        return self.visit_function_call(node)
    elif node.type == &#34;use_statement&#34;:
        return self.visit_use_statement(node)
    elif node.type == &#34;variable_declaration&#34;:
        return self.visit_variable_declaration(node)
    elif node.type == &#34;assignment_statement&#34;:
        return self.visit_assignment_statement(node)
    elif node.type == &#34;identifier&#34;:
        return self.visit_identifier(node)
    elif node.type == &#34;name&#34;:
        return self.visit_name(node)
    elif node.type in [
        &#34;unary_expression&#34;,
        &#34;math_expression&#34;,
        &#34;relational_expression&#34;,
    ]:
        return self.visit_math_expression(node)
    elif node.type in [
        &#34;number_literal&#34;,
        &#34;array_literal&#34;,
        &#34;string_literal&#34;,
        &#34;boolean_literal&#34;,
    ]:
        return self.visit_literal(node)
    elif node.type == &#34;keyword_statement&#34;:
        return self.visit_keyword_statement(node)
    elif node.type in builtin_statements:
        return self.visit_fortran_builtin_statement(node)
    elif node.type == &#34;extent_specifier&#34;:
        return self.visit_extent_specifier(node)
    elif node.type in [&#34;do_loop_statement&#34;]:
        return self.visit_do_loop_statement(node)
    elif node.type in [&#34;if_statement&#34;, &#34;else_if_clause&#34;, &#34;else_clause&#34;]:
        return self.visit_if_statement(node)
    elif node.type == &#34;logical_expression&#34;:
        return self.visit_logical_expression(node)
    elif node.type == &#34;derived_type_definition&#34;:
        return self.visit_derived_type(node)
    elif node.type == &#34;derived_type_member_expression&#34;:
        return self.visit_derived_type_member_expression(node)
    else:
        return self._visit_passthrough(node)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_assignment_statement"><code class="name flex">
<span>def <span class="ident">visit_assignment_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_assignment_statement(self, node):
    left, _, right = node.children

    # We need to check if the left side is a multidimensional array,
    # Since tree-sitter incorrectly shows this assignment as a call_expression
    if left.type == &#34;call_expression&#34;:
        return self._visit_set(node)

    return Assignment(
        left=self.visit(left),
        right=self.visit(right),
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_derived_type"><code class="name flex">
<span>def <span class="ident">visit_derived_type</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.record_def.RecordDef" href="../../CAST2FN/model/cast/record_def.html#skema.program_analysis.CAST2FN.model.cast.record_def.RecordDef">RecordDef</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor function for derived type definition. Will return a RecordDef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_derived_type(self, node: Node) -&gt; RecordDef:
    &#34;&#34;&#34;Visitor function for derived type definition. Will return a RecordDef&#34;&#34;&#34;
    &#34;&#34;&#34;Node Structure:
    (derived_type_definition)
        (derived_type_statement)
            (base)
                (base_type_specifier)
                    (identifier)
            (type_name)
        (BODY_NODES)
        ...
    &#34;&#34;&#34;

    record_name = self.node_helper.get_identifier(
        get_first_child_by_type(node, &#34;type_name&#34;, recurse=True)
    )

    # There is no multiple inheritance in Fortran, so a type may only extend 1 other type
    bases = []
    derived_type_statement_node = get_first_child_by_type(
        node, &#34;derived_type_statement&#34;
    )
    base_node = get_first_child_by_type(
        derived_type_statement_node, &#34;identifier&#34;, recurse=True
    )
    if base_node:
        bases.append([self.node_helper.get_identifier(base_node)])

    # A derived type can contain symbols with the same name as those already in the main program body.
    # If we tell the variable context we are in a record definition, it will append the type name as a prefix to all defined variables.
    self.variable_context.enter_record_definition(record_name)

    # Note:
    funcs = []
    derived_type_procedures_node = get_first_child_by_type(
        node, &#34;derived_type_procedures&#34;
    )
    if derived_type_procedures_node:
        for procedure_node in get_children_by_types(
            derived_type_procedures_node, [&#34;procedure_statement&#34;]
        ):
            funcs.append(
                self.visit_name(
                    get_first_child_by_type(procedure_node, &#34;method_name&#34;)
                )
            )

    # A derived type can only have variable declarations in its body.
    fields = []
    variable_declarations = [
        self.visit(variable_declaration)
        for variable_declaration in get_children_by_types(
            node, [&#34;variable_declaration&#34;]
        )
    ]
    for declaration in variable_declarations:
        # Variable declarations always returns a list of Var or Assignment, even when only one var is being created
        for var in declaration:
            if isinstance(var, Var):
                fields.append(var)
            elif isinstance(var, Assignment):
                # Since this is a record definition, an assignment is actually equivalent to setting the default value
                var.left.default_value = var.right
                fields.append(var.left)
            # TODO: Handle dimension type (Call type)
            elif isinstance(var, Call):
                pass
    # Leaving the record definition sets the prefix back to an empty string
    self.variable_context.exit_record_definition()

    return RecordDef(
        name=record_name,
        bases=bases,
        funcs=funcs,
        fields=fields,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_derived_type_member_expression"><code class="name flex">
<span>def <span class="ident">visit_derived_type_member_expression</span></span>(<span>self, node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.attribute.Attribute" href="../../CAST2FN/model/cast/attribute.html#skema.program_analysis.CAST2FN.model.cast.attribute.Attribute">Attribute</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor function for derived type access. Returns an Attribute object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_derived_type_member_expression(self, node) -&gt; Attribute:
    &#34;&#34;&#34;Visitor function for derived type access. Returns an Attribute object&#34;&#34;&#34;
    &#34;&#34;&#34; Node Structure
    Scalar Access
    (derived_type_member_expression)
        (identifier)
        (type_member)

    Dimensional Access
    (derived_type_member_expression)
        (call_expression)
            (identifier)
            (argument_list)
        (type_member)
    &#34;&#34;&#34;

    # If we are accessing an attribute of a scalar type, we can simply pull the name node from the variable context.
    # However, if this is a dimensional type, we must convert it to a call to _get.
    call_expression_node = get_first_child_by_type(node, &#34;call_expression&#34;)
    if call_expression_node:
        value = self._visit_get(call_expression_node)
    else:
        # We shouldn&#39;t be accessing get_node directly, since it may not exist in the case of an import.
        # Instead, we should visit the identifier node which will add it to the variable context automatically if it doesn&#39;t exist.
        value = self.visit(
            get_first_child_by_type(node, &#34;identifier&#34;, recurse=True)
        )

    # NOTE: Attribue should be a Name node, NOT a string or Var node
    # attr = self.node_helper.get_identifier(
    #    get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)
    # )
    # print(self.node_helper.get_identifier(get_first_child_by_type(node, &#34;type_member&#34;, recurse=True)))
    attr = self.visit_name(get_first_child_by_type(node, &#34;type_member&#34;))

    return Attribute(
        value=value,
        attr=attr,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_do_loop_statement"><code class="name flex">
<span>def <span class="ident">visit_do_loop_statement</span></span>(<span>self, node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.loop.Loop" href="../../CAST2FN/model/cast/loop.html#skema.program_analysis.CAST2FN.model.cast.loop.Loop">Loop</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
The do while loop will be passed off to a seperate visitor. Returns a Loop object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_do_loop_statement(self, node) -&gt; Loop:
    &#34;&#34;&#34;Visitor for Loops. Do to complexity, this visitor logic only handles the range-based do loop.
    The do while loop will be passed off to a seperate visitor. Returns a Loop object.
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    Node structure
    Do loop
    (do_loop_statement)
        (loop_control_expression)
            (...) ...
        (body) ...
    
    Do while
    (do_loop_statement)
        (while_statement)
            (parenthesized_expression)
                (...) ...
        (body) ...
    &#34;&#34;&#34;

    loop_control_node = get_first_child_by_type(node, &#34;loop_contrel_expression&#34;)
    if not loop_control_node:
        return self._visit_while(node)

    # If there is a loop control expression, the first body node will be the node after the loop_control_expression
    # It is valid Fortran to have a single itteration do loop as well.
    # NOTE: This code is for the creation of the main body. The do loop will still add some additional nodes at the end of this body.
    body_start_index = 1 + get_first_child_index(node, &#34;loop_control_expression&#34;)
    body = self.generate_cast_body(node.children[body_start_index:])

    # For the init and expression fields, we first need to determine if we are in a regular &#34;do&#34; or a &#34;do while&#34; loop
    # PRE:
    # _next(_iter(range(start, stop, step)))
    loop_control_node = get_first_child_by_type(node, &#34;loop_control_expression&#34;)
    loop_control_children = get_non_control_children(loop_control_node)
    if len(loop_control_children) == 3:
        itterator, start, stop = [
            self.visit(child) for child in loop_control_children
        ]
        step = LiteralValue(&#34;Integer&#34;, &#34;1&#34;)
    elif len(loop_control_children) == 4:
        itterator, start, stop, step = [
            self.visit(child) for child in loop_control_children
        ]
    else:
        itterator = None
        start = None
        stop = None
        step = None

    range_name_node = self.get_gromet_function_node(&#34;range&#34;)
    iter_name_node = self.get_gromet_function_node(&#34;iter&#34;)
    next_name_node = self.get_gromet_function_node(&#34;next&#34;)
    generated_iter_name_node = self.variable_context.generate_iterator()
    stop_condition_name_node = self.variable_context.generate_stop_condition()

    # generated_iter_0 = iter(range(start, stop, step))
    pre = []
    pre.append(
        Assignment(
            left=Var(generated_iter_name_node, &#34;Iterator&#34;),
            right=Call(
                iter_name_node,
                arguments=[Call(range_name_node, arguments=[start, stop, step])],
            ),
        )
    )

    # (i, generated_iter_0, sc_0) = next(generated_iter_0)
    pre.append(
        Assignment(
            left=LiteralValue(
                &#34;Tuple&#34;,
                [
                    itterator,
                    Var(generated_iter_name_node, &#34;Iterator&#34;),
                    Var(stop_condition_name_node, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_name_node,
                arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
            ),
        )
    )

    # EXPR
    expr = []
    expr = Operator(
        op=&#34;!=&#34;,  # TODO: Should this be == or !=
        operands=[
            Var(stop_condition_name_node, &#34;Boolean&#34;),
            LiteralValue(&#34;Boolean&#34;, True),
        ],
    )

    # BODY
    # At this point, the body nodes have already been visited
    # We just need to append the iterator next call
    body.append(
        Assignment(
            left=LiteralValue(
                &#34;Tuple&#34;,
                [
                    itterator,
                    Var(generated_iter_name_node, &#34;Iterator&#34;),
                    Var(stop_condition_name_node, &#34;Boolean&#34;),
                ],
            ),
            right=Call(
                next_name_node,
                arguments=[Var(generated_iter_name_node, &#34;Iterator&#34;)],
            ),
        )
    )

    # POST
    post = []
    post.append(
        Assignment(
            left=itterator,
            right=Operator(op=&#34;+&#34;, operands=[itterator, step]),
        )
    )

    return Loop(
        pre=pre,
        expr=expr,
        body=body,
        post=post,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_extent_specifier"><code class="name flex">
<span>def <span class="ident">visit_extent_specifier</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_extent_specifier(self, node):
    # Node structure
    # (extent_specifier)
    #   (identifier)
    #   (identifier)

    # The extent specifier is the same as a slice, it can have a start, stop, and step
    # We can determine these by looking at the number of control characters in this node.
    # Fortran uses the character &#39;:&#39; to differentiate these values
    argument_pointer = 0
    arguments = [
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
        LiteralValue(&#34;None&#34;, &#34;None&#34;),
    ]
    for child in node.children:
        if child.type == &#34;:&#34;:
            argument_pointer += 1
        else:
            arguments[argument_pointer] = self.visit(child)

    return Call(
        func=self.get_gromet_function_node(&#34;slice&#34;),
        source_language=&#34;Fortran&#34;,
        source_language_version=&#34;Fortran95&#34;,
        arguments=arguments,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_fortran_builtin_statement"><code class="name flex">
<span>def <span class="ident">visit_fortran_builtin_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for Fortran keywords that are not classified as keyword_statement by tree-sitter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_fortran_builtin_statement(self, node):
    &#34;&#34;&#34;Visitor for Fortran keywords that are not classified as keyword_statement by tree-sitter&#34;&#34;&#34;
    # All of the node types that fall into this category end with _statment.
    # So the function name will be the node type with _statement removed (write, read, open, ...)
    func = self.get_gromet_function_node(node.type.replace(&#34;_statement&#34;, &#34;&#34;))

    arguments = []

    return Call(
        func=func,
        arguments=arguments,
        source_language=&#34;Fortran&#34;,
        source_language_version=None,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_function_call"><code class="name flex">
<span>def <span class="ident">visit_function_call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_call(self, node):
    # Pull relevent nodes
    # A subroutine and function won&#39;t neccessarily have an arguments node.
    # So we should be careful about trying to access it.

    function_node = get_children_by_types(
        node,
        [
            &#34;unary_expression&#34;,
            &#34;subroutine&#34;,
            &#34;identifier&#34;,
            &#34;derived_type_member_expression&#34;,
        ],
    )[0]
    if function_node.type == &#34;derived_type_member_expression&#34;:
        return self.visit_derived_type_member_expression(function_node)

    arguments_node = get_first_child_by_type(node, &#34;argument_list&#34;)

    # If this is a unary expression (+foo()) the identifier will be nested.
    # TODO: If this is a non &#39;+&#39; unary expression, how do we add it to the CAST?
    if function_node.type == &#34;unary_expression&#34;:
        function_node = get_first_child_by_type(node, &#34;identifier&#34;, recurse=True)

    function_identifier = self.node_helper.get_identifier(function_node)

    # Tree-Sitter incorrectly parses mutlidimensional array accesses as function calls
    # We will need to check if this is truly a function call or a subscript
    if self.variable_context.is_variable(function_identifier):
        if self.variable_context.get_type(function_identifier) == &#34;List&#34;:
            return self._visit_get(
                node
            )  # This overrides the visitor and forces us to visit another

    # TODO: What should get a name node? Instrincit functions? Imported functions?
    # Judging from the Gromet generation pipeline, it appears that all functions need Name nodes.
    if self.variable_context.is_variable(function_identifier):
        func = self.variable_context.get_node(function_identifier)
    else:
        func = Name(function_identifier, -1)  # TODO: REFACTOR

    # Add arguments to arguments list
    arguments = []
    if arguments_node:
        for argument in arguments_node.children:
            child_cast = self.visit(argument)
            if child_cast:
                arguments.append(child_cast)

    return Call(
        func=func,
        source_language=&#34;Fortran&#34;,
        source_language_version=&#34;2008&#34;,
        arguments=arguments,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_function_def"><code class="name flex">
<span>def <span class="ident">visit_function_def</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function_def(self, node):
    # TODO: Refactor function def code to use new helper functions
    # Node structure
    # (subroutine)
    #   (subroutine_statement)
    #     (subroutine)
    #     (name)
    #     (parameters) - Optional
    #   (body_node) ...
    # (function)
    #   (function_statement)
    #     (function)
    #     (intrinsic_type) - Optional
    #     (name)
    #     (parameters) - Optional
    #     (function_result) - Optional
    #       (identifier)
    #  (body_node) ...

    # Create a new variable context
    self.variable_context.push_context()

    # Top level statement node

    statement_node = get_children_by_types(
        node, [&#34;subroutine_statement&#34;, &#34;function_statement&#34;]
    )[0]

    name_node = get_first_child_by_type(statement_node, &#34;name&#34;)
    name = self.visit(
        name_node
    )  # Visit the name node to add it to the variable context

    # If this is a function, check for return type and return value
    if node.type == &#34;function&#34;:
        intrinsic_type = None
        return_value = None
        signature_qualifiers = get_children_by_types(
            statement_node, [&#34;intrinsic_type&#34;, &#34;function_result&#34;]
        )
        for qualifier in signature_qualifiers:
            if qualifier.type == &#34;intrinsic_type&#34;:
                intrinsic_type = self.node_helper.get_identifier(qualifier)
                self.variable_context.add_variable(
                    self.node_helper.get_identifier(name_node), intrinsic_type, None
                )
            elif qualifier.type == &#34;function_result&#34;:
                return_value = self.visit(
                    get_first_child_by_type(qualifier, &#34;identifier&#34;)
                ).val
                self.variable_context.add_return_value(return_value.name)

        # NOTE: In the case of a function specifically, if there is no explicit return value, the return value will be the name of the function
        # TODO: Should this be a node instead
        if not return_value:
            self.variable_context.add_return_value(
                self.node_helper.get_identifier(name_node)
            )
            return_value = self.visit(name_node)

        # If funciton has both an explicit intrinsic type, then we also need to update the type of the return value in the variable context
        if intrinsic_type:
            self.variable_context.update_type(return_value.name, intrinsic_type)

    # Generating the function arguments by walking the parameters node
    func_args = []
    if parameters_node := get_first_child_by_type(statement_node, &#34;parameters&#34;):
        for parameter in get_non_control_children(parameters_node):
            # For both subroutine and functions, all arguments are assumes intent(inout) by default unless otherwise specified with intent(in)
            # The variable declaration visitor will check for this and remove any arguments that are input only from the return values
            self.variable_context.add_return_value(
                self.node_helper.get_identifier(parameter)
            )
            func_args.append(self.visit(parameter))

    # The first child of function will be the function statement, the rest will be body nodes
    body = []
    for body_node in node.children[1:]:
        child_cast = self.visit(body_node)
        if isinstance(child_cast, List):
            body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            body.append(child_cast)

    # After creating the body, we can go back and update the var nodes we created for the arguments
    # We do this by looking for intent,in nodes
    for i, arg in enumerate(func_args):
        func_args[i].type = self.variable_context.get_type(arg.val.name)

    # TODO:
    # This logic can be made cleaner
    # Fortran doesn&#39;t require a return statement, so we need to check if there is a top-level return statement
    # If there is not, then we will create a dummy one
    return_found = False
    for child in body:
        if isinstance(child, ModelReturn):
            return_found = True
    if not return_found:
        body.append(self.visit_keyword_statement(node))

    # Pop variable context off of stack before leaving this scope
    self.variable_context.pop_context()

    return FunctionDef(
        name=name,
        func_args=func_args,
        body=body,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_identifier"><code class="name flex">
<span>def <span class="ident">visit_identifier</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_identifier(self, node):
    # By default, this is unknown, but can be updated by other visitors
    identifier = self.node_helper.get_identifier(node)
    if self.variable_context.is_variable(identifier):
        var_type = self.variable_context.get_type(identifier)
    else:
        var_type = &#34;Unknown&#34;

    # Default value comes from Pytohn keyword arguments i.e. def foo(a, b=10)
    # Fortran does have optional arguments introduced in F90, but these do not specify a default
    default_value = None

    # This is another case where we need to override the visitor to explicitly visit another node
    value = self.visit_name(node)

    return Var(
        val=value,
        type=var_type,
        default_value=default_value,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_if_statement"><code class="name flex">
<span>def <span class="ident">visit_if_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_if_statement(self, node):
    # (if_statement)
    #  (if)
    #  (parenthesised_expression)
    #  (then)
    #  (body_nodes) ...
    #  (elseif_clauses) ..
    #  (else_clause)
    #  (end_if_statement)

    # TODO: Can you have a parenthesized expression as a body node
    body_nodes = get_children_except_types(
        node,
        [
            &#34;if&#34;,
            &#34;elseif&#34;,
            &#34;else&#34;,
            &#34;then&#34;,
            &#34;parenthesized_expression&#34;,
            &#34;elseif_clause&#34;,
            &#34;else_clause&#34;,
            &#34;end_if_statement&#34;,
        ],
    )
    body = self.generate_cast_body(body_nodes)

    expr_node = get_first_child_by_type(node, &#34;parenthesized_expression&#34;)
    expr = None
    if expr_node:
        expr = self.visit(expr_node)

    elseif_nodes = get_children_by_types(node, [&#34;elseif_clause&#34;])
    elseif_cast = [self.visit(elseif_clause) for elseif_clause in elseif_nodes]
    for i in range(len(elseif_cast) - 1):
        elseif_cast[i].orelse = [elseif_cast[i + 1]]

    else_node = get_first_child_by_type(node, &#34;else_clause&#34;)
    else_cast = None
    if else_node:
        else_cast = self.visit(else_node)

    orelse = []
    if len(elseif_cast) &gt; 0:
        orelse = [elseif_cast[0]]
    elif else_cast:
        orelse = else_cast.body

    return ModelIf(expr=expr, body=body, orelse=orelse)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_internal_procedures"><code class="name flex">
<span>def <span class="ident">visit_internal_procedures</span></span>(<span>self, node: tree_sitter.Node) ‑> List[<a title="skema.program_analysis.CAST2FN.model.cast.function_def.FunctionDef" href="../../CAST2FN/model/cast/function_def.html#skema.program_analysis.CAST2FN.model.cast.function_def.FunctionDef">FunctionDef</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for internal procedures. Returns list of FunctionDef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_internal_procedures(self, node: Node) -&gt; List[FunctionDef]:
    &#34;&#34;&#34;Visitor for internal procedures. Returns list of FunctionDef&#34;&#34;&#34;
    internal_procedures = get_children_by_types(node, [&#34;function&#34;, &#34;subroutine&#34;])
    return [self.visit(procedure) for procedure in internal_procedures]</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_keyword_statement"><code class="name flex">
<span>def <span class="ident">visit_keyword_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_keyword_statement(self, node):
    # NOTE: RETURN is not the only Fortran keyword. GO TO and CONTINUE are also considered keywords.
    # TODO: Handle GO TO and CONTINUE
    identifier = self.node_helper.get_identifier(node).lower()
    if node.type == &#34;keyword_statement&#34;:
        if &#34;continue&#34; in identifier or &#34;go to&#34; in identifier:
            return self._visit_no_op(node)
        if &#34;exit&#34; in identifier:
            return ModelBreak(source_refs=[self.node_helper.get_source_ref(node)])

    # In Fortran the return statement doesn&#39;t return a value (there is the obsolete &#34;alternative return&#34;)
    # We keep track of values that need to be returned in the variable context
    return_values = self.variable_context.context_return_values[
        -1
    ]  # TODO: Make function for this

    if len(return_values) == 1:
        value = self.variable_context.get_node(list(return_values)[0])
    elif len(return_values) &gt; 1:
        value = LiteralValue(
            value_type=&#34;Tuple&#34;,
            value=[self.variable_context.get_node(ret) for ret in return_values],
            source_code_data_type=None,
            source_refs=None,
        )
    else:
        value = LiteralValue(value=None, value_type=None, source_refs=None)

    return ModelReturn(
        value=value, source_refs=[self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_literal"><code class="name flex">
<span>def <span class="ident">visit_literal</span></span>(<span>self, node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.literal_value.LiteralValue" href="../../CAST2FN/model/cast/literal_value.html#skema.program_analysis.CAST2FN.model.cast.literal_value.LiteralValue">LiteralValue</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for literals. Returns a LiteralValue</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_literal(self, node) -&gt; LiteralValue:
    &#34;&#34;&#34;Visitor for literals. Returns a LiteralValue&#34;&#34;&#34;
    literal_type = node.type
    literal_value = self.node_helper.get_identifier(node)
    literal_source_ref = self.node_helper.get_source_ref(node)

    if literal_type == &#34;number_literal&#34;:
        # Check if this is a real value, or an Integer
        if &#34;e&#34; in literal_value.lower() or &#34;.&#34; in literal_value:
            return LiteralValue(
                value_type=&#34;AbstractFloat&#34;,
                value=literal_value,
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;real&#34;],
                source_refs=[literal_source_ref],
            )
        else:
            return LiteralValue(
                value_type=&#34;Integer&#34;,
                value=literal_value,
                source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;integer&#34;],
                source_refs=[literal_source_ref],
            )

    elif literal_type == &#34;string_literal&#34;:
        return LiteralValue(
            value_type=&#34;Character&#34;,
            value=literal_value,
            source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;character&#34;],
            source_refs=[literal_source_ref],
        )

    elif literal_type == &#34;boolean_literal&#34;:
        return LiteralValue(
            value_type=&#34;Boolean&#34;,
            value=literal_value,
            source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;logical&#34;],
            source_refs=[literal_source_ref],
        )

    elif literal_type == &#34;array_literal&#34;:
        # There are a multiple ways to create an array literal. This visitor is for the traditional explicit creation (/ 1,2,3 /)
        # For the do loop based version, we pass it off to another visitor
        implied_do_loop_expression_node = get_first_child_by_type(
            node, &#34;implied_do_loop_expression&#34;
        )
        if implied_do_loop_expression_node:
            return self._visit_implied_do_loop(implied_do_loop_expression_node)

        return LiteralValue(
            value_type=&#34;List&#34;,
            value=[
                self.visit(element) for element in get_non_control_children(node)
            ],
            source_code_data_type=[&#34;Fortran&#34;, &#34;Fortran95&#34;, &#34;dimension&#34;],
            source_refs=[literal_source_ref],
        )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_logical_expression"><code class="name flex">
<span>def <span class="ident">visit_logical_expression</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitior for logical expression (i.e. true and false) which is used in compound conditional</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_logical_expression(self, node):
    &#34;&#34;&#34;Visitior for logical expression (i.e. true and false) which is used in compound conditional&#34;&#34;&#34;
    # If this is a .not. operator, we need to pass it on to the math_expression visitor
    if len(node.children) &lt; 3:
        return self.visit_math_expression(node)

    literal_value_false = LiteralValue(&#34;Boolean&#34;, False)
    literal_value_true = LiteralValue(&#34;Boolean&#34;, True)

    # AND: Right side goes in body if, left side in condition
    # OR: Right side goes in body else, left side in condition
    left, operator, right = node.children

    # First we need to check if this is logical and or a logical or
    # The tehcnical types for these are \.or\. and \.and\. so to simplify things we can use the in keyword
    is_or = &#34;or&#34; in operator.type

    top_if = ModelIf()
    top_if_expr = self.visit(left)
    top_if.expr = top_if_expr

    bottom_if_expr = self.visit(right)
    if is_or:
        top_if.orelse = [bottom_if_expr]
        top_if.body = [literal_value_true]
    else:
        top_if.orelse = [literal_value_false]
        top_if.body = [bottom_if_expr]

    return top_if</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_math_expression"><code class="name flex">
<span>def <span class="ident">visit_math_expression</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_math_expression(self, node):
    op = self.node_helper.get_identifier(
        get_control_children(node)[0]
    )  # The operator will be the first control character
    operands = []
    for operand in get_non_control_children(node):
        operands.append(self.visit(operand))

        # For operators, we will only need the name node since we are not allocating space
        if operand.type == &#34;identifier&#34;:
            operands[-1] = operands[-1].val

    return Operator(
        source_language=&#34;Fortran&#34;,
        interpreter=None,
        version=None,
        op=op,
        operands=operands,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_module"><code class="name flex">
<span>def <span class="ident">visit_module</span></span>(<span>self, node: tree_sitter.Node) ‑> <a title="skema.program_analysis.CAST2FN.model.cast.module.Module" href="../../CAST2FN/model/cast/module.html#skema.program_analysis.CAST2FN.model.cast.module.Module">Module</a></span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for program and module statement. Returns a Module object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_module(self, node: Node) -&gt; Module:
    &#34;&#34;&#34;Visitor for program and module statement. Returns a Module object&#34;&#34;&#34;
    self.variable_context.push_context()

    program_body = []
    for child in node.children[1:-1]:  # Ignore the start and end program statement
        child_cast = self.visit(child)
        if isinstance(child_cast, List):
            program_body.extend(child_cast)
        elif isinstance(child_cast, AstNode):
            program_body.append(child_cast)

    self.variable_context.pop_context()

    return Module(
        name=None,  # TODO: Fill out name field
        body=program_body,
        source_refs=[self.node_helper.get_source_ref(node)],
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_name"><code class="name flex">
<span>def <span class="ident">visit_name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_name(self, node):
    # Node structure
    # (name)

    # First, we will check if this name is already defined, and if it is return the name node generated previously
    identifier = self.node_helper.get_identifier(node)
    if self.variable_context.is_variable(identifier):
        return self.variable_context.get_node(identifier)

    return self.variable_context.add_variable(
        identifier, &#34;Unknown&#34;, [self.node_helper.get_source_ref(node)]
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_print_statement"><code class="name flex">
<span>def <span class="ident">visit_print_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_print_statement(self, node):
    func = self.get_gromet_function_node(&#34;print&#34;)

    arguments = []

    return Call(
        func=func,
        arguments=arguments,
        source_language=None,
        source_language_version=None,
    )</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_use_statement"><code class="name flex">
<span>def <span class="ident">visit_use_statement</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_use_statement(self, node):
    # (use)
    #   (use)
    #   (module_name)

    ## Pull relevent child nodes
    module_name_node = get_first_child_by_type(node, &#34;module_name&#34;)
    module_name = self.node_helper.get_identifier(module_name_node)
    included_items_node = get_first_child_by_type(node, &#34;included_items&#34;)

    import_all = included_items_node is None
    import_alias = None  # TODO: Look into local-name and use-name fields

    # We need to check if this import is a full import of a module, i.e. use module
    # Or a partial import i.e. use module,only: sub1, sub2
    if import_all:
        return ModelImport(
            name=module_name,
            alias=import_alias,
            all=import_all,
            symbol=None,
            source_refs=[self.node_helper.get_source_ref(node)],
        )
    else:
        imports = []
        for symbol in get_non_control_children(included_items_node):
            symbol_identifier = self.node_helper.get_identifier(symbol)
            symbol_source_refs = [self.node_helper.get_source_ref(symbol)]
            imports.append(
                ModelImport(
                    name=module_name,
                    alias=import_alias,
                    all=import_all,
                    symbol=symbol_identifier,
                    source_refs=symbol_source_refs,
                )
            )
        return imports</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_variable_declaration"><code class="name flex">
<span>def <span class="ident">visit_variable_declaration</span></span>(<span>self, node) ‑> List[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for variable declaration. Will return a List of Var and Assignment nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_variable_declaration(self, node) -&gt; List:
    &#34;&#34;&#34;Visitor for variable declaration. Will return a List of Var and Assignment nodes.&#34;&#34;&#34;
    &#34;&#34;&#34;
    # Node structure
    (variable_declaration)
        (intrinsic_type)
        (type_qualifier)
            (qualifier)
            (value)
        (identifier) ...
        (assignment_statement) ...

    (variable_declaration)
        (derived_type)
            (type_name)
    &#34;&#34;&#34;
    # A variable can be declared with an intrinsic_type if its built-in, or a derived_type if it is user defined.
    intrinsic_type_node = get_first_child_by_type(node, &#34;intrinsic_type&#34;)
    derived_type_node = get_first_child_by_type(node, &#34;derived_type&#34;)

    variable_type = &#34;&#34;
    variable_intent = &#34;&#34;

    if intrinsic_type_node:
        type_map = {
            &#34;integer&#34;: &#34;Integer&#34;,
            &#34;real&#34;: &#34;AbstractFloat&#34;,
            &#34;double precision&#34;: &#34;AbstractFloat&#34;,
            &#34;complex&#34;: &#34;Tuple&#34;,  # Complex is a Tuple (rational,irrational),
            &#34;logical&#34;: &#34;Boolean&#34;,
            &#34;character&#34;: &#34;String&#34;,
        }
        # NOTE: Identifiers are case sensitive, so we always need to make sure we are comparing to the lower() version
        variable_type = type_map[
            self.node_helper.get_identifier(intrinsic_type_node).lower()
        ]
    elif derived_type_node:
        variable_type = self.node_helper.get_identifier(
            get_first_child_by_type(derived_type_node, &#34;type_name&#34;, recurse=True),
        )

    # There are multiple type qualifiers that change the way we generate a variable
    # For example, we need to determine if we are creating an array (dimension) or a single variable
    type_qualifiers = get_children_by_types(node, [&#34;type_qualifier&#34;])
    for qualifier in type_qualifiers:
        field = self.node_helper.get_identifier(qualifier.children[0])

        if field == &#34;dimension&#34;:
            variable_type = &#34;List&#34;
        elif field == &#34;intent&#34;:
            variable_intent = self.node_helper.get_identifier(qualifier.children[1])

    # You can declare multiple variables of the same type in a single statement, so we need to create a Var or Assignment node for each instance
    definied_variables = get_children_by_types(
        node,
        [
            &#34;identifier&#34;,  # Variable declaration
            &#34;assignment_statement&#34;,  # Variable assignment
            &#34;call_expression&#34;,  # Dimension without intent
        ],
    )
    vars = []
    for variable in definied_variables:
        if variable.type == &#34;assignment_statement&#34;:
            if variable.children[0].type == &#34;call_expression&#34;:
                vars.append(
                    Assignment(
                        left=self.visit(
                            get_first_child_by_type(
                                variable.children[0], &#34;identifier&#34;
                            )
                        ),
                        right=self.visit(variable.children[2]),
                        source_refs=[self.node_helper.get_source_ref(variable)],
                    )
                )
                vars[-1].left.type = &#34;List&#34;
                self.variable_context.update_type(vars[-1].left.val.name, &#34;List&#34;)
            else:
                # If its a regular assignment, we can update the type normally
                vars.append(self.visit(variable))
                vars[-1].left.type = variable_type
                self.variable_context.update_type(
                    vars[-1].left.val.name, variable_type
                )

        elif variable.type == &#34;identifier&#34;:
            # A basic variable declaration, we visit the identifier and then update the type
            vars.append(self.visit(variable))
            vars[-1].type = variable_type
            self.variable_context.update_type(vars[-1].val.name, variable_type)
        elif variable.type == &#34;call_expression&#34;:
            # Declaring a dimension variable using the x(1:5) format. It will look like a call expression in tree-sitter.
            # We treat it like an identifier by visiting its identifier node. Then the type gets overridden by &#34;dimension&#34;
            vars.append(self.visit(get_first_child_by_type(variable, &#34;identifier&#34;)))
            vars[-1].type = &#34;List&#34;
            self.variable_context.update_type(vars[-1].val.name, &#34;List&#34;)

    # By default, all variables are added to a function&#39;s list of return values
    # If the intent is actually in, then we need to remove them from the list
    if variable_intent == &#34;in&#34;:
        for var in vars:
            self.variable_context.remove_return_value(var.val.name)

    return vars</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis.CAST.fortran" href="index.html">skema.program_analysis.CAST.fortran</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST">TS2CAST</a></code></h4>
<ul class="">
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.generate_cast" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.generate_cast">generate_cast</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.generate_cast_body" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.generate_cast_body">generate_cast_body</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.get_gromet_function_node" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.get_gromet_function_node">get_gromet_function_node</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.run" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.run">run</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit">visit</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_assignment_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_assignment_statement">visit_assignment_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_derived_type" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_derived_type">visit_derived_type</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_derived_type_member_expression" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_derived_type_member_expression">visit_derived_type_member_expression</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_do_loop_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_do_loop_statement">visit_do_loop_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_extent_specifier" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_extent_specifier">visit_extent_specifier</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_fortran_builtin_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_fortran_builtin_statement">visit_fortran_builtin_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_function_call" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_function_call">visit_function_call</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_function_def" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_function_def">visit_function_def</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_identifier" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_identifier">visit_identifier</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_if_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_if_statement">visit_if_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_internal_procedures" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_internal_procedures">visit_internal_procedures</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_keyword_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_keyword_statement">visit_keyword_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_literal" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_literal">visit_literal</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_logical_expression" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_logical_expression">visit_logical_expression</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_math_expression" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_math_expression">visit_math_expression</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_module" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_module">visit_module</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_name" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_name">visit_name</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_print_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_print_statement">visit_print_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_use_statement" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_use_statement">visit_use_statement</a></code></li>
<li><code><a title="skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_variable_declaration" href="#skema.program_analysis.CAST.fortran.ts2cast.TS2CAST.visit_variable_declaration">visit_variable_declaration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>