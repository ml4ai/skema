<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.program_analysis.script_functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.program_analysis.script_functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import ast
import dill
import os.path
import json

# import astpp
from skema.gromet import GROMET_VERSION
from skema.gromet.fn import (
    GrometFNModuleCollection,
)

from skema.utils.fold import dictionary_to_gromet_json, del_nulls
from skema.program_analysis.PyAST2CAST import py_ast_to_cast
from skema.program_analysis.CAST2FN import cast
from skema.program_analysis.CAST2FN.model.cast import SourceRef
from skema.program_analysis.CAST2FN.cast import CAST
from skema.program_analysis.CAST2FN.visitors.cast_to_agraph_visitor import (
    CASTToAGraphVisitor,
)
from skema.program_analysis.CAST2FN.ann_cast.cast_to_annotated_cast import (
    CastToAnnotatedCastVisitor,
)
from skema.program_analysis.CAST2FN.ann_cast.id_collapse_pass import (
    IdCollapsePass,
)
from skema.program_analysis.CAST2FN.ann_cast.container_scope_pass import (
    ContainerScopePass,
)
from skema.program_analysis.CAST2FN.ann_cast.variable_version_pass import (
    VariableVersionPass,
)
from skema.program_analysis.CAST2FN.ann_cast.grfn_var_creation_pass import (
    GrfnVarCreationPass,
)
from skema.program_analysis.CAST2FN.ann_cast.grfn_assignment_pass import (
    GrfnAssignmentPass,
)
from skema.program_analysis.CAST2FN.ann_cast.lambda_expression_pass import (
    LambdaExpressionPass,
)
from skema.program_analysis.CAST2FN.ann_cast.to_grfn_pass import ToGrfnPass
from skema.program_analysis.CAST2FN.ann_cast.to_gromet_pass import (
    ToGrometPass,
)


def process_file_system(system_name, path, files, write_to_file=False):
    root_dir = path.strip()
    file_list = open(files, &#34;r&#34;).readlines()

    module_collection = GrometFNModuleCollection(
        schema_version=GROMET_VERSION,
        name=system_name,
        modules=[],
        module_index=[],
        executables=[],
    )

    for f in file_list:
        full_file = os.path.join(os.path.normpath(root_dir), f.rstrip(&#34;\n&#34;))

        # Open the file
        # TODO: Do we want to open the CAST or the Python source?
        #  If we open the Python source then we need to generate its CAST and then generate its GroMEt after
        #  I&#39;m thinking for now we open the CAST, and generate GroMEt
        #  As a next-step we can incorporate the Python -&gt; CAST step
        print(full_file.rstrip())

        try:
            cast = python_to_cast(full_file, cast_obj=True)
            generated_gromet = ann_cast_pipeline(
                cast, gromet=True, to_file=False, from_obj=True
            )

            # Then, after we generate the GroMEt we store it in the &#39;modules&#39; field
            # and store its path in the &#39;module_index&#39; field
            module_collection.modules.append(generated_gromet)

            # DONE: Change this so that it&#39;s the dotted path from the root
            # i.e. like model.view.sir&#34; like it shows up in Python
            source_directory = os.path.basename(
                os.path.normpath(root_dir)
            )  # We just need the last directory of the path, not the complete path
            os_module_path = os.path.join(source_directory, f)
            python_module_path = os_module_path.replace(&#34;/&#34;, &#34;.&#34;).replace(
                &#34;.py&#34;, &#34;&#34;
            )
            module_collection.module_index.append(python_module_path)

            # Done: Determine how we know a gromet goes in the &#39;executable&#39; field
            # We do this by finding all user_defined top level functions in the Gromet
            # and check if the name &#39;main&#39; is among them
            function_networks = [
                fn.value
                for fn in generated_gromet.attributes
                if fn.type == &#34;FN&#34;
            ]
            defined_functions = [
                fn.b[0].name
                for fn in function_networks
                if fn.b[0].function_type == &#34;FUNCTION&#34;
            ]
            if &#34;main&#34; in defined_functions:
                module_collection.executables.append(python_module_path)

        except ImportError:
            print(&#34;FAILURE&#34;)

    # After we go through the whole system, we can then write out the module_collection
    if write_to_file:
        with open(f&#34;{system_name}--Gromet-FN-auto.json&#34;, &#34;w&#34;) as f:
            gromet_collection_dict = module_collection.to_dict()
            f.write(
                dictionary_to_gromet_json(del_nulls(gromet_collection_dict))
            )

    return module_collection


def python_to_cast(
    pyfile_path,
    agraph=False,
    astprint=False,
    std_out=False,
    rawjson=False,
    legacy=False,
    cast_obj=False,
):
    # Open Python file as a giant string
    file_handle = open(pyfile_path)
    file_contents = file_handle.read()
    file_handle.close()
    file_name = pyfile_path.split(&#34;/&#34;)[-1]

    # Count the number of lines in the file
    file_handle = open(pyfile_path)
    file_list = file_handle.readlines()
    line_count = 0
    for l in file_list:
        line_count += 1
    file_handle.close()

    # Create a PyASTToCAST Object
    if legacy:
        convert = py_ast_to_cast.PyASTToCAST(file_name, legacy=True)
    else:
        convert = py_ast_to_cast.PyASTToCAST(file_name)

    # Additional option to allow us to view the PyAST
    # using the astpp module
    if astprint:
        # astpp.parseprint(file_contents)
        print(&#34;AST Printing Currently Disabled&#34;)
        pass

    # &#39;Root&#39; the current working directory so that it&#39;s where the
    # Source file we&#39;re generating CAST for is (for Import statements)
    old_path = os.getcwd()
    try:
        idx = pyfile_path.rfind(&#34;/&#34;)

        if idx &gt; -1:
            curr_path = pyfile_path[0:idx]
            os.chdir(curr_path)
        else:
            curr_path = &#34;./&#34; + pyfile_path

        # os.chdir(curr_path)

        # Parse the python program&#39;s AST and create the CAST
        contents = ast.parse(file_contents)
        C = convert.visit(contents, {}, {})
        C.source_refs = [SourceRef(file_name, None, None, 1, line_count)]
    finally:
        os.chdir(old_path)

    out_cast = cast.CAST([C], &#34;python&#34;)

    if agraph:
        import skema.utils.misc.test_pygraphviz

        test_pygraphviz(
            &#34;For the agraph generation in the python_to_cast &#34;
            &#34;function to work, pygraphviz must be installed.&#34;
        )
        V = CASTToAGraphVisitor(out_cast)
        last_slash_idx = file_name.rfind(&#34;/&#34;)
        file_ending_idx = file_name.rfind(&#34;.&#34;)
        pdf_file_name = (
            f&#34;{file_name[last_slash_idx + 1 : file_ending_idx]}.pdf&#34;
        )
        V.to_pdf(pdf_file_name)

    # Then, print CAST as JSON
    if cast_obj:
        return out_cast
    else:
        if rawjson:
            print(
                json.dumps(
                    out_cast.to_json_object(), sort_keys=True, indent=None
                )
            )
        else:
            if std_out:
                print(out_cast.to_json_str())
            else:
                out_name = file_name.split(&#34;.&#34;)[0]
                print(&#34;Writing CAST to &#34; + out_name + &#34;--CAST.json&#34;)
                out_handle = open(out_name + &#34;--CAST.json&#34;, &#34;w&#34;)
                out_handle.write(out_cast.to_json_str())


def ann_cast_pipeline(
    cast_instance,
    to_file=True,
    gromet=False,
    grfn_2_2=False,
    a_graph=False,
    from_obj=False,
    indent_level=0,
):
    &#34;&#34;&#34;cast_to_annotated.py

    This function reads a JSON file that contains the CAST representation
    of a program, and transforms it to annotated CAST. It then calls a
    series of passes that each augment the information in the annotatd CAST nodes
    in preparation for the GrFN generation.

    One command-line argument is expected, namely the name of the JSON file that
    contains the CAST data.
    TODO: Update this docstring as the program has been tweaked so that this is a function instead of
    the program
    &#34;&#34;&#34;

    if from_obj:
        f_name = &#34;&#34;
        cast = cast_instance
    else:
        f_name = cast_instance
        f_name = f_name.split(&#34;/&#34;)[-1]
        file_contents = open(f_name, &#34;r&#34;).read()

        cast_json = CAST([], &#34;python&#34;)
        cast = cast_json.from_json_str(file_contents)

    visitor = CastToAnnotatedCastVisitor(cast)
    # The Annotated Cast is an attribute of the PipelineState object
    pipeline_state = visitor.generate_annotated_cast(grfn_2_2)

    # TODO: make filename creation more resilient

    print(&#34;Calling IdCollapsePass------------------------&#34;)
    IdCollapsePass(pipeline_state)

    print(&#34;\nCalling ContainerScopePass-------------------&#34;)
    ContainerScopePass(pipeline_state)

    print(&#34;\nCalling VariableVersionPass-------------------&#34;)
    VariableVersionPass(pipeline_state)

    # NOTE: CASTToAGraphVisitor uses misc.uuid, so placing it here means
    # that the generated GrFN uuids will not be consistent with GrFN uuids
    # created during test runtime. So, do not use these GrFN jsons as expected
    # json for testing
    f_name = f_name.replace(&#34;--CAST.json&#34;, &#34;&#34;)
    if a_graph:
        agraph = CASTToAGraphVisitor(pipeline_state)
        pdf_file_name = f&#34;{f_name}-AnnCast.pdf&#34;
        agraph.to_pdf(pdf_file_name)

    print(&#34;\nCalling GrfnVarCreationPass-------------------&#34;)
    GrfnVarCreationPass(pipeline_state)

    print(&#34;\nCalling GrfnAssignmentPass-------------------&#34;)
    GrfnAssignmentPass(pipeline_state)

    print(&#34;\nCalling LambdaExpressionPass-------------------&#34;)
    LambdaExpressionPass(pipeline_state)

    if gromet:
        print(&#34;\nCalling ToGrometPass-----------------------&#34;)
        ToGrometPass(pipeline_state)

        if to_file:
            with open(f&#34;{f_name}--Gromet-FN-auto.json&#34;, &#34;w&#34;) as f:
                gromet_collection_dict = (
                    pipeline_state.gromet_collection.to_dict()
                )
                f.write(
                    dictionary_to_gromet_json(
                        del_nulls(gromet_collection_dict), level=indent_level
                    )
                )
        else:
            return pipeline_state.gromet_collection
    else:
        print(&#34;\nCalling ToGrfnPass-------------------&#34;)
        ToGrfnPass(pipeline_state)
        grfn = pipeline_state.get_grfn()
        grfn.to_json_file(f&#34;{f_name}--AC-GrFN.json&#34;)

        grfn_agraph = grfn.to_AGraph()
        grfn_agraph.draw(f&#34;{f_name}--AC-GrFN.pdf&#34;, prog=&#34;dot&#34;)

        print(&#34;\nGenerating pickled AnnCast nodes-----------------&#34;)
        pickled_file_name = f&#34;{f_name}--AnnCast.pickled&#34;
        with open(pickled_file_name, &#34;wb&#34;) as pkfile:
            dill.dump(pipeline_state, pkfile)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="skema.program_analysis.script_functions.ann_cast_pipeline"><code class="name flex">
<span>def <span class="ident">ann_cast_pipeline</span></span>(<span>cast_instance, to_file=True, gromet=False, grfn_2_2=False, a_graph=False, from_obj=False, indent_level=0)</span>
</code></dt>
<dd>
<div class="desc"><p>cast_to_annotated.py</p>
<p>This function reads a JSON file that contains the CAST representation
of a program, and transforms it to annotated CAST. It then calls a
series of passes that each augment the information in the annotatd CAST nodes
in preparation for the GrFN generation.</p>
<p>One command-line argument is expected, namely the name of the JSON file that
contains the CAST data.
TODO: Update this docstring as the program has been tweaked so that this is a function instead of
the program</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ann_cast_pipeline(
    cast_instance,
    to_file=True,
    gromet=False,
    grfn_2_2=False,
    a_graph=False,
    from_obj=False,
    indent_level=0,
):
    &#34;&#34;&#34;cast_to_annotated.py

    This function reads a JSON file that contains the CAST representation
    of a program, and transforms it to annotated CAST. It then calls a
    series of passes that each augment the information in the annotatd CAST nodes
    in preparation for the GrFN generation.

    One command-line argument is expected, namely the name of the JSON file that
    contains the CAST data.
    TODO: Update this docstring as the program has been tweaked so that this is a function instead of
    the program
    &#34;&#34;&#34;

    if from_obj:
        f_name = &#34;&#34;
        cast = cast_instance
    else:
        f_name = cast_instance
        f_name = f_name.split(&#34;/&#34;)[-1]
        file_contents = open(f_name, &#34;r&#34;).read()

        cast_json = CAST([], &#34;python&#34;)
        cast = cast_json.from_json_str(file_contents)

    visitor = CastToAnnotatedCastVisitor(cast)
    # The Annotated Cast is an attribute of the PipelineState object
    pipeline_state = visitor.generate_annotated_cast(grfn_2_2)

    # TODO: make filename creation more resilient

    print(&#34;Calling IdCollapsePass------------------------&#34;)
    IdCollapsePass(pipeline_state)

    print(&#34;\nCalling ContainerScopePass-------------------&#34;)
    ContainerScopePass(pipeline_state)

    print(&#34;\nCalling VariableVersionPass-------------------&#34;)
    VariableVersionPass(pipeline_state)

    # NOTE: CASTToAGraphVisitor uses misc.uuid, so placing it here means
    # that the generated GrFN uuids will not be consistent with GrFN uuids
    # created during test runtime. So, do not use these GrFN jsons as expected
    # json for testing
    f_name = f_name.replace(&#34;--CAST.json&#34;, &#34;&#34;)
    if a_graph:
        agraph = CASTToAGraphVisitor(pipeline_state)
        pdf_file_name = f&#34;{f_name}-AnnCast.pdf&#34;
        agraph.to_pdf(pdf_file_name)

    print(&#34;\nCalling GrfnVarCreationPass-------------------&#34;)
    GrfnVarCreationPass(pipeline_state)

    print(&#34;\nCalling GrfnAssignmentPass-------------------&#34;)
    GrfnAssignmentPass(pipeline_state)

    print(&#34;\nCalling LambdaExpressionPass-------------------&#34;)
    LambdaExpressionPass(pipeline_state)

    if gromet:
        print(&#34;\nCalling ToGrometPass-----------------------&#34;)
        ToGrometPass(pipeline_state)

        if to_file:
            with open(f&#34;{f_name}--Gromet-FN-auto.json&#34;, &#34;w&#34;) as f:
                gromet_collection_dict = (
                    pipeline_state.gromet_collection.to_dict()
                )
                f.write(
                    dictionary_to_gromet_json(
                        del_nulls(gromet_collection_dict), level=indent_level
                    )
                )
        else:
            return pipeline_state.gromet_collection
    else:
        print(&#34;\nCalling ToGrfnPass-------------------&#34;)
        ToGrfnPass(pipeline_state)
        grfn = pipeline_state.get_grfn()
        grfn.to_json_file(f&#34;{f_name}--AC-GrFN.json&#34;)

        grfn_agraph = grfn.to_AGraph()
        grfn_agraph.draw(f&#34;{f_name}--AC-GrFN.pdf&#34;, prog=&#34;dot&#34;)

        print(&#34;\nGenerating pickled AnnCast nodes-----------------&#34;)
        pickled_file_name = f&#34;{f_name}--AnnCast.pickled&#34;
        with open(pickled_file_name, &#34;wb&#34;) as pkfile:
            dill.dump(pipeline_state, pkfile)</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.script_functions.process_file_system"><code class="name flex">
<span>def <span class="ident">process_file_system</span></span>(<span>system_name, path, files, write_to_file=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_file_system(system_name, path, files, write_to_file=False):
    root_dir = path.strip()
    file_list = open(files, &#34;r&#34;).readlines()

    module_collection = GrometFNModuleCollection(
        schema_version=GROMET_VERSION,
        name=system_name,
        modules=[],
        module_index=[],
        executables=[],
    )

    for f in file_list:
        full_file = os.path.join(os.path.normpath(root_dir), f.rstrip(&#34;\n&#34;))

        # Open the file
        # TODO: Do we want to open the CAST or the Python source?
        #  If we open the Python source then we need to generate its CAST and then generate its GroMEt after
        #  I&#39;m thinking for now we open the CAST, and generate GroMEt
        #  As a next-step we can incorporate the Python -&gt; CAST step
        print(full_file.rstrip())

        try:
            cast = python_to_cast(full_file, cast_obj=True)
            generated_gromet = ann_cast_pipeline(
                cast, gromet=True, to_file=False, from_obj=True
            )

            # Then, after we generate the GroMEt we store it in the &#39;modules&#39; field
            # and store its path in the &#39;module_index&#39; field
            module_collection.modules.append(generated_gromet)

            # DONE: Change this so that it&#39;s the dotted path from the root
            # i.e. like model.view.sir&#34; like it shows up in Python
            source_directory = os.path.basename(
                os.path.normpath(root_dir)
            )  # We just need the last directory of the path, not the complete path
            os_module_path = os.path.join(source_directory, f)
            python_module_path = os_module_path.replace(&#34;/&#34;, &#34;.&#34;).replace(
                &#34;.py&#34;, &#34;&#34;
            )
            module_collection.module_index.append(python_module_path)

            # Done: Determine how we know a gromet goes in the &#39;executable&#39; field
            # We do this by finding all user_defined top level functions in the Gromet
            # and check if the name &#39;main&#39; is among them
            function_networks = [
                fn.value
                for fn in generated_gromet.attributes
                if fn.type == &#34;FN&#34;
            ]
            defined_functions = [
                fn.b[0].name
                for fn in function_networks
                if fn.b[0].function_type == &#34;FUNCTION&#34;
            ]
            if &#34;main&#34; in defined_functions:
                module_collection.executables.append(python_module_path)

        except ImportError:
            print(&#34;FAILURE&#34;)

    # After we go through the whole system, we can then write out the module_collection
    if write_to_file:
        with open(f&#34;{system_name}--Gromet-FN-auto.json&#34;, &#34;w&#34;) as f:
            gromet_collection_dict = module_collection.to_dict()
            f.write(
                dictionary_to_gromet_json(del_nulls(gromet_collection_dict))
            )

    return module_collection</code></pre>
</details>
</dd>
<dt id="skema.program_analysis.script_functions.python_to_cast"><code class="name flex">
<span>def <span class="ident">python_to_cast</span></span>(<span>pyfile_path, agraph=False, astprint=False, std_out=False, rawjson=False, legacy=False, cast_obj=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def python_to_cast(
    pyfile_path,
    agraph=False,
    astprint=False,
    std_out=False,
    rawjson=False,
    legacy=False,
    cast_obj=False,
):
    # Open Python file as a giant string
    file_handle = open(pyfile_path)
    file_contents = file_handle.read()
    file_handle.close()
    file_name = pyfile_path.split(&#34;/&#34;)[-1]

    # Count the number of lines in the file
    file_handle = open(pyfile_path)
    file_list = file_handle.readlines()
    line_count = 0
    for l in file_list:
        line_count += 1
    file_handle.close()

    # Create a PyASTToCAST Object
    if legacy:
        convert = py_ast_to_cast.PyASTToCAST(file_name, legacy=True)
    else:
        convert = py_ast_to_cast.PyASTToCAST(file_name)

    # Additional option to allow us to view the PyAST
    # using the astpp module
    if astprint:
        # astpp.parseprint(file_contents)
        print(&#34;AST Printing Currently Disabled&#34;)
        pass

    # &#39;Root&#39; the current working directory so that it&#39;s where the
    # Source file we&#39;re generating CAST for is (for Import statements)
    old_path = os.getcwd()
    try:
        idx = pyfile_path.rfind(&#34;/&#34;)

        if idx &gt; -1:
            curr_path = pyfile_path[0:idx]
            os.chdir(curr_path)
        else:
            curr_path = &#34;./&#34; + pyfile_path

        # os.chdir(curr_path)

        # Parse the python program&#39;s AST and create the CAST
        contents = ast.parse(file_contents)
        C = convert.visit(contents, {}, {})
        C.source_refs = [SourceRef(file_name, None, None, 1, line_count)]
    finally:
        os.chdir(old_path)

    out_cast = cast.CAST([C], &#34;python&#34;)

    if agraph:
        import skema.utils.misc.test_pygraphviz

        test_pygraphviz(
            &#34;For the agraph generation in the python_to_cast &#34;
            &#34;function to work, pygraphviz must be installed.&#34;
        )
        V = CASTToAGraphVisitor(out_cast)
        last_slash_idx = file_name.rfind(&#34;/&#34;)
        file_ending_idx = file_name.rfind(&#34;.&#34;)
        pdf_file_name = (
            f&#34;{file_name[last_slash_idx + 1 : file_ending_idx]}.pdf&#34;
        )
        V.to_pdf(pdf_file_name)

    # Then, print CAST as JSON
    if cast_obj:
        return out_cast
    else:
        if rawjson:
            print(
                json.dumps(
                    out_cast.to_json_object(), sort_keys=True, indent=None
                )
            )
        else:
            if std_out:
                print(out_cast.to_json_str())
            else:
                out_name = file_name.split(&#34;.&#34;)[0]
                print(&#34;Writing CAST to &#34; + out_name + &#34;--CAST.json&#34;)
                out_handle = open(out_name + &#34;--CAST.json&#34;, &#34;w&#34;)
                out_handle.write(out_cast.to_json_str())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.program_analysis" href="index.html">skema.program_analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="skema.program_analysis.script_functions.ann_cast_pipeline" href="#skema.program_analysis.script_functions.ann_cast_pipeline">ann_cast_pipeline</a></code></li>
<li><code><a title="skema.program_analysis.script_functions.process_file_system" href="#skema.program_analysis.script_functions.process_file_system">process_file_system</a></code></li>
<li><code><a title="skema.program_analysis.script_functions.python_to_cast" href="#skema.program_analysis.script_functions.python_to_cast">python_to_cast</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>