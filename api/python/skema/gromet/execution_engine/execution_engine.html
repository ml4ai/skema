<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.gromet.execution_engine.execution_engine API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.gromet.execution_engine.execution_engine</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import yaml
import argparse
import asyncio
import subprocess

from ast import literal_eval
from pathlib import Path
from typing import Any, List, Dict

import torch
from gqlalchemy import Memgraph

from skema.program_analysis.CAST.pythonAST.builtin_map import retrieve_operator
from skema.program_analysis.single_file_ingester import process_file
from skema.gromet.execution_engine.execute import execute_primitive

# TODO: Broken import: from skema.rest.workflows import code_snippets_to_pn_amr
from skema.skema_py.server import System
from skema.gromet.execution_engine.query_runner import QueryRunner
from skema.gromet.execution_engine.symbol_table import SymbolTable
from skema.utils.fold import dictionary_to_gromet_json, del_nulls

SKEMA_BIN = Path(__file__).resolve().parents[2] / &#34;skema-rs&#34; / &#34;skema&#34; / &#34;src&#34; / &#34;bin&#34;


class Execute(torch.autograd.Function):
    @staticmethod
    def forward(ctx, primitive: str, inputs: List[torch.Tensor]):
        return execute_primitive(primitive, inputs)

    @staticmethod
    def backward(ctx, grad_output):
        pass


execute = Execute.apply


class ExecutionEngine:
    def __init__(self, host: str, port: str, source_path: str):
        self.query_runner = QueryRunner(host, port)
        self.symbol_table = SymbolTable()
        self.source_path = source_path

        # Filename is source path filename minus the extension
        self.filename = Path(source_path).stem

        # Upload source to Memgraph instance
        self.upload_source()

    def upload_source(self):
        &#34;&#34;&#34;Ingest source file and upload Gromet to Memgraph&#34;&#34;&#34;

        # Currently, the Gromet ingester writes the output JSON to the directory where the script is run from.
        # Instead, we want to store it alongside the source so that we can upload it to Memgraph.
        gromet_collection = process_file(self.source_path)
        gromet_name = f&#34;{self.filename}--Gromet-FN-auto.json&#34;
        gromet_path = Path(self.source_path).parent / gromet_name
        gromet_path.write_text(
            dictionary_to_gromet_json(del_nulls(gromet_collection.to_dict()))
        )

        # The Memgraph database state should be reset before running any queries.
        # Unexpected nodes/edges can cause issues with execution.
        self.query_runner.run_query(&#34;reset_state&#34;)

        # Upload to memgraph
        subprocess.run(
            [&#34;cargo&#34;, &#34;run&#34;, &#34;--bin&#34;, &#34;gromet2graphdb&#34;, str(gromet_path)], cwd=SKEMA_BIN
        )

    def execute(
        self,
        module: bool = False,
        main: bool = False,
        function: bool = False,
        function_name: str = None,
    ):
        &#34;&#34;&#34;Run the execution engine at specified scope&#34;&#34;&#34;
        if module:
            module_list = self.query_runner.run_query(
                &#34;module&#34;, n_or_m=&#34;n&#34;, filename=self.filename
            )
            self.visit(module_list[0])

    def parameter_extraction(self):
        &#34;&#34;&#34;Run the execution engine and extract initial values for each parameter&#34;&#34;&#34;

        # Execute the source at the module level
        self.execute(module=True)

        # Extract the initial values from the symbol map
        return self.symbol_table.get_initial_values()

    def visit(self, node):
        node_types = node._labels
        if &#34;Module&#34; in node_types:
            self.visit_module(node)
        if &#34;Expression&#34; in node_types:
            self.visit_expression(node)
        if &#34;Function&#34; in node_types:
            self.visit_function(node)
        if &#34;Opo&#34; in node_types:
            return self.visit_opo(node)
        if &#34;Opi&#34; in node_types:
            return self.visit_opi(node)
        if &#34;Literal&#34; in node_types:
            return self.visit_literal(node)
        if &#34;Primitive&#34; in node_types:
            return self.visit_primitive(node)

    def visit_module(self, node):
        &#34;&#34;&#34;Visitor for top-level module&#34;&#34;&#34;
        node_id = str(node._id)

        expressions = self.query_runner.run_query(&#34;ordered_expressions&#34;, id=node_id)
        for expression in expressions:
            self.visit(expression)

    def visit_expression(self, node):
        node_id = node._id

        # Only the left hand side is directly connected to the expression. So, we access the right hand side from the left hand side node
        # (Expression) -&gt; (Opo) -&gt; (Primitive | Literal | Opo)
        left_hand_side = self.query_runner.run_query(&#34;assignment_left_hand&#34;, id=node_id)
        right_hand_side = self.query_runner.run_query(
            &#34;assignment_right_hand&#34;, id=left_hand_side[0]._id
        )

        # The lefthand side represents the Opo of the variable we are assigning to
        # TODO: What if we have multiple assignment x,y = 1,2
        # TODO: Does an expression always correspond to an assingment?
        symbol = self.visit(left_hand_side[0])

        # The right hand side can be either a LiteralValue, an Expression, or a Primitive
        # A Literal
        index = {&#34;Primitive&#34;: 1, &#34;Expression&#34;: 1, &#34;Literal&#34;: 2}
        right_hand_side = sorted(
            right_hand_side, key=lambda node: index[list(node._labels)[0]]
        )
        value = self.visit(right_hand_side[0])
        if not self.symbol_table.get_symbol(symbol):
            self.symbol_table.add_symbol(symbol, value, None)
        else:
            self.symbol_table.update_symbol(symbol, value, None)

    def visit_function(self, node):
        &#34;&#34;&#34;Visitor for :Opi node type&#34;&#34;&#34;
        # TODO: Add support for function calls/definitions
        pass

    def visit_opo(self, node):
        &#34;Visitor for :Opo node type&#34;
        return node.name

    def visit_opi(self, node):
        &#34;&#34;&#34;Visitor for :Opi node type&#34;&#34;&#34;
        node_id = node._id

        # If un-named, we need to get the name from the attached Opo
        if node.name == &#34;un-named&#34;:
            return self.visit(
                self.query_runner.run_query(&#34;assignment_left_hand&#34;, id=node_id)[0]
            )

        return node.name

    def visit_literal(self, node):
        def create_dummy_node(value: Dict):
            &#34;&#34;&#34;Create a dummy gqlalchemy node so that we can pass a LiteralValue to a visitor.&#34;&#34;&#34;

            class DummyNode:
                pass

            node = DummyNode()
            node._id = -1
            node._labels = [&#34;Literal&#34;]
            node.value = value

            # TODO: Update LiteralValue representation for List types
            node.value[&#34;value&#34;] = str(node.value[&#34;value&#34;])

            return node

        # TODO: Update LiteralValue to remove wrapping &#34;&#34; characters
        value = node.value[&#34;value&#34;].strip(&#39;&#34;&#39;)
        value_type = node.value[&#34;value_type&#34;]

        if value_type == &#34;Integer&#34;:
            return torch.tensor(int(value), dtype=torch.int)
        elif value_type == &#34;AbstractFloat&#34;:
            return torch.tensor(float(value), dtype=torch.float)
        elif value_type == &#34;Complex&#34;:
            print(
                &#34;WARNING: Execution for type Complex not support and will be skipped.&#34;
            )
        elif value_type == &#34;Boolean&#34;:
            return torch.tensor(value == &#34;True&#34;, dtype=torch.bool)
        elif value_type == &#34;List&#34;:
            if isinstance(value, str):
                return None
            list = literal_eval(value)
            return [self.visit(create_dummy_node(element)) for element in list]
        elif value_type == &#34;Map&#34;:
            print(&#34;WARNING: Execution for type Map not support and will be skipped.&#34;)
        elif value_type == &#34;None&#34;:
            return None

    def visit_primitive(self, node):
        &#34;&#34;&#34;Visitor for :Primitive node type&#34;&#34;&#34;
        node_id = node._id

        # Some inputs may be symbol names, so we need to access the current value from the symbol map
        inputs = [
            self.visit(input)
            for input in self.query_runner.run_query(&#34;primitive_operands&#34;, id=node_id)
        ]
        inputs = [
            self.symbol_table.get_symbol(input)[&#34;current_value&#34;]
            if isinstance(input, str)
            else input
            for input in inputs
        ]

        primative = retrieve_operator(node.name)
        return execute(primative, inputs)


if __name__ == &#34;__main__&#34;:
    parser = argparse.ArgumentParser(description=&#34;Parameter Extraction Script&#34;)
    parser.add_argument(&#34;source_path&#34;, type=str, help=&#34;File path to source to execute&#34;)
    parser.add_argument(
        &#34;--host&#34;,
        default=&#34;localhost&#34;,
        type=str,
        help=&#34;Host serving the memgraph database&#34;,
    )
    parser.add_argument(
        &#34;--port&#34;, default=7687, type=int, help=&#34;Port serving the megraph database&#34;
    )
    args = parser.parse_args()

    engine = ExecutionEngine(args.host, args.port, args.source_path)
    print(engine.parameter_extraction())

    &#34;&#34;&#34; TODO: New arguments to add with function execution support
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(&#34;--main&#34;, action=&#34;store_true&#34;, help=&#34;Extract parameters from the main module&#34;)
    group.add_argument(&#34;--function&#34;, type=str, metavar=&#34;function_name&#34;, help=&#34;Extract parameters from a specific function&#34;)
    &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.gromet.execution_engine.execution_engine.Execute"><code class="flex name class">
<span>class <span class="ident">Execute</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class to create custom <code>autograd.Function</code></p>
<p>To create a custom <code>autograd.Function</code>, subclass this class and implement
the :meth:<code>forward</code> and :meth:<code>backward</code> static methods. Then, to use your custom
op in the forward pass, call the class method <code>apply</code>. Do not call
:meth:<code>forward</code> directly.</p>
<p>To ensure correctness and best performance, make sure you are calling the
correct methods on <code>ctx</code> and validating your backward function using
:func:<code>torch.autograd.gradcheck</code>.</p>
<p>See :ref:<code>extending-autograd</code> for more details on how to use this class.</p>
<p>Examples::</p>
<pre><code>&gt;&gt;&gt; # xdoctest: +REQUIRES(env:TORCH_DOCTEST_AUTOGRAD)
&gt;&gt;&gt; class Exp(Function):
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def forward(ctx, i):
&gt;&gt;&gt;         result = i.exp()
&gt;&gt;&gt;         ctx.save_for_backward(result)
&gt;&gt;&gt;         return result
&gt;&gt;&gt;
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def backward(ctx, grad_output):
&gt;&gt;&gt;         result, = ctx.saved_tensors
&gt;&gt;&gt;         return grad_output * result
&gt;&gt;&gt;
&gt;&gt;&gt; # Use it by calling the apply method:
&gt;&gt;&gt; # xdoctest: +SKIP
&gt;&gt;&gt; output = Exp.apply(input)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Execute(torch.autograd.Function):
    @staticmethod
    def forward(ctx, primitive: str, inputs: List[torch.Tensor]):
        return execute_primitive(primitive, inputs)

    @staticmethod
    def backward(ctx, grad_output):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.autograd.function.Function</li>
<li>torch.autograd.function._SingleLevelFunction</li>
<li>torch._C._FunctionBase</li>
<li>torch.autograd.function.FunctionCtx</li>
<li>torch.autograd.function._HookMixin</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="skema.gromet.execution_engine.execution_engine.Execute.backward"><code class="name flex">
<span>def <span class="ident">backward</span></span>(<span>ctx, grad_output)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a formula for differentiating the operation with backward mode
automatic differentiation (alias to the vjp function).</p>
<p>This function is to be overridden by all subclasses.</p>
<p>It must accept a context :attr:<code>ctx</code> as the first argument, followed by
as many outputs as the :func:<code>forward</code> returned (None will be passed in
for non tensor outputs of the forward function),
and it should return as many tensors, as there were inputs to
:func:<code>forward</code>. Each argument is the gradient w.r.t the given output,
and each returned value should be the gradient w.r.t. the
corresponding input. If an input is not a Tensor or is a Tensor not
requiring grads, you can just pass None as a gradient for that input.</p>
<p>The context can be used to retrieve tensors saved during the forward
pass. It also has an attribute :attr:<code>ctx.needs_input_grad</code> as a tuple
of booleans representing whether each input needs gradient. E.g.,
:func:<code>backward</code> will have <code>ctx.needs_input_grad[0] = True</code> if the
first input to :func:<code>forward</code> needs gradient computated w.r.t. the
output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def backward(ctx, grad_output):
    pass</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.Execute.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>ctx, primitive: str, inputs: List[torch.Tensor])</span>
</code></dt>
<dd>
<div class="desc"><p>This function is to be overridden by all subclasses. There are two ways
to define forward:</p>
<p>Usage 1 (Combined forward and ctx)::</p>
<pre><code>@staticmethod
def forward(ctx: Any, *args: Any, **kwargs: Any) -&gt; Any:
    pass
</code></pre>
<ul>
<li>It must accept a context ctx as the first argument, followed by any
number of arguments (tensors or other types).</li>
<li>See :ref:<code>combining-forward-context</code> for more details</li>
</ul>
<p>Usage 2 (Separate forward and ctx)::</p>
<pre><code>@staticmethod
def forward(*args: Any, **kwargs: Any) -&gt; Any:
    pass

@staticmethod
def setup_context(ctx: Any, inputs: Tuple[Any, ...], output: Any) -&gt; None:
    pass
</code></pre>
<ul>
<li>The forward no longer accepts a ctx argument.</li>
<li>Instead, you must also override the :meth:<code>torch.autograd.Function.setup_context</code>
staticmethod to handle setting up the <code>ctx</code> object.
<code>output</code> is the output of the forward, <code>inputs</code> are a Tuple of inputs
to the forward.</li>
<li>See :ref:<code>extending-autograd</code> for more details</li>
</ul>
<p>The context can be used to store arbitrary data that can be then
retrieved during the backward pass. Tensors should not be stored
directly on <code>ctx</code> (though this is not currently enforced for
backward compatibility). Instead, tensors should be saved either with
:func:<code>ctx.save_for_backward</code> if they are intended to be used in
<code>backward</code> (equivalently, <code>vjp</code>) or :func:<code>ctx.save_for_forward</code>
if they are intended to be used for in <code>jvp</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def forward(ctx, primitive: str, inputs: List[torch.Tensor]):
    return execute_primitive(primitive, inputs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine"><code class="flex name class">
<span>class <span class="ident">ExecutionEngine</span></span>
<span>(</span><span>host: str, port: str, source_path: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExecutionEngine:
    def __init__(self, host: str, port: str, source_path: str):
        self.query_runner = QueryRunner(host, port)
        self.symbol_table = SymbolTable()
        self.source_path = source_path

        # Filename is source path filename minus the extension
        self.filename = Path(source_path).stem

        # Upload source to Memgraph instance
        self.upload_source()

    def upload_source(self):
        &#34;&#34;&#34;Ingest source file and upload Gromet to Memgraph&#34;&#34;&#34;

        # Currently, the Gromet ingester writes the output JSON to the directory where the script is run from.
        # Instead, we want to store it alongside the source so that we can upload it to Memgraph.
        gromet_collection = process_file(self.source_path)
        gromet_name = f&#34;{self.filename}--Gromet-FN-auto.json&#34;
        gromet_path = Path(self.source_path).parent / gromet_name
        gromet_path.write_text(
            dictionary_to_gromet_json(del_nulls(gromet_collection.to_dict()))
        )

        # The Memgraph database state should be reset before running any queries.
        # Unexpected nodes/edges can cause issues with execution.
        self.query_runner.run_query(&#34;reset_state&#34;)

        # Upload to memgraph
        subprocess.run(
            [&#34;cargo&#34;, &#34;run&#34;, &#34;--bin&#34;, &#34;gromet2graphdb&#34;, str(gromet_path)], cwd=SKEMA_BIN
        )

    def execute(
        self,
        module: bool = False,
        main: bool = False,
        function: bool = False,
        function_name: str = None,
    ):
        &#34;&#34;&#34;Run the execution engine at specified scope&#34;&#34;&#34;
        if module:
            module_list = self.query_runner.run_query(
                &#34;module&#34;, n_or_m=&#34;n&#34;, filename=self.filename
            )
            self.visit(module_list[0])

    def parameter_extraction(self):
        &#34;&#34;&#34;Run the execution engine and extract initial values for each parameter&#34;&#34;&#34;

        # Execute the source at the module level
        self.execute(module=True)

        # Extract the initial values from the symbol map
        return self.symbol_table.get_initial_values()

    def visit(self, node):
        node_types = node._labels
        if &#34;Module&#34; in node_types:
            self.visit_module(node)
        if &#34;Expression&#34; in node_types:
            self.visit_expression(node)
        if &#34;Function&#34; in node_types:
            self.visit_function(node)
        if &#34;Opo&#34; in node_types:
            return self.visit_opo(node)
        if &#34;Opi&#34; in node_types:
            return self.visit_opi(node)
        if &#34;Literal&#34; in node_types:
            return self.visit_literal(node)
        if &#34;Primitive&#34; in node_types:
            return self.visit_primitive(node)

    def visit_module(self, node):
        &#34;&#34;&#34;Visitor for top-level module&#34;&#34;&#34;
        node_id = str(node._id)

        expressions = self.query_runner.run_query(&#34;ordered_expressions&#34;, id=node_id)
        for expression in expressions:
            self.visit(expression)

    def visit_expression(self, node):
        node_id = node._id

        # Only the left hand side is directly connected to the expression. So, we access the right hand side from the left hand side node
        # (Expression) -&gt; (Opo) -&gt; (Primitive | Literal | Opo)
        left_hand_side = self.query_runner.run_query(&#34;assignment_left_hand&#34;, id=node_id)
        right_hand_side = self.query_runner.run_query(
            &#34;assignment_right_hand&#34;, id=left_hand_side[0]._id
        )

        # The lefthand side represents the Opo of the variable we are assigning to
        # TODO: What if we have multiple assignment x,y = 1,2
        # TODO: Does an expression always correspond to an assingment?
        symbol = self.visit(left_hand_side[0])

        # The right hand side can be either a LiteralValue, an Expression, or a Primitive
        # A Literal
        index = {&#34;Primitive&#34;: 1, &#34;Expression&#34;: 1, &#34;Literal&#34;: 2}
        right_hand_side = sorted(
            right_hand_side, key=lambda node: index[list(node._labels)[0]]
        )
        value = self.visit(right_hand_side[0])
        if not self.symbol_table.get_symbol(symbol):
            self.symbol_table.add_symbol(symbol, value, None)
        else:
            self.symbol_table.update_symbol(symbol, value, None)

    def visit_function(self, node):
        &#34;&#34;&#34;Visitor for :Opi node type&#34;&#34;&#34;
        # TODO: Add support for function calls/definitions
        pass

    def visit_opo(self, node):
        &#34;Visitor for :Opo node type&#34;
        return node.name

    def visit_opi(self, node):
        &#34;&#34;&#34;Visitor for :Opi node type&#34;&#34;&#34;
        node_id = node._id

        # If un-named, we need to get the name from the attached Opo
        if node.name == &#34;un-named&#34;:
            return self.visit(
                self.query_runner.run_query(&#34;assignment_left_hand&#34;, id=node_id)[0]
            )

        return node.name

    def visit_literal(self, node):
        def create_dummy_node(value: Dict):
            &#34;&#34;&#34;Create a dummy gqlalchemy node so that we can pass a LiteralValue to a visitor.&#34;&#34;&#34;

            class DummyNode:
                pass

            node = DummyNode()
            node._id = -1
            node._labels = [&#34;Literal&#34;]
            node.value = value

            # TODO: Update LiteralValue representation for List types
            node.value[&#34;value&#34;] = str(node.value[&#34;value&#34;])

            return node

        # TODO: Update LiteralValue to remove wrapping &#34;&#34; characters
        value = node.value[&#34;value&#34;].strip(&#39;&#34;&#39;)
        value_type = node.value[&#34;value_type&#34;]

        if value_type == &#34;Integer&#34;:
            return torch.tensor(int(value), dtype=torch.int)
        elif value_type == &#34;AbstractFloat&#34;:
            return torch.tensor(float(value), dtype=torch.float)
        elif value_type == &#34;Complex&#34;:
            print(
                &#34;WARNING: Execution for type Complex not support and will be skipped.&#34;
            )
        elif value_type == &#34;Boolean&#34;:
            return torch.tensor(value == &#34;True&#34;, dtype=torch.bool)
        elif value_type == &#34;List&#34;:
            if isinstance(value, str):
                return None
            list = literal_eval(value)
            return [self.visit(create_dummy_node(element)) for element in list]
        elif value_type == &#34;Map&#34;:
            print(&#34;WARNING: Execution for type Map not support and will be skipped.&#34;)
        elif value_type == &#34;None&#34;:
            return None

    def visit_primitive(self, node):
        &#34;&#34;&#34;Visitor for :Primitive node type&#34;&#34;&#34;
        node_id = node._id

        # Some inputs may be symbol names, so we need to access the current value from the symbol map
        inputs = [
            self.visit(input)
            for input in self.query_runner.run_query(&#34;primitive_operands&#34;, id=node_id)
        ]
        inputs = [
            self.symbol_table.get_symbol(input)[&#34;current_value&#34;]
            if isinstance(input, str)
            else input
            for input in inputs
        ]

        primative = retrieve_operator(node.name)
        return execute(primative, inputs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, module: bool = False, main: bool = False, function: bool = False, function_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the execution engine at specified scope</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(
    self,
    module: bool = False,
    main: bool = False,
    function: bool = False,
    function_name: str = None,
):
    &#34;&#34;&#34;Run the execution engine at specified scope&#34;&#34;&#34;
    if module:
        module_list = self.query_runner.run_query(
            &#34;module&#34;, n_or_m=&#34;n&#34;, filename=self.filename
        )
        self.visit(module_list[0])</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.parameter_extraction"><code class="name flex">
<span>def <span class="ident">parameter_extraction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the execution engine and extract initial values for each parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parameter_extraction(self):
    &#34;&#34;&#34;Run the execution engine and extract initial values for each parameter&#34;&#34;&#34;

    # Execute the source at the module level
    self.execute(module=True)

    # Extract the initial values from the symbol map
    return self.symbol_table.get_initial_values()</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.upload_source"><code class="name flex">
<span>def <span class="ident">upload_source</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ingest source file and upload Gromet to Memgraph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload_source(self):
    &#34;&#34;&#34;Ingest source file and upload Gromet to Memgraph&#34;&#34;&#34;

    # Currently, the Gromet ingester writes the output JSON to the directory where the script is run from.
    # Instead, we want to store it alongside the source so that we can upload it to Memgraph.
    gromet_collection = process_file(self.source_path)
    gromet_name = f&#34;{self.filename}--Gromet-FN-auto.json&#34;
    gromet_path = Path(self.source_path).parent / gromet_name
    gromet_path.write_text(
        dictionary_to_gromet_json(del_nulls(gromet_collection.to_dict()))
    )

    # The Memgraph database state should be reset before running any queries.
    # Unexpected nodes/edges can cause issues with execution.
    self.query_runner.run_query(&#34;reset_state&#34;)

    # Upload to memgraph
    subprocess.run(
        [&#34;cargo&#34;, &#34;run&#34;, &#34;--bin&#34;, &#34;gromet2graphdb&#34;, str(gromet_path)], cwd=SKEMA_BIN
    )</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    node_types = node._labels
    if &#34;Module&#34; in node_types:
        self.visit_module(node)
    if &#34;Expression&#34; in node_types:
        self.visit_expression(node)
    if &#34;Function&#34; in node_types:
        self.visit_function(node)
    if &#34;Opo&#34; in node_types:
        return self.visit_opo(node)
    if &#34;Opi&#34; in node_types:
        return self.visit_opi(node)
    if &#34;Literal&#34; in node_types:
        return self.visit_literal(node)
    if &#34;Primitive&#34; in node_types:
        return self.visit_primitive(node)</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_expression"><code class="name flex">
<span>def <span class="ident">visit_expression</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_expression(self, node):
    node_id = node._id

    # Only the left hand side is directly connected to the expression. So, we access the right hand side from the left hand side node
    # (Expression) -&gt; (Opo) -&gt; (Primitive | Literal | Opo)
    left_hand_side = self.query_runner.run_query(&#34;assignment_left_hand&#34;, id=node_id)
    right_hand_side = self.query_runner.run_query(
        &#34;assignment_right_hand&#34;, id=left_hand_side[0]._id
    )

    # The lefthand side represents the Opo of the variable we are assigning to
    # TODO: What if we have multiple assignment x,y = 1,2
    # TODO: Does an expression always correspond to an assingment?
    symbol = self.visit(left_hand_side[0])

    # The right hand side can be either a LiteralValue, an Expression, or a Primitive
    # A Literal
    index = {&#34;Primitive&#34;: 1, &#34;Expression&#34;: 1, &#34;Literal&#34;: 2}
    right_hand_side = sorted(
        right_hand_side, key=lambda node: index[list(node._labels)[0]]
    )
    value = self.visit(right_hand_side[0])
    if not self.symbol_table.get_symbol(symbol):
        self.symbol_table.add_symbol(symbol, value, None)
    else:
        self.symbol_table.update_symbol(symbol, value, None)</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_function"><code class="name flex">
<span>def <span class="ident">visit_function</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for :Opi node type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_function(self, node):
    &#34;&#34;&#34;Visitor for :Opi node type&#34;&#34;&#34;
    # TODO: Add support for function calls/definitions
    pass</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_literal"><code class="name flex">
<span>def <span class="ident">visit_literal</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_literal(self, node):
    def create_dummy_node(value: Dict):
        &#34;&#34;&#34;Create a dummy gqlalchemy node so that we can pass a LiteralValue to a visitor.&#34;&#34;&#34;

        class DummyNode:
            pass

        node = DummyNode()
        node._id = -1
        node._labels = [&#34;Literal&#34;]
        node.value = value

        # TODO: Update LiteralValue representation for List types
        node.value[&#34;value&#34;] = str(node.value[&#34;value&#34;])

        return node

    # TODO: Update LiteralValue to remove wrapping &#34;&#34; characters
    value = node.value[&#34;value&#34;].strip(&#39;&#34;&#39;)
    value_type = node.value[&#34;value_type&#34;]

    if value_type == &#34;Integer&#34;:
        return torch.tensor(int(value), dtype=torch.int)
    elif value_type == &#34;AbstractFloat&#34;:
        return torch.tensor(float(value), dtype=torch.float)
    elif value_type == &#34;Complex&#34;:
        print(
            &#34;WARNING: Execution for type Complex not support and will be skipped.&#34;
        )
    elif value_type == &#34;Boolean&#34;:
        return torch.tensor(value == &#34;True&#34;, dtype=torch.bool)
    elif value_type == &#34;List&#34;:
        if isinstance(value, str):
            return None
        list = literal_eval(value)
        return [self.visit(create_dummy_node(element)) for element in list]
    elif value_type == &#34;Map&#34;:
        print(&#34;WARNING: Execution for type Map not support and will be skipped.&#34;)
    elif value_type == &#34;None&#34;:
        return None</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_module"><code class="name flex">
<span>def <span class="ident">visit_module</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for top-level module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_module(self, node):
    &#34;&#34;&#34;Visitor for top-level module&#34;&#34;&#34;
    node_id = str(node._id)

    expressions = self.query_runner.run_query(&#34;ordered_expressions&#34;, id=node_id)
    for expression in expressions:
        self.visit(expression)</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_opi"><code class="name flex">
<span>def <span class="ident">visit_opi</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for :Opi node type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_opi(self, node):
    &#34;&#34;&#34;Visitor for :Opi node type&#34;&#34;&#34;
    node_id = node._id

    # If un-named, we need to get the name from the attached Opo
    if node.name == &#34;un-named&#34;:
        return self.visit(
            self.query_runner.run_query(&#34;assignment_left_hand&#34;, id=node_id)[0]
        )

    return node.name</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_opo"><code class="name flex">
<span>def <span class="ident">visit_opo</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for :Opo node type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_opo(self, node):
    &#34;Visitor for :Opo node type&#34;
    return node.name</code></pre>
</details>
</dd>
<dt id="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_primitive"><code class="name flex">
<span>def <span class="ident">visit_primitive</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visitor for :Primitive node type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_primitive(self, node):
    &#34;&#34;&#34;Visitor for :Primitive node type&#34;&#34;&#34;
    node_id = node._id

    # Some inputs may be symbol names, so we need to access the current value from the symbol map
    inputs = [
        self.visit(input)
        for input in self.query_runner.run_query(&#34;primitive_operands&#34;, id=node_id)
    ]
    inputs = [
        self.symbol_table.get_symbol(input)[&#34;current_value&#34;]
        if isinstance(input, str)
        else input
        for input in inputs
    ]

    primative = retrieve_operator(node.name)
    return execute(primative, inputs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.gromet.execution_engine" href="index.html">skema.gromet.execution_engine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.gromet.execution_engine.execution_engine.Execute" href="#skema.gromet.execution_engine.execution_engine.Execute">Execute</a></code></h4>
<ul class="">
<li><code><a title="skema.gromet.execution_engine.execution_engine.Execute.backward" href="#skema.gromet.execution_engine.execution_engine.Execute.backward">backward</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.Execute.forward" href="#skema.gromet.execution_engine.execution_engine.Execute.forward">forward</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine">ExecutionEngine</a></code></h4>
<ul class="">
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.execute" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.execute">execute</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.parameter_extraction" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.parameter_extraction">parameter_extraction</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.upload_source" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.upload_source">upload_source</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit">visit</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_expression" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_expression">visit_expression</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_function" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_function">visit_function</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_literal" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_literal">visit_literal</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_module" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_module">visit_module</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_opi" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_opi">visit_opi</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_opo" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_opo">visit_opo</a></code></li>
<li><code><a title="skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_primitive" href="#skema.gromet.execution_engine.execution_engine.ExecutionEngine.visit_primitive">visit_primitive</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>