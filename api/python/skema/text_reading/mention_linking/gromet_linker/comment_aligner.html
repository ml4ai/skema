<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>skema.text_reading.mention_linking.gromet_linker.comment_aligner API documentation</title>
<meta name="description" content="Aligns source code comments to Gromet function networks" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>skema.text_reading.mention_linking.gromet_linker.comment_aligner</code></h1>
</header>
<section id="section-intro">
<p>Aligns source code comments to Gromet function networks</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Aligns source code comments to Gromet function networks &#34;&#34;&#34;

from typing import List, Tuple
from .comment_debugger import CommentDebugger
from .comment_info import CommentInfo
from .gromet_helper import GrometHelper
from .provenance_helper import ProvenanceHelper
from .source_comments import SourceComments
from .text_reading_linker import TextReadingLinker
from .time_stamper import TimeStamper
from .uid_stamper import UidStamper
from .utils import Utils
from .variable_name_matcher import VariableNameMatcher

from skema.gromet.fn import (
    GrometBoxFunction,
    GrometFN,
    GrometFNModule,
    GrometPort,
    TypedValue,
)


class CommentAlignerHelper:
    def __init__(
        self,
        debugger: CommentDebugger,
        time_stamper: TimeStamper,
        uid_stamper: UidStamper,
        gromet_fn_module: GrometFNModule,
        variable_name_matcher: VariableNameMatcher,
        source_comments: SourceComments,
        linker: TextReadingLinker,
    ):
        self.debugger = debugger
        self.uid_stamper = uid_stamper
        self.gromet_fn_module = gromet_fn_module
        self.variable_name_matcher = variable_name_matcher
        self.source_comments = source_comments
        self.linker = linker
        self.provenance_helper = ProvenanceHelper(time_stamper)


class CommentAligner:
    def __init__(self, comment_aligner_helper: CommentAlignerHelper):
        self.comment_aligner_helper = comment_aligner_helper
        self.debugger = comment_aligner_helper.debugger
        self.uid_stamper = comment_aligner_helper.uid_stamper
        self.gromet_fn_module = comment_aligner_helper.gromet_fn_module
        self.variable_name_matcher = (
            comment_aligner_helper.variable_name_matcher
        )
        self.source_comments = comment_aligner_helper.source_comments
        self.linker = comment_aligner_helper.linker
        self.provenance_helper = comment_aligner_helper.provenance_helper

    def get_aligned_comments(
        self, name: str, inner_line_range: range, outer_line_range: range
    ) -&gt; List[Tuple[int, str]]:
        if name:
            leading_comments = self.get_leading_comments(outer_line_range)
            aligned_comments = self.variable_name_matcher.match_line_comment(
                name, leading_comments
            )
            return aligned_comments
        else:
            return []

    # Get the comments in contiguous lines above the function.
    def get_leading_comments(self, line_range: range) -&gt; List[Tuple[int, str]]:
        &#34;&#34;&#34;Gets the block of comments adjacent to the function&#39;s definition&#34;&#34;&#34;
        line_comments = self.source_comments.line_comments
        comments = list()
        # Since a line with a comment can have both code and a comment, we might want not to stop only at the first
        # line without a comment, but also at the first line with code.  The code would belong to something else.
        for line_num in range(
            line_range.start - 1, -1, -1
        ):  # decreasing line_num counter
            if line_num in line_comments:  # and line_num in outer_line_numbers
                comments.append((line_num, line_comments[line_num]))
            else:
                break
        comments.reverse()
        return comments

    def get_comments(self, line_comments: List[Tuple[int, str]]) -&gt; List[str]:
        return [comment for _, comment in line_comments]

    # TODO pass in comments, all of them, maybe with line numbers?  Name would be an exception, so apart?
    def align_mentions(
        self,
        name: str,
        gromet_object,
        aligned_docstrings: List[Tuple[int, str]],
        aligned_box_comments: List[Tuple[int, str]],
        aligned_comments: List[Tuple[int, str]],
    ) -&gt; None:
        # Build new metadata object and append it to the metadata list of each port.
        # TODO Enrique: Here will be a good place to introduce the fallback/default comments
        comments = (
            [name]
            if name
            else []
            + self.get_comments(aligned_docstrings)
            + self.get_comments(aligned_box_comments)
            + self.get_comments(aligned_comments)
        )
        code_file_ref = Utils.get_code_file_ref(
            self.source_comments.file_name(), self.gromet_fn_module
        )
        # aligned_comments, the only ones to include line numbers
        # TODO: Why should this be different?
        for comment in aligned_box_comments:
            Utils.build_line_comment_metadata(
                self.provenance_helper,
                comment,
                code_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )
        for _, comment in aligned_comments:
            Utils.build_comment_metadata(
                self.provenance_helper,
                comment,
                code_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )
        # aligned docstring
        for _, docstring in aligned_docstrings:
            Utils.build_comment_metadata(
                self.provenance_helper,
                docstring,
                code_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )

        aligned_mentions = self.linker.align_to_comments(comments)

        for mention in aligned_mentions:
            doc_file_ref = Utils.get_doc_file_ref(
                self.provenance_helper,
                self.uid_stamper,
                mention,
                self.linker,
                self.gromet_fn_module,
            )
            Utils.build_textreading_mention_metadata(
                self.provenance_helper,
                mention,
                doc_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )

        comment_info = CommentInfo(
            self.line_range,
            self.name,
            aligned_docstrings,
            aligned_box_comments + aligned_comments,
            aligned_mentions,
        )
        self.debugger.add_info(comment_info)

        # return aligned_mentions


class GrometBoxFunctionCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_box_function: GrometBoxFunction,
        comment_aligner_helper: CommentAlignerHelper,
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_box_function = gromet_box_function
        self.name = self.gromet_box_function.name
        self.line_range = GrometHelper.get_element_line_numbers(
            self.gromet_box_function, self.gromet_fn_module
        )

    def get_aligned_box_comments(
        self, line_range: range
    ) -&gt; List[Tuple[int, str]]:
        comments = list()
        if self.gromet_box_function.function_type not in {
            &#34;PRIMITIVE&#34;,
            &#34;LITERAL&#34;,
        }:
            for line_num in line_range:
                if line_num in self.source_comments.line_comments:
                    comments.append(
                        (
                            line_num,
                            self.source_comments.line_comments[line_num],
                        )
                    )
        return comments


class OuterGrometBoxFunctionCommentAligner(GrometBoxFunctionCommentAligner):
    def __init__(
        self,
        gromet_box_function: GrometBoxFunction,
        comment_aligner_helper: CommentAlignerHelper,
    ):
        super().__init__(gromet_box_function, comment_aligner_helper)
        self.line_docstrings = self.make_line_docstrings()

    def make_line_docstrings(self) -&gt; List[str]:
        # docstrings are within the function, just after the signature and before the body.
        condition = self.gromet_box_function.function_type == &#34;FUNCTION&#34;
        # This retrieves the docstrings based on the box function&#39;s name.  It gets all of them.
        line_docstrings = (
            self.source_comments.get_line_docstrings(
                self.gromet_box_function.name
            )
            if condition
            else []
        )
        return line_docstrings

    def align(self) -&gt; None:
        if self.name:
            # This below is all of the docstrings for the function.  The name has already been matched above.
            aligned_docstrings = self.line_docstrings
            # This is all the comments within the line_range, independent of the name.
            aligned_box_comments = self.get_aligned_box_comments(
                self.line_range
            )
            # This is all the comments above the second line range until a line without a comment is encountered
            # (or the beginning of the file) where the name also matches.
            # For a box function, these would be comments just before the function definition, which seems reasonable.
            aligned_comments = self.get_aligned_comments(
                self.name, self.line_range, self.line_range
            )
            self.align_mentions(
                self.name,
                self.gromet_box_function,
                aligned_docstrings,
                aligned_box_comments,
                aligned_comments,
            )


class InnerGrometBoxFunctionCommentAligner(GrometBoxFunctionCommentAligner):
    def __init__(
        self,
        gromet_box_function: GrometBoxFunction,
        comment_aligner_helper: CommentAlignerHelper,
        line_docstrings: List[Tuple[int, str]],
        outer_line_range: range,
    ):
        super().__init__(gromet_box_function, comment_aligner_helper)
        self.line_docstrings = line_docstrings
        self.outer_line_range = outer_line_range

    def align(self) -&gt; None:
        # These are all the docstrings where the name has matched.
        aligned_docstrings = self.variable_name_matcher.match_line_comment(
            self.name, self.line_docstrings
        )
        # This is all the comments within the line_range, so possibly just the one line, independent of name.
        aligned_box_comments = self.get_aligned_box_comments(self.line_range)
        # This is all the comments above the second line range, the outer_line_range, where the name also matches.
        aligned_comments = self.get_aligned_comments(
            self.name, self.line_range, self.outer_line_range
        )
        self.align_mentions(
            self.name,
            self.gromet_box_function,
            aligned_docstrings,
            aligned_box_comments,
            aligned_comments,
        )


class GrometPortCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_port: GrometPort,
        comment_aligner_helper: CommentAlignerHelper,
        line_docstrings: List[Tuple[int, str]],
        outer_line_range: range,
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_port = gromet_port
        self.line_docstrings = line_docstrings
        self.name = self.gromet_port.name
        self.outer_line_range = outer_line_range
        self.line_range = GrometHelper.get_element_line_numbers(
            self.gromet_port, self.gromet_fn_module
        )

    def align(self) -&gt; None:
        # These are all the docstrings where the name has matched.
        aligned_docstrings = self.variable_name_matcher.match_line_comment(
            self.name, self.line_docstrings
        )
        # This is completely skipped.
        aligned_box_comments = []
        # This is all the comments above the second line range, the outer_line_range, where the name also matches.
        aligned_comments = self.get_aligned_comments(
            self.name, self.line_range, self.outer_line_range
        )
        self.align_mentions(
            self.name,
            self.gromet_port,
            aligned_docstrings,
            aligned_box_comments,
            aligned_comments,
        )


class GrometFNCommentAligner(CommentAligner):
    def __init__(
        self, gromet_fn: GrometFN, comment_aligner_helper: CommentAlignerHelper
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_fn = gromet_fn
        # b: The FN Outer Box (although not enforced, there is always only 1).
        # The gromet_fn value comes from the superclass that gets it from the helper.
        assert self.gromet_fn.b and len(self.gromet_fn.b) == 1
        self.outer_gromet_box_function = self.gromet_fn.b[0]

    def align(self) -&gt; None:
        # Identify the output ports with variable names
        ## attributes -&gt; type:&#34;FN&#34; -&gt; value:&#34;b&#34; with name
        ##                            value:&#34;opi&#34; with name
        ##                            value:&#34;pof&#34; with [unnecessary] name
        ##                            value:&#34;poc&#34; with name??
        outer_gromet_box_function_comment_aligner = (
            OuterGrometBoxFunctionCommentAligner(
                self.outer_gromet_box_function, self.comment_aligner_helper
            )
        )
        outer_gromet_box_function_comment_aligner.align()
        line_docstrings = (
            outer_gromet_box_function_comment_aligner.line_docstrings
        )
        outer_line_range = outer_gromet_box_function_comment_aligner.line_range

        # opi: The Outer Port Inputs of the FN Outer Box (b)
        if self.gromet_fn.opi:
            for gromet_port in self.gromet_fn.opi:
                GrometPortCommentAligner(
                    gromet_port,
                    self.comment_aligner_helper,
                    line_docstrings,
                    outer_line_range,
                ).align()
        # pof: The Port Outputs of the GrometBoxFunctions (bf).
        if self.gromet_fn.pof:
            for gromet_port in self.gromet_fn.pof:
                GrometPortCommentAligner(
                    gromet_port,
                    self.comment_aligner_helper,
                    line_docstrings,
                    outer_line_range,
                ).align()
        # bf: The GrometBoxFunctions within this GrometFN.
        if self.gromet_fn.bf:
            for gromet_box_function in self.gromet_fn.bf:
                InnerGrometBoxFunctionCommentAligner(
                    gromet_box_function,
                    self.comment_aligner_helper,
                    line_docstrings,
                    outer_line_range,
                ).align()
        # poc: The Port Outputs of the GrometBoxConditionals (bc)
        # TODO: Is this redundant?
        # for poc in v.poc:
        #       GrometPortCommentAligner(gromet_port, self.comment_aligner_helper, line_docstrings, outer_line_range).align()


class GrometAttributeCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_attribute: TypedValue,
        comment_aligner_helper: CommentAlignerHelper,
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_attribute = gromet_attribute

    def align(self) -&gt; None:
        if self.gromet_attribute.type == &#34;FN&#34;:
            GrometFNCommentAligner(
                self.gromet_attribute.value, self.comment_aligner_helper
            ).align()


class GrometFNModuleCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_fn_module: GrometFNModule,
        comment_aligner_helper: CommentAlignerHelper,
        embeddings_path: str,
    ):
        # TODO: The incoming gromet_fn_module should not yet have been aligned.  Assert that!
        super().__init__(comment_aligner_helper)
        self.gromet_fn_module = gromet_fn_module
        # TODO: Add the codefile references.

    def align(self) -&gt; None:
        # TODO Make this work for several modules!
        for gromet_attribute in self.gromet_fn_module.attributes:
            GrometAttributeCommentAligner(
                gromet_attribute, self.comment_aligner_helper
            ).align()
        self.debugger.debug()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner"><code class="flex name class">
<span>class <span class="ident">CommentAligner</span></span>
<span>(</span><span>comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommentAligner:
    def __init__(self, comment_aligner_helper: CommentAlignerHelper):
        self.comment_aligner_helper = comment_aligner_helper
        self.debugger = comment_aligner_helper.debugger
        self.uid_stamper = comment_aligner_helper.uid_stamper
        self.gromet_fn_module = comment_aligner_helper.gromet_fn_module
        self.variable_name_matcher = (
            comment_aligner_helper.variable_name_matcher
        )
        self.source_comments = comment_aligner_helper.source_comments
        self.linker = comment_aligner_helper.linker
        self.provenance_helper = comment_aligner_helper.provenance_helper

    def get_aligned_comments(
        self, name: str, inner_line_range: range, outer_line_range: range
    ) -&gt; List[Tuple[int, str]]:
        if name:
            leading_comments = self.get_leading_comments(outer_line_range)
            aligned_comments = self.variable_name_matcher.match_line_comment(
                name, leading_comments
            )
            return aligned_comments
        else:
            return []

    # Get the comments in contiguous lines above the function.
    def get_leading_comments(self, line_range: range) -&gt; List[Tuple[int, str]]:
        &#34;&#34;&#34;Gets the block of comments adjacent to the function&#39;s definition&#34;&#34;&#34;
        line_comments = self.source_comments.line_comments
        comments = list()
        # Since a line with a comment can have both code and a comment, we might want not to stop only at the first
        # line without a comment, but also at the first line with code.  The code would belong to something else.
        for line_num in range(
            line_range.start - 1, -1, -1
        ):  # decreasing line_num counter
            if line_num in line_comments:  # and line_num in outer_line_numbers
                comments.append((line_num, line_comments[line_num]))
            else:
                break
        comments.reverse()
        return comments

    def get_comments(self, line_comments: List[Tuple[int, str]]) -&gt; List[str]:
        return [comment for _, comment in line_comments]

    # TODO pass in comments, all of them, maybe with line numbers?  Name would be an exception, so apart?
    def align_mentions(
        self,
        name: str,
        gromet_object,
        aligned_docstrings: List[Tuple[int, str]],
        aligned_box_comments: List[Tuple[int, str]],
        aligned_comments: List[Tuple[int, str]],
    ) -&gt; None:
        # Build new metadata object and append it to the metadata list of each port.
        # TODO Enrique: Here will be a good place to introduce the fallback/default comments
        comments = (
            [name]
            if name
            else []
            + self.get_comments(aligned_docstrings)
            + self.get_comments(aligned_box_comments)
            + self.get_comments(aligned_comments)
        )
        code_file_ref = Utils.get_code_file_ref(
            self.source_comments.file_name(), self.gromet_fn_module
        )
        # aligned_comments, the only ones to include line numbers
        # TODO: Why should this be different?
        for comment in aligned_box_comments:
            Utils.build_line_comment_metadata(
                self.provenance_helper,
                comment,
                code_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )
        for _, comment in aligned_comments:
            Utils.build_comment_metadata(
                self.provenance_helper,
                comment,
                code_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )
        # aligned docstring
        for _, docstring in aligned_docstrings:
            Utils.build_comment_metadata(
                self.provenance_helper,
                docstring,
                code_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )

        aligned_mentions = self.linker.align_to_comments(comments)

        for mention in aligned_mentions:
            doc_file_ref = Utils.get_doc_file_ref(
                self.provenance_helper,
                self.uid_stamper,
                mention,
                self.linker,
                self.gromet_fn_module,
            )
            Utils.build_textreading_mention_metadata(
                self.provenance_helper,
                mention,
                doc_file_ref,
                gromet_object,
                self.gromet_fn_module,
            )

        comment_info = CommentInfo(
            self.line_range,
            self.name,
            aligned_docstrings,
            aligned_box_comments + aligned_comments,
            aligned_mentions,
        )
        self.debugger.add_info(comment_info)

        # return aligned_mentions</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner">GrometAttributeCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner">GrometBoxFunctionCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner">GrometFNCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner">GrometFNModuleCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner">GrometPortCommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.align_mentions"><code class="name flex">
<span>def <span class="ident">align_mentions</span></span>(<span>self, name: str, gromet_object, aligned_docstrings: List[Tuple[int, str]], aligned_box_comments: List[Tuple[int, str]], aligned_comments: List[Tuple[int, str]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_mentions(
    self,
    name: str,
    gromet_object,
    aligned_docstrings: List[Tuple[int, str]],
    aligned_box_comments: List[Tuple[int, str]],
    aligned_comments: List[Tuple[int, str]],
) -&gt; None:
    # Build new metadata object and append it to the metadata list of each port.
    # TODO Enrique: Here will be a good place to introduce the fallback/default comments
    comments = (
        [name]
        if name
        else []
        + self.get_comments(aligned_docstrings)
        + self.get_comments(aligned_box_comments)
        + self.get_comments(aligned_comments)
    )
    code_file_ref = Utils.get_code_file_ref(
        self.source_comments.file_name(), self.gromet_fn_module
    )
    # aligned_comments, the only ones to include line numbers
    # TODO: Why should this be different?
    for comment in aligned_box_comments:
        Utils.build_line_comment_metadata(
            self.provenance_helper,
            comment,
            code_file_ref,
            gromet_object,
            self.gromet_fn_module,
        )
    for _, comment in aligned_comments:
        Utils.build_comment_metadata(
            self.provenance_helper,
            comment,
            code_file_ref,
            gromet_object,
            self.gromet_fn_module,
        )
    # aligned docstring
    for _, docstring in aligned_docstrings:
        Utils.build_comment_metadata(
            self.provenance_helper,
            docstring,
            code_file_ref,
            gromet_object,
            self.gromet_fn_module,
        )

    aligned_mentions = self.linker.align_to_comments(comments)

    for mention in aligned_mentions:
        doc_file_ref = Utils.get_doc_file_ref(
            self.provenance_helper,
            self.uid_stamper,
            mention,
            self.linker,
            self.gromet_fn_module,
        )
        Utils.build_textreading_mention_metadata(
            self.provenance_helper,
            mention,
            doc_file_ref,
            gromet_object,
            self.gromet_fn_module,
        )

    comment_info = CommentInfo(
        self.line_range,
        self.name,
        aligned_docstrings,
        aligned_box_comments + aligned_comments,
        aligned_mentions,
    )
    self.debugger.add_info(comment_info)

    # return aligned_mentions</code></pre>
</details>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_aligned_comments"><code class="name flex">
<span>def <span class="ident">get_aligned_comments</span></span>(<span>self, name: str, inner_line_range: range, outer_line_range: range) ‑> List[Tuple[int, str]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aligned_comments(
    self, name: str, inner_line_range: range, outer_line_range: range
) -&gt; List[Tuple[int, str]]:
    if name:
        leading_comments = self.get_leading_comments(outer_line_range)
        aligned_comments = self.variable_name_matcher.match_line_comment(
            name, leading_comments
        )
        return aligned_comments
    else:
        return []</code></pre>
</details>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_comments"><code class="name flex">
<span>def <span class="ident">get_comments</span></span>(<span>self, line_comments: List[Tuple[int, str]]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_comments(self, line_comments: List[Tuple[int, str]]) -&gt; List[str]:
    return [comment for _, comment in line_comments]</code></pre>
</details>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments"><code class="name flex">
<span>def <span class="ident">get_leading_comments</span></span>(<span>self, line_range: range) ‑> List[Tuple[int, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the block of comments adjacent to the function's definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_leading_comments(self, line_range: range) -&gt; List[Tuple[int, str]]:
    &#34;&#34;&#34;Gets the block of comments adjacent to the function&#39;s definition&#34;&#34;&#34;
    line_comments = self.source_comments.line_comments
    comments = list()
    # Since a line with a comment can have both code and a comment, we might want not to stop only at the first
    # line without a comment, but also at the first line with code.  The code would belong to something else.
    for line_num in range(
        line_range.start - 1, -1, -1
    ):  # decreasing line_num counter
        if line_num in line_comments:  # and line_num in outer_line_numbers
            comments.append((line_num, line_comments[line_num]))
        else:
            break
    comments.reverse()
    return comments</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper"><code class="flex name class">
<span>class <span class="ident">CommentAlignerHelper</span></span>
<span>(</span><span>debugger: <a title="skema.text_reading.mention_linking.gromet_linker.comment_debugger.CommentDebugger" href="comment_debugger.html#skema.text_reading.mention_linking.gromet_linker.comment_debugger.CommentDebugger">CommentDebugger</a>, time_stamper: <a title="skema.text_reading.mention_linking.gromet_linker.time_stamper.TimeStamper" href="time_stamper.html#skema.text_reading.mention_linking.gromet_linker.time_stamper.TimeStamper">TimeStamper</a>, uid_stamper: <a title="skema.text_reading.mention_linking.gromet_linker.uid_stamper.UidStamper" href="uid_stamper.html#skema.text_reading.mention_linking.gromet_linker.uid_stamper.UidStamper">UidStamper</a>, gromet_fn_module: skema.gromet.fn.gromet_fn_module.GrometFNModule, variable_name_matcher: <a title="skema.text_reading.mention_linking.gromet_linker.variable_name_matcher.VariableNameMatcher" href="variable_name_matcher.html#skema.text_reading.mention_linking.gromet_linker.variable_name_matcher.VariableNameMatcher">VariableNameMatcher</a>, source_comments: <a title="skema.text_reading.mention_linking.gromet_linker.source_comments.SourceComments" href="source_comments.html#skema.text_reading.mention_linking.gromet_linker.source_comments.SourceComments">SourceComments</a>, linker: <a title="skema.text_reading.mention_linking.gromet_linker.text_reading_linker.TextReadingLinker" href="text_reading_linker.html#skema.text_reading.mention_linking.gromet_linker.text_reading_linker.TextReadingLinker">TextReadingLinker</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommentAlignerHelper:
    def __init__(
        self,
        debugger: CommentDebugger,
        time_stamper: TimeStamper,
        uid_stamper: UidStamper,
        gromet_fn_module: GrometFNModule,
        variable_name_matcher: VariableNameMatcher,
        source_comments: SourceComments,
        linker: TextReadingLinker,
    ):
        self.debugger = debugger
        self.uid_stamper = uid_stamper
        self.gromet_fn_module = gromet_fn_module
        self.variable_name_matcher = variable_name_matcher
        self.source_comments = source_comments
        self.linker = linker
        self.provenance_helper = ProvenanceHelper(time_stamper)</code></pre>
</details>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner"><code class="flex name class">
<span>class <span class="ident">GrometAttributeCommentAligner</span></span>
<span>(</span><span>gromet_attribute: skema.gromet.fn.typed_value.TypedValue, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrometAttributeCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_attribute: TypedValue,
        comment_aligner_helper: CommentAlignerHelper,
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_attribute = gromet_attribute

    def align(self) -&gt; None:
        if self.gromet_attribute.type == &#34;FN&#34;:
            GrometFNCommentAligner(
                self.gromet_attribute.value, self.comment_aligner_helper
            ).align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self) -&gt; None:
    if self.gromet_attribute.type == &#34;FN&#34;:
        GrometFNCommentAligner(
            self.gromet_attribute.value, self.comment_aligner_helper
        ).align()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner"><code class="flex name class">
<span>class <span class="ident">GrometBoxFunctionCommentAligner</span></span>
<span>(</span><span>gromet_box_function: skema.gromet.fn.gromet_box_function.GrometBoxFunction, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrometBoxFunctionCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_box_function: GrometBoxFunction,
        comment_aligner_helper: CommentAlignerHelper,
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_box_function = gromet_box_function
        self.name = self.gromet_box_function.name
        self.line_range = GrometHelper.get_element_line_numbers(
            self.gromet_box_function, self.gromet_fn_module
        )

    def get_aligned_box_comments(
        self, line_range: range
    ) -&gt; List[Tuple[int, str]]:
        comments = list()
        if self.gromet_box_function.function_type not in {
            &#34;PRIMITIVE&#34;,
            &#34;LITERAL&#34;,
        }:
            for line_num in line_range:
                if line_num in self.source_comments.line_comments:
                    comments.append(
                        (
                            line_num,
                            self.source_comments.line_comments[line_num],
                        )
                    )
        return comments</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner">InnerGrometBoxFunctionCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner">OuterGrometBoxFunctionCommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner.get_aligned_box_comments"><code class="name flex">
<span>def <span class="ident">get_aligned_box_comments</span></span>(<span>self, line_range: range) ‑> List[Tuple[int, str]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aligned_box_comments(
    self, line_range: range
) -&gt; List[Tuple[int, str]]:
    comments = list()
    if self.gromet_box_function.function_type not in {
        &#34;PRIMITIVE&#34;,
        &#34;LITERAL&#34;,
    }:
        for line_num in line_range:
            if line_num in self.source_comments.line_comments:
                comments.append(
                    (
                        line_num,
                        self.source_comments.line_comments[line_num],
                    )
                )
    return comments</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner"><code class="flex name class">
<span>class <span class="ident">GrometFNCommentAligner</span></span>
<span>(</span><span>gromet_fn: skema.gromet.fn.gromet_fn.GrometFN, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrometFNCommentAligner(CommentAligner):
    def __init__(
        self, gromet_fn: GrometFN, comment_aligner_helper: CommentAlignerHelper
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_fn = gromet_fn
        # b: The FN Outer Box (although not enforced, there is always only 1).
        # The gromet_fn value comes from the superclass that gets it from the helper.
        assert self.gromet_fn.b and len(self.gromet_fn.b) == 1
        self.outer_gromet_box_function = self.gromet_fn.b[0]

    def align(self) -&gt; None:
        # Identify the output ports with variable names
        ## attributes -&gt; type:&#34;FN&#34; -&gt; value:&#34;b&#34; with name
        ##                            value:&#34;opi&#34; with name
        ##                            value:&#34;pof&#34; with [unnecessary] name
        ##                            value:&#34;poc&#34; with name??
        outer_gromet_box_function_comment_aligner = (
            OuterGrometBoxFunctionCommentAligner(
                self.outer_gromet_box_function, self.comment_aligner_helper
            )
        )
        outer_gromet_box_function_comment_aligner.align()
        line_docstrings = (
            outer_gromet_box_function_comment_aligner.line_docstrings
        )
        outer_line_range = outer_gromet_box_function_comment_aligner.line_range

        # opi: The Outer Port Inputs of the FN Outer Box (b)
        if self.gromet_fn.opi:
            for gromet_port in self.gromet_fn.opi:
                GrometPortCommentAligner(
                    gromet_port,
                    self.comment_aligner_helper,
                    line_docstrings,
                    outer_line_range,
                ).align()
        # pof: The Port Outputs of the GrometBoxFunctions (bf).
        if self.gromet_fn.pof:
            for gromet_port in self.gromet_fn.pof:
                GrometPortCommentAligner(
                    gromet_port,
                    self.comment_aligner_helper,
                    line_docstrings,
                    outer_line_range,
                ).align()
        # bf: The GrometBoxFunctions within this GrometFN.
        if self.gromet_fn.bf:
            for gromet_box_function in self.gromet_fn.bf:
                InnerGrometBoxFunctionCommentAligner(
                    gromet_box_function,
                    self.comment_aligner_helper,
                    line_docstrings,
                    outer_line_range,
                ).align()
        # poc: The Port Outputs of the GrometBoxConditionals (bc)
        # TODO: Is this redundant?
        # for poc in v.poc:
        #       GrometPortCommentAligner(gromet_port, self.comment_aligner_helper, line_docstrings, outer_line_range).align()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self) -&gt; None:
    # Identify the output ports with variable names
    ## attributes -&gt; type:&#34;FN&#34; -&gt; value:&#34;b&#34; with name
    ##                            value:&#34;opi&#34; with name
    ##                            value:&#34;pof&#34; with [unnecessary] name
    ##                            value:&#34;poc&#34; with name??
    outer_gromet_box_function_comment_aligner = (
        OuterGrometBoxFunctionCommentAligner(
            self.outer_gromet_box_function, self.comment_aligner_helper
        )
    )
    outer_gromet_box_function_comment_aligner.align()
    line_docstrings = (
        outer_gromet_box_function_comment_aligner.line_docstrings
    )
    outer_line_range = outer_gromet_box_function_comment_aligner.line_range

    # opi: The Outer Port Inputs of the FN Outer Box (b)
    if self.gromet_fn.opi:
        for gromet_port in self.gromet_fn.opi:
            GrometPortCommentAligner(
                gromet_port,
                self.comment_aligner_helper,
                line_docstrings,
                outer_line_range,
            ).align()
    # pof: The Port Outputs of the GrometBoxFunctions (bf).
    if self.gromet_fn.pof:
        for gromet_port in self.gromet_fn.pof:
            GrometPortCommentAligner(
                gromet_port,
                self.comment_aligner_helper,
                line_docstrings,
                outer_line_range,
            ).align()
    # bf: The GrometBoxFunctions within this GrometFN.
    if self.gromet_fn.bf:
        for gromet_box_function in self.gromet_fn.bf:
            InnerGrometBoxFunctionCommentAligner(
                gromet_box_function,
                self.comment_aligner_helper,
                line_docstrings,
                outer_line_range,
            ).align()
    # poc: The Port Outputs of the GrometBoxConditionals (bc)
    # TODO: Is this redundant?
    # for poc in v.poc:
    #       GrometPortCommentAligner(gromet_port, self.comment_aligner_helper, line_docstrings, outer_line_range).align()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner"><code class="flex name class">
<span>class <span class="ident">GrometFNModuleCommentAligner</span></span>
<span>(</span><span>gromet_fn_module: skema.gromet.fn.gromet_fn_module.GrometFNModule, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>, embeddings_path: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrometFNModuleCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_fn_module: GrometFNModule,
        comment_aligner_helper: CommentAlignerHelper,
        embeddings_path: str,
    ):
        # TODO: The incoming gromet_fn_module should not yet have been aligned.  Assert that!
        super().__init__(comment_aligner_helper)
        self.gromet_fn_module = gromet_fn_module
        # TODO: Add the codefile references.

    def align(self) -&gt; None:
        # TODO Make this work for several modules!
        for gromet_attribute in self.gromet_fn_module.attributes:
            GrometAttributeCommentAligner(
                gromet_attribute, self.comment_aligner_helper
            ).align()
        self.debugger.debug()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self) -&gt; None:
    # TODO Make this work for several modules!
    for gromet_attribute in self.gromet_fn_module.attributes:
        GrometAttributeCommentAligner(
            gromet_attribute, self.comment_aligner_helper
        ).align()
    self.debugger.debug()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner"><code class="flex name class">
<span>class <span class="ident">GrometPortCommentAligner</span></span>
<span>(</span><span>gromet_port: skema.gromet.fn.gromet_port.GrometPort, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>, line_docstrings: List[Tuple[int, str]], outer_line_range: range)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GrometPortCommentAligner(CommentAligner):
    def __init__(
        self,
        gromet_port: GrometPort,
        comment_aligner_helper: CommentAlignerHelper,
        line_docstrings: List[Tuple[int, str]],
        outer_line_range: range,
    ):
        super().__init__(comment_aligner_helper)
        self.gromet_port = gromet_port
        self.line_docstrings = line_docstrings
        self.name = self.gromet_port.name
        self.outer_line_range = outer_line_range
        self.line_range = GrometHelper.get_element_line_numbers(
            self.gromet_port, self.gromet_fn_module
        )

    def align(self) -&gt; None:
        # These are all the docstrings where the name has matched.
        aligned_docstrings = self.variable_name_matcher.match_line_comment(
            self.name, self.line_docstrings
        )
        # This is completely skipped.
        aligned_box_comments = []
        # This is all the comments above the second line range, the outer_line_range, where the name also matches.
        aligned_comments = self.get_aligned_comments(
            self.name, self.line_range, self.outer_line_range
        )
        self.align_mentions(
            self.name,
            self.gromet_port,
            aligned_docstrings,
            aligned_box_comments,
            aligned_comments,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self) -&gt; None:
    # These are all the docstrings where the name has matched.
    aligned_docstrings = self.variable_name_matcher.match_line_comment(
        self.name, self.line_docstrings
    )
    # This is completely skipped.
    aligned_box_comments = []
    # This is all the comments above the second line range, the outer_line_range, where the name also matches.
    aligned_comments = self.get_aligned_comments(
        self.name, self.line_range, self.outer_line_range
    )
    self.align_mentions(
        self.name,
        self.gromet_port,
        aligned_docstrings,
        aligned_box_comments,
        aligned_comments,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner"><code class="flex name class">
<span>class <span class="ident">InnerGrometBoxFunctionCommentAligner</span></span>
<span>(</span><span>gromet_box_function: skema.gromet.fn.gromet_box_function.GrometBoxFunction, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>, line_docstrings: List[Tuple[int, str]], outer_line_range: range)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InnerGrometBoxFunctionCommentAligner(GrometBoxFunctionCommentAligner):
    def __init__(
        self,
        gromet_box_function: GrometBoxFunction,
        comment_aligner_helper: CommentAlignerHelper,
        line_docstrings: List[Tuple[int, str]],
        outer_line_range: range,
    ):
        super().__init__(gromet_box_function, comment_aligner_helper)
        self.line_docstrings = line_docstrings
        self.outer_line_range = outer_line_range

    def align(self) -&gt; None:
        # These are all the docstrings where the name has matched.
        aligned_docstrings = self.variable_name_matcher.match_line_comment(
            self.name, self.line_docstrings
        )
        # This is all the comments within the line_range, so possibly just the one line, independent of name.
        aligned_box_comments = self.get_aligned_box_comments(self.line_range)
        # This is all the comments above the second line range, the outer_line_range, where the name also matches.
        aligned_comments = self.get_aligned_comments(
            self.name, self.line_range, self.outer_line_range
        )
        self.align_mentions(
            self.name,
            self.gromet_box_function,
            aligned_docstrings,
            aligned_box_comments,
            aligned_comments,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner">GrometBoxFunctionCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self) -&gt; None:
    # These are all the docstrings where the name has matched.
    aligned_docstrings = self.variable_name_matcher.match_line_comment(
        self.name, self.line_docstrings
    )
    # This is all the comments within the line_range, so possibly just the one line, independent of name.
    aligned_box_comments = self.get_aligned_box_comments(self.line_range)
    # This is all the comments above the second line range, the outer_line_range, where the name also matches.
    aligned_comments = self.get_aligned_comments(
        self.name, self.line_range, self.outer_line_range
    )
    self.align_mentions(
        self.name,
        self.gromet_box_function,
        aligned_docstrings,
        aligned_box_comments,
        aligned_comments,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner">GrometBoxFunctionCommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner"><code class="flex name class">
<span>class <span class="ident">OuterGrometBoxFunctionCommentAligner</span></span>
<span>(</span><span>gromet_box_function: skema.gromet.fn.gromet_box_function.GrometBoxFunction, comment_aligner_helper: <a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OuterGrometBoxFunctionCommentAligner(GrometBoxFunctionCommentAligner):
    def __init__(
        self,
        gromet_box_function: GrometBoxFunction,
        comment_aligner_helper: CommentAlignerHelper,
    ):
        super().__init__(gromet_box_function, comment_aligner_helper)
        self.line_docstrings = self.make_line_docstrings()

    def make_line_docstrings(self) -&gt; List[str]:
        # docstrings are within the function, just after the signature and before the body.
        condition = self.gromet_box_function.function_type == &#34;FUNCTION&#34;
        # This retrieves the docstrings based on the box function&#39;s name.  It gets all of them.
        line_docstrings = (
            self.source_comments.get_line_docstrings(
                self.gromet_box_function.name
            )
            if condition
            else []
        )
        return line_docstrings

    def align(self) -&gt; None:
        if self.name:
            # This below is all of the docstrings for the function.  The name has already been matched above.
            aligned_docstrings = self.line_docstrings
            # This is all the comments within the line_range, independent of the name.
            aligned_box_comments = self.get_aligned_box_comments(
                self.line_range
            )
            # This is all the comments above the second line range until a line without a comment is encountered
            # (or the beginning of the file) where the name also matches.
            # For a box function, these would be comments just before the function definition, which seems reasonable.
            aligned_comments = self.get_aligned_comments(
                self.name, self.line_range, self.line_range
            )
            self.align_mentions(
                self.name,
                self.gromet_box_function,
                aligned_docstrings,
                aligned_box_comments,
                aligned_comments,
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner">GrometBoxFunctionCommentAligner</a></li>
<li><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self) -&gt; None:
    if self.name:
        # This below is all of the docstrings for the function.  The name has already been matched above.
        aligned_docstrings = self.line_docstrings
        # This is all the comments within the line_range, independent of the name.
        aligned_box_comments = self.get_aligned_box_comments(
            self.line_range
        )
        # This is all the comments above the second line range until a line without a comment is encountered
        # (or the beginning of the file) where the name also matches.
        # For a box function, these would be comments just before the function definition, which seems reasonable.
        aligned_comments = self.get_aligned_comments(
            self.name, self.line_range, self.line_range
        )
        self.align_mentions(
            self.name,
            self.gromet_box_function,
            aligned_docstrings,
            aligned_box_comments,
            aligned_comments,
        )</code></pre>
</details>
</dd>
<dt id="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner.make_line_docstrings"><code class="name flex">
<span>def <span class="ident">make_line_docstrings</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_line_docstrings(self) -&gt; List[str]:
    # docstrings are within the function, just after the signature and before the body.
    condition = self.gromet_box_function.function_type == &#34;FUNCTION&#34;
    # This retrieves the docstrings based on the box function&#39;s name.  It gets all of them.
    line_docstrings = (
        self.source_comments.get_line_docstrings(
            self.gromet_box_function.name
        )
        if condition
        else []
    )
    return line_docstrings</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner">GrometBoxFunctionCommentAligner</a></b></code>:
<ul class="hlist">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="skema.text_reading.mention_linking.gromet_linker" href="index.html">skema.text_reading.mention_linking.gromet_linker</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner">CommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.align_mentions" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.align_mentions">align_mentions</a></code></li>
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_aligned_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_aligned_comments">get_aligned_comments</a></code></li>
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_comments">get_comments</a></code></li>
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAligner.get_leading_comments">get_leading_comments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.CommentAlignerHelper">CommentAlignerHelper</a></code></h4>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner">GrometAttributeCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner.align" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometAttributeCommentAligner.align">align</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner">GrometBoxFunctionCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner.get_aligned_box_comments" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometBoxFunctionCommentAligner.get_aligned_box_comments">get_aligned_box_comments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner">GrometFNCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner.align" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNCommentAligner.align">align</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner">GrometFNModuleCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner.align" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometFNModuleCommentAligner.align">align</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner">GrometPortCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner.align" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.GrometPortCommentAligner.align">align</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner">InnerGrometBoxFunctionCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner.align" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.InnerGrometBoxFunctionCommentAligner.align">align</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner">OuterGrometBoxFunctionCommentAligner</a></code></h4>
<ul class="">
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner.align" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner.align">align</a></code></li>
<li><code><a title="skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner.make_line_docstrings" href="#skema.text_reading.mention_linking.gromet_linker.comment_aligner.OuterGrometBoxFunctionCommentAligner.make_line_docstrings">make_line_docstrings</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>